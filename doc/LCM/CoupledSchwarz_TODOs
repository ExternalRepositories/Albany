
-----------------------Cleanup TODOs---------------------------

1.) Throw error when solutin method = Coupled Schwarz and running with Albany exe in Albany::SolverFactory [Irina].

2.) Incrementing of materials*.xml file name in SchwarzMultiscale constructor [Alejandro].

3.) Check that problem names for all input files are the same and throw error if they're not in 
SchwarzMultiscale constructor [Irina].

4.) Change variable/function names to comply with C++ coding standards [Alejandro].

5.) Further down the line, we'll want to clean up the input files to remove stuff that's not read in 
(e.g., the coupled one won't have a discretization section probably) [TBD -- I suggest we hold 
off on this for now until we decide definitively what'll be read in from what file.].


---------------------Development TODOs------------------------

1.) Put in validatian of parameter lists in LCM::SchwarzMultiscale class (similar to how it's done in 
QCAD::CoupledSchrodingerPoisson; I started it in SchwarzMultiscale.cpp; see getValidProblemParameters 
and getValidAppParameters at the bottom) [Alejandro, perhaps you could do this since you know better
than me what are the valid/required parameters for the problems we're looking at?].

2.) Write function that creates coupled_disc_map_ in LCM::SchwarzMultiscale class [Irina].

3.) Implement get_p_space, get_g_space and get_p_names in SchwarzMultiscale.cpp.  
See get_p_map, get_g_map and get_p_names routines in Piro_Epetra_NECoupledModelEvaluator.cpp. [TBD]

4.) Implement create_W_op() in SchwarzMultiscale.cpp.  Look at create_W function 
in QCAD_CoupledPoissonSchrodinger.cpp as an example.  We may want to write a separate class 
to return the Jacobian operator, as in QCAD. [TBD -- I suggest we hold off on this until we do 
the other easier stuff.  I also suggest in the first attempt we just implement the 
Jacobian for 2 models that are concatenated but not coupled.]

5.) Some trivial function implementations in SchwarzMultiscale.cpp: getNominalValues(),
reportFinalPoint, get_W_factory(), getUpperBounds(), getLowerBounds(), createInArgs() [Irina].

6.) Implement createInArgsImpl() in SchwarzMultiscale.cpp [Irina]

7.) Implement allocateVectors() in SchwarzMultiscale.cpp.  Here we'll create x_init and x_dot_init 
(by concatenating x_init and x_dot_init from each model that's coupled), and then set these for the nominalValues 
object: nominalValues.set_x(...), nominalValues.set_x_dot(...).  See Albany_ModelEvaluatorT.cpp 
and QCAD_CoupledSchrodingerPoisson.cpp. [Irina will put in a template now.  Implementation TBD.]

8.) Once allocateVectors() is implemented, set up nominal values in LCM::SchwarzMultiscale 
constructor.  See Albany_ModelEvaluatorT.cpp.  This is where set_p will be 
set in nominal values.  That's analogous to get_p_init in EpetraExt::ModelEvaluator
[Irina will put in a template now.  Implementation TBD.]

9.) Implement create_DgDx_op_impl and create_DgDx_dot_op_impl in SchwarzMultiscale.cpp. 
See QCAD_CoupledSchrodingerPoisson.cpp for an example. [TBD]

10.) Implement createOutArgsImpl() in SchwarzMultiscale.cpp. [TBD]

11.) Implement evalModelImpl in SchwarzMultiscale.cpp. [TBD]

12.) Whether we need to implement create_DfDp_op_impl depends on whether we'll have distributed 
parameters (see "Questions/Comments/Notes"). [TBD?] 


------------------Questions/Comments/Notes-----------------------------

1.) create_W_prec() is not implemented in Thyra.  This means we will not have a preconditioner 
at the beginning.

2.) get_W_factory() is not needed -- just returns null.

3.) create_DfDp_op_impl is for distributed parameters.  Are we going to have distributed parameters? 
If not, we don't need this function.  QCAD does not have it. 


----------------Development Planning TODOs----------------------------------------

1.) Look at how initial_guess is used throughout the code.  It's used in LCM::SchwarzMultiscale 
to create the apps.

2.) Understand how the output will be done.  In QCAD::CoupledPoissonSchrodinger, a discretization 
object is created just for producing the collected output.  Need to understand how this works and 
how to extend it to our case.  A related question is whether we need to create an observer.  
We would need a routine that breaks up the final concatenated solutions into separate
ones and gives these to the mesh output routines (like separateCombinedVector in QCAD?).

3.) Figure out how we'll hook in Teko for the preconditioner.

-----------------Notes from emails with Andy---------------------------------------

1.) The CouplePS_NOXObserver takes a single vector for the fully coupled problem and
breaks it into separate vectors for output. The single vector has sizes like 4N+3 for
for potential and 3 eigenvectos, and it sends the 5 separate N vectors to exodus
using the eigenvalues as time stamps. 

2.) For all Thyra problems, and almost all EpetraExt problems, there is no Wprec. 
Then the preconditioner is built within Stratimikos based on the parameter list 
entries for Ifpack{2} or ML/MueLu. All of these internal preconditioners require
that W is a RowMatrix (parent abstract class of CRS matrix). If W is just an operator,
we can't do any internal preconditioning and problems must be run without a
preconditioner or with Wprec implemented.

3.) The Teko interface in Albany was done very
quickly when Teko was new. My understanding is that it has evolved since then, 
and the Albany implementation is not something we should look to or build on.
It is now accessible through Stratimikos and we should figure out how to call
it that way. 

4.) Thyra should have clean ways to construct a single vector from views of others, and
a matrix from views of sub-matrices. This will make everything much cleaner if
we can figure out the syntax.  Talk to Roger Pawlowski, Roscoe Bartless, Eric Cyr.
