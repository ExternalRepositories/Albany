<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Albany: a Trilinos-based PDE code: QCAD_SaddleValueResponseFunction.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>QCAD_SaddleValueResponseFunction.cpp</h1>  </div>
</div>
<div class="contents">
<a href="QCAD__SaddleValueResponseFunction_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//*****************************************************************//</span>
<a name="l00002"></a>00002 <span class="comment">//    Albany 2.0:  Copyright 2012 Sandia Corporation               //</span>
<a name="l00003"></a>00003 <span class="comment">//    This Software is released under the BSD license detailed     //</span>
<a name="l00004"></a>00004 <span class="comment">//    in the file &quot;license.txt&quot; in the top-level Albany directory  //</span>
<a name="l00005"></a>00005 <span class="comment">//*****************************************************************//</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;Teuchos_Array.hpp&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;Epetra_LocalMap.h&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;<a class="code" href="Albany__Utils_8hpp.html">Albany_Utils.hpp</a>&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;<a class="code" href="QCAD__SaddleValueResponseFunction_8hpp.html">QCAD_SaddleValueResponseFunction.hpp</a>&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;<a class="code" href="QCAD__GreensFunctionTunneling_8hpp.html">QCAD_GreensFunctionTunneling.hpp</a>&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00012"></a>00012 
<a name="l00014"></a>00014 <span class="keyword">namespace </span>QCAD 
<a name="l00015"></a>00015 {
<a name="l00016"></a>00016   <span class="keywordtype">bool</span> <a class="code" href="namespaceQCAD.html#ac9df0a8006b5ec2519d3f46a3103f687" title="Helper functions.">ptInPolygon</a>(<span class="keyword">const</span> std::vector&lt;QCAD::mathVector&gt;&amp; polygon, <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; pt);
<a name="l00017"></a>00017   <span class="keywordtype">bool</span> <a class="code" href="namespaceQCAD.html#ac9df0a8006b5ec2519d3f46a3103f687" title="Helper functions.">ptInPolygon</a>(<span class="keyword">const</span> std::vector&lt;QCAD::mathVector&gt;&amp; polygon, <span class="keyword">const</span> <span class="keywordtype">double</span>* pt);
<a name="l00018"></a>00018 
<a name="l00019"></a>00019   <span class="keywordtype">void</span> <a class="code" href="namespaceQCAD.html#a985bf075550ffc548624607851d93d1e" title="Helper functions.">gatherVector</a>(std::vector&lt;double&gt;&amp; v, std::vector&lt;double&gt;&amp; gv,
<a name="l00020"></a>00020         <span class="keyword">const</span> Epetra_Comm&amp; comm_);
<a name="l00021"></a>00021   <span class="keywordtype">void</span> <a class="code" href="namespaceQCAD.html#a8146e2aea1832644a7a0dced84e9d80c">getOrdering</a>(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; v, std::vector&lt;int&gt;&amp; ordering);
<a name="l00022"></a>00022   <span class="keywordtype">bool</span> <a class="code" href="namespaceQCAD.html#a75992f4f866ba0dceba1c2d89b756c67">lessOp</a>(std::pair&lt;std::size_t, double&gt; <span class="keyword">const</span>&amp; <a class="code" href="MOR__ExtendedEpetraLapack_8cpp.html#abaab71a1a7c21d8e915288b6945891f6">a</a>,
<a name="l00023"></a>00023         std::pair&lt;std::size_t, double&gt; <span class="keyword">const</span>&amp; b);
<a name="l00024"></a>00024   <span class="keywordtype">double</span> <a class="code" href="namespaceQCAD.html#a60ab2fe2fbbbd5d8e573d61cf5a09f41">averageOfVector</a>(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; v);
<a name="l00025"></a>00025   <span class="keywordtype">double</span> <a class="code" href="namespaceQCAD.html#a42ea78e1e6778716622135e795f00909">distance</a>(<span class="keyword">const</span> std::vector&lt;double&gt;* vCoords, <span class="keywordtype">int</span> ind1, <span class="keywordtype">int</span> ind2, std::size_t nDims);
<a name="l00026"></a>00026 }
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a74140c8032405787fee467d891e8599b" title="Constructor.">QCAD::SaddleValueResponseFunction::</a>
<a name="l00029"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a74140c8032405787fee467d891e8599b">00029</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a74140c8032405787fee467d891e8599b" title="Constructor.">SaddleValueResponseFunction</a>(
<a name="l00030"></a>00030   <span class="keyword">const</span> Teuchos::RCP&lt;Albany::Application&gt;&amp; application,
<a name="l00031"></a>00031   <span class="keyword">const</span> Teuchos::RCP&lt;Albany::AbstractProblem&gt;&amp; problem,
<a name="l00032"></a>00032   <span class="keyword">const</span> Teuchos::RCP&lt;Albany::MeshSpecsStruct&gt;&amp;  ms,
<a name="l00033"></a>00033   <span class="keyword">const</span> Teuchos::RCP&lt;Albany::StateManager&gt;&amp; stateMgr,
<a name="l00034"></a>00034   Teuchos::ParameterList&amp; params) : 
<a name="l00035"></a>00035   Albany::FieldManagerScalarResponseFunction(application, problem, ms, stateMgr),
<a name="l00036"></a>00036   numDims(problem-&gt;spatialDimension()),
<a name="l00037"></a>00037   <a class="code" href="felix__driver_8cpp.html#ab048c6f9fcbcfaa57ce68b00263dbebe">comm</a>(application-&gt;<a class="code" href="namespaceMOR.html#a85a036a1a3311dd507dfb48076c78471">getComm</a>() )
<a name="l00038"></a>00038 {
<a name="l00039"></a>00039   TEUCHOS_TEST_FOR_EXCEPTION (numDims &lt; 2 || numDims &gt; 3, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l00040"></a>00040         &lt;&lt; <span class="stringliteral">&quot;Saddle Point not implemented for &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &lt;&lt; <span class="stringliteral">&quot; dimensions.&quot;</span> &lt;&lt; std::endl); 
<a name="l00041"></a>00041 
<a name="l00042"></a>00042   params.set(<span class="stringliteral">&quot;Response Function&quot;</span>, Teuchos::rcp(<span class="keyword">this</span>,<span class="keyword">false</span>));
<a name="l00043"></a>00043 
<a name="l00044"></a>00044   Teuchos::Array&lt;double&gt; ar;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>   = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Image Point Size&quot;</span>, 0.01);
<a name="l00047"></a>00047   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>     = params.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Number of Image Points&quot;</span>, 10);
<a name="l00048"></a>00048   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa95ae59806dfebdb6fb149ea933b3303">maxTimeStep</a>   = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Max Time Step&quot;</span>, 1.0);
<a name="l00049"></a>00049   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9fc297039b153fbaee78d1df7b325a4d">minTimeStep</a>   = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Min Time Step&quot;</span>, 0.002);
<a name="l00050"></a>00050   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a11d86580790b7891f8184f9b4fd45fdc">maxIterations</a> = params.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Maximum Iterations&quot;</span>, 100);
<a name="l00051"></a>00051   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a38ebd30b78f63593f7e41a6b6cf1e163">backtraceAfterIters</a> = params.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Backtrace After Iteration&quot;</span>, 10000000);
<a name="l00052"></a>00052   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a2e1227060d5dfabbbeafdf3628f63216">convergeTolerance</a>   = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Convergence Tolerance&quot;</span>, 1e-5);
<a name="l00053"></a>00053   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ae8e506d9f60f12afcf63c2e700ae8b7e">minSpringConstant</a>   = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Min Spring Constant&quot;</span>, 1.0);
<a name="l00054"></a>00054   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6780efc76dd1113175f601e6a6892915">maxSpringConstant</a>   = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Max Spring Constant&quot;</span>, 1.0);
<a name="l00055"></a>00055   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a> = params.get&lt;std::string&gt;(<span class="stringliteral">&quot;Output Filename&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00056"></a>00056   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a14f626be3dcc22d873e69c225dbef70a">debugFilename</a>  = params.get&lt;std::string&gt;(<span class="stringliteral">&quot;Debug Filename&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00057"></a>00057   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8c500245dfdd249ede1bdd9d38d0166a">appendOutput</a>   = params.get&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;Append Output&quot;</span>, <span class="keyword">false</span>);
<a name="l00058"></a>00058   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a3b4f189eadef077456f2d80944c32cf2">nEvery</a>         = params.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Output Interval&quot;</span>, 0);
<a name="l00059"></a>00059   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad03496cc58cc9ffb598ecf2e8e232478">bClimbing</a>      = params.get&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;Climbing NEB&quot;</span>, <span class="keyword">true</span>);
<a name="l00060"></a>00060   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ac54f7aaee83b91ed0f2398fa709d12ec">antiKinkFactor</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Anti-Kink Factor&quot;</span>, 0.0);
<a name="l00061"></a>00061   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8fdd456a00773defd2b33e0abe645ed9" title="data for memory-intensive but fast mode (hold entire proc&amp;#39;s data)">bAggregateWorksets</a> = params.get&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;Aggregate Worksets&quot;</span>, <span class="keyword">false</span>);
<a name="l00062"></a>00062   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ae2b96d9132a7ff7bf8e04d119907fb04">bAdaptivePointSize</a> = params.get&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;Adaptive Image Point Size&quot;</span>, <span class="keyword">false</span>);
<a name="l00063"></a>00063   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9e79fbe9346261b217f99c2a982e02b8">minAdaptivePointWt</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Adaptive Min Point Weight&quot;</span>, 5);
<a name="l00064"></a>00064   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1457d05d60c7f82d5494893860519bcf">maxAdaptivePointWt</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Adaptive Max Point Weight&quot;</span>, 10);
<a name="l00065"></a>00065   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a910e72d12939294612677c688243a5af">shortenBeginPc</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Percent to Shorten Begin&quot;</span>, 0);
<a name="l00066"></a>00066   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b44566fa28e8db917dd821b4f669b29">shortenEndPc</a>   = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Percent to Shorten End&quot;</span>, 0);
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a960cd671db6d61697a25bbbc7cb11963">fieldCutoffFctr</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Levelset Field Cutoff Factor&quot;</span>, 1.0);
<a name="l00069"></a>00069   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab533be8589780edc525b58128d140f9d">minPoolDepthFctr</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Levelset Minimum Pool Depth Factor&quot;</span>, 1.0);
<a name="l00070"></a>00070   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a80a75097d3e22f7ce0a9064069bd0b9c">distanceCutoffFctr</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Levelset Distance Cutoff Factor&quot;</span>, 1.0);
<a name="l00071"></a>00071   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a19bd8b4b06d315c750dff8d2a0d3ee15">levelSetRadius</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Levelset Radius&quot;</span>, 0);
<a name="l00072"></a>00072 
<a name="l00073"></a>00073   <span class="comment">// set default maxFinalPts to nImagePts</span>
<a name="l00074"></a>00074   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab538db72e79b9f717b66270ea40db992" title="data for final points (just used at end to get more data pts along saddle path)">maxFinalPts</a> = params.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Maximum Number of Final Points&quot;</span>, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>);
<a name="l00075"></a>00075   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6f29fc3cf29ab3ff0b75047fcebadde7">gfGridSpacing</a>  = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;GF-CBR Method Grid Spacing&quot;</span>, 0.0005);
<a name="l00076"></a>00076   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a7aca2519a95a2d89ee4f41f7c02fec2a">fieldScaling</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Field Scaling Factor&quot;</span>, 1.0);
<a name="l00077"></a>00077   
<a name="l00078"></a>00078   <span class="comment">// set Vds information</span>
<a name="l00079"></a>00079   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a586a9ebce70f47b368988c86da2f0953">bSweepVds</a> = params.get&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;GF-CBR Method Vds Sweep&quot;</span>, <span class="keyword">false</span>);
<a name="l00080"></a>00080   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab1d424aa287aaa0249735252f07b9a92">initVds</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;GF-CBR Method Vds Initial Value&quot;</span>, 0.0);
<a name="l00081"></a>00081   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8a651fe609f9ba267c05c82f7fc13e01">finalVds</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;GF-CBR Method Vds Final Value&quot;</span>, 0.0);
<a name="l00082"></a>00082   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#abc188c25699c0b3883d2d9ede13844ea">stepsVds</a> = params.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;GF-CBR Method Vds Steps&quot;</span>, 0);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="comment">// specify the eigensolver to be used for the GF-CBR calculation</span>
<a name="l00085"></a>00085   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a2ff5d5a63e5e13843c62f791d9ac063c">gfEigensolver</a> = params.get&lt;std::string&gt;(<span class="stringliteral">&quot;GF-CBR Method Eigensolver&quot;</span>, <span class="stringliteral">&quot;tql2&quot;</span>);
<a name="l00086"></a>00086   std::cout &lt;&lt; <span class="stringliteral">&quot;gfEigensolver = &quot;</span> &lt;&lt; gfEigensolver &lt;&lt; std::endl; 
<a name="l00087"></a>00087   
<a name="l00088"></a>00088   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aed5ca26c78e24d3b5dfba4d92dc0b828">bGetCurrent</a> = (params.get&lt;std::string&gt;(<span class="stringliteral">&quot;Return Field Name&quot;</span>, <span class="stringliteral">&quot;&quot;</span>) == <span class="stringliteral">&quot;current&quot;</span>);
<a name="l00089"></a>00089   
<a name="l00090"></a>00090   <span class="comment">// set default value to 0.5 eV (always want a positive value)</span>
<a name="l00091"></a>00091   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a679b40860f4539eb242a6a85ea666496">current_Ecutoff_offset_from_Emax</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;GF-CBR Method Energy Cutoff Offset&quot;</span>, 0.5);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="keywordflow">if</span>(backtraceAfterIters &lt; 0) backtraceAfterIters = 10000000;
<a name="l00094"></a>00094   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(backtraceAfterIters &lt;= 1) backtraceAfterIters = 2; <span class="comment">// can&#39;t backtrace until the second iteration</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a3dfbfb1de5e7cc235d821b982ae12c13">bLockToPlane</a> = <span class="keyword">false</span>;
<a name="l00097"></a>00097   <span class="keywordflow">if</span>(params.isParameter(<span class="stringliteral">&quot;Lock to z-coord&quot;</span>)) {
<a name="l00098"></a>00098     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a3dfbfb1de5e7cc235d821b982ae12c13">bLockToPlane</a> = <span class="keyword">true</span>;
<a name="l00099"></a>00099     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a25d37323f7be8aa498372a703430d38d">lockedZ</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Lock to z-coord&quot;</span>);
<a name="l00100"></a>00100   }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a> = -1;        <span class="comment">//clear &quot;found&quot; saddle point index</span>
<a name="l00103"></a>00103   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa92848b0ec3bc572a589cb7fdf009f4c">returnFieldVal</a> = -1.0; <span class="comment">//init to nonzero is important - so doesn&#39;t &quot;match&quot; default init</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105   <span class="comment">//Beginning target region</span>
<a name="l00106"></a>00106   <span class="keywordflow">if</span>(params.isParameter(<span class="stringliteral">&quot;Begin Point&quot;</span>)) {
<a name="l00107"></a>00107     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a92332cbc05e63bcb209b4682dabcd751" title="data for beginning and ending regions">beginRegionType</a> = <span class="stringliteral">&quot;Point&quot;</span>;
<a name="l00108"></a>00108     ar = params.get&lt;Teuchos::Array&lt;double&gt; &gt;(<span class="stringliteral">&quot;Begin Point&quot;</span>);
<a name="l00109"></a>00109     TEUCHOS_TEST_FOR_EXCEPTION (ar.size() != (int)<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l00110"></a>00110         &lt;&lt; <span class="stringliteral">&quot;Begin Point does not have &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &lt;&lt; <span class="stringliteral">&quot; elements&quot;</span> &lt;&lt; std::endl); 
<a name="l00111"></a>00111     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1c056f042b14462cdd409a9c3ba5d805">beginPolygon</a>.resize(1); <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1c056f042b14462cdd409a9c3ba5d805">beginPolygon</a>[0].resize(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);
<a name="l00112"></a>00112     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; i++) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1c056f042b14462cdd409a9c3ba5d805">beginPolygon</a>[0][i] = ar[i];
<a name="l00113"></a>00113   }
<a name="l00114"></a>00114   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(params.isParameter(<span class="stringliteral">&quot;Begin Element Block&quot;</span>)) {
<a name="l00115"></a>00115     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a92332cbc05e63bcb209b4682dabcd751" title="data for beginning and ending regions">beginRegionType</a> = <span class="stringliteral">&quot;Element Block&quot;</span>;
<a name="l00116"></a>00116     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af4bf80d249a7563bfe291c7dda2f08ab">beginElementBlock</a> = params.get&lt;std::string&gt;(<span class="stringliteral">&quot;Begin Element Block&quot;</span>);
<a name="l00117"></a>00117   }
<a name="l00118"></a>00118   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(params.isSublist(<span class="stringliteral">&quot;Begin Polygon&quot;</span>)) {
<a name="l00119"></a>00119     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a92332cbc05e63bcb209b4682dabcd751" title="data for beginning and ending regions">beginRegionType</a> = <span class="stringliteral">&quot;Polygon&quot;</span>;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     Teuchos::ParameterList&amp; polyList = params.sublist(<span class="stringliteral">&quot;Begin Polygon&quot;</span>);
<a name="l00122"></a>00122     <span class="keywordtype">int</span> nPts = polyList.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Number of Points&quot;</span>);
<a name="l00123"></a>00123     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1c056f042b14462cdd409a9c3ba5d805">beginPolygon</a>.resize(nPts); 
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nPts; i++) {
<a name="l00126"></a>00126       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1c056f042b14462cdd409a9c3ba5d805">beginPolygon</a>[i].resize(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);
<a name="l00127"></a>00127       ar = polyList.get&lt;Teuchos::Array&lt;double&gt; &gt;( <a class="code" href="namespaceAlbany.html#a0825dc2de792b06ebb1ded9784d6a111" title="Utility to make a string out of a string + int: strint(&amp;quot;dog&amp;quot;,2) = &amp;quot;dog 2&amp;quot;...">Albany::strint</a>(<span class="stringliteral">&quot;Point&quot;</span>,i) );
<a name="l00128"></a>00128       TEUCHOS_TEST_FOR_EXCEPTION (ar.size() != (int)<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l00129"></a>00129           &lt;&lt; <span class="stringliteral">&quot;Begin polygon point does not have &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &lt;&lt; <span class="stringliteral">&quot; elements&quot;</span> &lt;&lt; std::endl); 
<a name="l00130"></a>00130       <span class="keywordflow">for</span>(std::size_t k=0; k&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; k++) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1c056f042b14462cdd409a9c3ba5d805">beginPolygon</a>[i][k] = ar[k];
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132   }
<a name="l00133"></a>00133   <span class="keywordflow">else</span> TEUCHOS_TEST_FOR_EXCEPTION (<span class="keyword">true</span>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l00134"></a>00134           &lt;&lt; <span class="stringliteral">&quot;No beginning region specified for saddle pt&quot;</span> &lt;&lt; std::endl); 
<a name="l00135"></a>00135 
<a name="l00136"></a>00136   
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   <span class="comment">//Ending target region</span>
<a name="l00139"></a>00139   <span class="keywordflow">if</span>(params.isParameter(<span class="stringliteral">&quot;End Point&quot;</span>)) {
<a name="l00140"></a>00140     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a55bb9c99a5099665866ce146d9c9db2f">endRegionType</a> = <span class="stringliteral">&quot;Point&quot;</span>;
<a name="l00141"></a>00141     ar = params.get&lt;Teuchos::Array&lt;double&gt; &gt;(<span class="stringliteral">&quot;End Point&quot;</span>);
<a name="l00142"></a>00142     TEUCHOS_TEST_FOR_EXCEPTION (ar.size() != (int)<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l00143"></a>00143         &lt;&lt; <span class="stringliteral">&quot;End Point does not have &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &lt;&lt; <span class="stringliteral">&quot; elements&quot;</span> &lt;&lt; std::endl); 
<a name="l00144"></a>00144     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d7a5d254466509a078a966310a5b498">endPolygon</a>.resize(1); <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d7a5d254466509a078a966310a5b498">endPolygon</a>[0].resize(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);
<a name="l00145"></a>00145     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; i++) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d7a5d254466509a078a966310a5b498">endPolygon</a>[0][i] = ar[i];
<a name="l00146"></a>00146   }
<a name="l00147"></a>00147   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(params.isParameter(<span class="stringliteral">&quot;End Element Block&quot;</span>)) {
<a name="l00148"></a>00148     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a55bb9c99a5099665866ce146d9c9db2f">endRegionType</a> = <span class="stringliteral">&quot;Element Block&quot;</span>;
<a name="l00149"></a>00149     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1a5918863849eba95eaa460cfc0bbe8f">endElementBlock</a> = params.get&lt;std::string&gt;(<span class="stringliteral">&quot;End Element Block&quot;</span>);
<a name="l00150"></a>00150   }
<a name="l00151"></a>00151   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(params.isSublist(<span class="stringliteral">&quot;End Polygon&quot;</span>)) {
<a name="l00152"></a>00152     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a55bb9c99a5099665866ce146d9c9db2f">endRegionType</a> = <span class="stringliteral">&quot;Polygon&quot;</span>;
<a name="l00153"></a>00153     
<a name="l00154"></a>00154     Teuchos::ParameterList&amp; polyList = params.sublist(<span class="stringliteral">&quot;End Polygon&quot;</span>);
<a name="l00155"></a>00155     <span class="keywordtype">int</span> nPts = polyList.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Number of Points&quot;</span>);
<a name="l00156"></a>00156     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d7a5d254466509a078a966310a5b498">endPolygon</a>.resize(nPts); 
<a name="l00157"></a>00157     
<a name="l00158"></a>00158     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nPts; i++) {
<a name="l00159"></a>00159       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d7a5d254466509a078a966310a5b498">endPolygon</a>[i].resize(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);
<a name="l00160"></a>00160       ar = polyList.get&lt;Teuchos::Array&lt;double&gt; &gt;( <a class="code" href="namespaceAlbany.html#a0825dc2de792b06ebb1ded9784d6a111" title="Utility to make a string out of a string + int: strint(&amp;quot;dog&amp;quot;,2) = &amp;quot;dog 2&amp;quot;...">Albany::strint</a>(<span class="stringliteral">&quot;Point&quot;</span>,i) );
<a name="l00161"></a>00161       TEUCHOS_TEST_FOR_EXCEPTION (ar.size() != (int)<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l00162"></a>00162           &lt;&lt; <span class="stringliteral">&quot;End polygon point does not have &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &lt;&lt; <span class="stringliteral">&quot; elements&quot;</span> &lt;&lt; std::endl); 
<a name="l00163"></a>00163       <span class="keywordflow">for</span>(std::size_t k=0; k&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; k++) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d7a5d254466509a078a966310a5b498">endPolygon</a>[i][k] = ar[k];
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166   <span class="keywordflow">else</span> TEUCHOS_TEST_FOR_EXCEPTION (<span class="keyword">true</span>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l00167"></a>00167           &lt;&lt; <span class="stringliteral">&quot;No ending region specified for saddle pt&quot;</span> &lt;&lt; std::endl); 
<a name="l00168"></a>00168   
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <span class="comment">//Guess at the saddle point</span>
<a name="l00171"></a>00171   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a78083f6cfa7b40553dcc5a86ea469275">saddleGuessGiven</a> = <span class="keyword">false</span>;
<a name="l00172"></a>00172   <span class="keywordflow">if</span>(params.isParameter(<span class="stringliteral">&quot;Saddle Point Guess&quot;</span>)) {
<a name="l00173"></a>00173     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a78083f6cfa7b40553dcc5a86ea469275">saddleGuessGiven</a> = <span class="keyword">true</span>;
<a name="l00174"></a>00174     ar = params.get&lt;Teuchos::Array&lt;double&gt; &gt;(<span class="stringliteral">&quot;Saddle Point Guess&quot;</span>);
<a name="l00175"></a>00175     TEUCHOS_TEST_FOR_EXCEPTION (ar.size() != (int)<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l00176"></a>00176         &lt;&lt; <span class="stringliteral">&quot;Saddle point guess does not have &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &lt;&lt; <span class="stringliteral">&quot; elements&quot;</span> &lt;&lt; std::endl); 
<a name="l00177"></a>00177     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a522c5ddba4fcc442013aad5648b47def">saddlePointGuess</a>.<a class="code" href="classQCAD_1_1mathVector.html#adea02471efe6c010c0ef58801b437de1">resize</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);
<a name="l00178"></a>00178     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; i++) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a522c5ddba4fcc442013aad5648b47def">saddlePointGuess</a>[i] = ar[i];
<a name="l00179"></a>00179   }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a76487b548ee7abe49b7b2d99bdc53013">debugMode</a> = params.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Debug Mode&quot;</span>,0);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>.resize(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>);
<a name="l00184"></a>00184   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a60d3435342ec9032dd55e4dac1378533" title="accumulation vectors for evaluator to fill">imagePtValues</a>.<a class="code" href="classQCAD_1_1mathVector.html#adea02471efe6c010c0ef58801b437de1">resize</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>);
<a name="l00185"></a>00185   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab59d0d98b3cec0fbab0055e4941d33b5">imagePtWeights</a>.<a class="code" href="classQCAD_1_1mathVector.html#adea02471efe6c010c0ef58801b437de1">resize</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>);
<a name="l00186"></a>00186   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d706bcd0aab5b33aa17e424145b074b">imagePtGradComps</a>.<a class="code" href="classQCAD_1_1mathVector.html#adea02471efe6c010c0ef58801b437de1">resize</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);
<a name="l00187"></a>00187 
<a name="l00188"></a>00188   <span class="comment">// Add allowed z-range if in 3D (lateral volume assumed)</span>
<a name="l00189"></a>00189   <span class="comment">//  - rest (xmin, etc) computed dynamically</span>
<a name="l00190"></a>00190   <span class="keywordflow">if</span>(numDims &gt; 2) {
<a name="l00191"></a>00191     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaecb6aeeb3b94887c23e820532ef04e">zmin</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;z min&quot;</span>);
<a name="l00192"></a>00192     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a09cf85ec53115a72e0c81b8704046ec5">zmax</a> = params.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;z max&quot;</span>);
<a name="l00193"></a>00193   }  
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   this-&gt;<a class="code" href="classAlbany_1_1ScalarResponseFunction.html#a2f83b725302a61f5be983b5d8eb6fd73" title="Setup response function.">setup</a>(params);
<a name="l00196"></a>00196   this-&gt;<a class="code" href="classAlbany_1_1FieldManagerScalarResponseFunction.html#a0d7d574dedcf45e1b9bf20977f0be561" title="Number of responses we compute.">num_responses</a> = 5;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8094f77d09d5941687c543fcfdcc13c3" title="Destructor.">QCAD::SaddleValueResponseFunction::</a>
<a name="l00200"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8094f77d09d5941687c543fcfdcc13c3">00200</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8094f77d09d5941687c543fcfdcc13c3" title="Destructor.">~SaddleValueResponseFunction</a>()
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00205"></a>00205 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6ac59d4673606f35752d59869b527fdb" title="Get the number of responses.">QCAD::SaddleValueResponseFunction::</a>
<a name="l00206"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6ac59d4673606f35752d59869b527fdb">00206</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6ac59d4673606f35752d59869b527fdb" title="Get the number of responses.">numResponses</a>()<span class="keyword"> const </span>
<a name="l00207"></a>00207 <span class="keyword"></span>{
<a name="l00208"></a>00208   <span class="keywordflow">return</span> this-&gt;<a class="code" href="classAlbany_1_1FieldManagerScalarResponseFunction.html#a0d7d574dedcf45e1b9bf20977f0be561" title="Number of responses we compute.">num_responses</a>;  <span class="comment">// returnFieldValue, fieldValue, saddleX, saddleY, saddleZ</span>
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="keywordtype">void</span>
<a name="l00212"></a>00212 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46" title="Evaluate responses.">QCAD::SaddleValueResponseFunction::</a>
<a name="l00213"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46">00213</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46" title="Evaluate responses.">evaluateResponse</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l00214"></a>00214          <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l00215"></a>00215          <span class="keyword">const</span> Epetra_Vector* xdotdot,
<a name="l00216"></a>00216          <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l00217"></a>00217          <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l00218"></a>00218          Epetra_Vector&amp; <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>)
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220   <span class="keywordtype">int</span> dbMode = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;MyPID() == 0) ? <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a76487b548ee7abe49b7b2d99bdc53013">debugMode</a> : 0;
<a name="l00221"></a>00221   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;MyPID() != 0) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a> = <span class="stringliteral">&quot;&quot;</span>; <span class="comment">//Only root process outputs to files</span>
<a name="l00222"></a>00222   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;MyPID() != 0) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a14f626be3dcc22d873e69c225dbef70a">debugFilename</a> = <span class="stringliteral">&quot;&quot;</span>; <span class="comment">//Only root process outputs to files</span>
<a name="l00223"></a>00223   
<a name="l00224"></a>00224   TEUCHOS_TEST_FOR_EXCEPTION (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a> &lt; 2, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l00225"></a>00225         &lt;&lt; <span class="stringliteral">&quot;Saddle Point needs more than 2 image pts (&quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a> &lt;&lt; <span class="stringliteral">&quot; given)&quot;</span> &lt;&lt; std::endl); 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   <span class="comment">// Clear output file if we&#39;re not told to append output</span>
<a name="l00228"></a>00228   <span class="keywordflow">if</span>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a>.length() &gt; 0) {
<a name="l00229"></a>00229     std::fstream out;
<a name="l00230"></a>00230     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8c500245dfdd249ede1bdd9d38d0166a">appendOutput</a>) {
<a name="l00231"></a>00231       out.open(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a>.c_str(), std::fstream::out | <a class="code" href="InterfaceTry_8cpp.html#a5687d6d7d8e1356f9cbed0616b9e7cec">std::fstream::app</a>);
<a name="l00232"></a>00232       out &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&quot;</span> &lt;&lt; std::endl; <span class="comment">// to separate new data</span>
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234     <span class="keywordflow">else</span> out.open(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a>.c_str(), std::fstream::out);
<a name="l00235"></a>00235     out.close();
<a name="l00236"></a>00236   }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238   <span class="comment">// Find saddle point in stages:</span>
<a name="l00239"></a>00239  
<a name="l00240"></a>00240   <span class="comment">//  1) Initialize image points</span>
<a name="l00241"></a>00241   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a996f928d67d97d4a421507ccb8c347c1" title="Helper functions for Nudged Elastic Band (NEB) algorithm, performed in evaluateResponse.">initializeImagePoints</a>(current_time, xdot, x, p, g, dbMode);
<a name="l00242"></a>00242   
<a name="l00243"></a>00243   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a11d86580790b7891f8184f9b4fd45fdc">maxIterations</a> &gt; 0) {
<a name="l00244"></a>00244     <span class="comment">//  2) Perform Nudged Elastic Band (NEB) algorithm on image points (iterative)</span>
<a name="l00245"></a>00245     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aefa1eebc84c37bd509a2723957b270b9">doNudgedElasticBand</a>(current_time, xdot, x, p, g, dbMode);
<a name="l00246"></a>00246   }
<a name="l00247"></a>00247   <span class="keywordflow">else</span> {
<a name="l00248"></a>00248     <span class="comment">// If no NEB iteractions, choose center image point as saddle point</span>
<a name="l00249"></a>00249     <span class="keywordtype">int</span> nFirstLeg = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>+1)/2, iCenter = nFirstLeg-1;
<a name="l00250"></a>00250     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a> = iCenter; <span class="comment">//don&#39;t need to check for positive weight at this point</span>
<a name="l00251"></a>00251   }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253   <span class="comment">//  3) Perform level-set method in a radius around saddle image point</span>
<a name="l00254"></a>00254   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aef9194b98a66f3150b3f507b2612cc1f" title="Helper functions for level-set algorithm, performed in evaluateResponse.">doLevelSet</a>(current_time, xdot, x, p, g, dbMode);
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <span class="comment">//  4) Get data at &quot;final points&quot; which can be more dense than neb image points, if desired</span>
<a name="l00257"></a>00257   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a11d86580790b7891f8184f9b4fd45fdc">maxIterations</a> &gt; 0 &amp;&amp; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab538db72e79b9f717b66270ea40db992" title="data for final points (just used at end to get more data pts along saddle path)">maxFinalPts</a> &gt; 0) {
<a name="l00258"></a>00258     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a135424776e2da27a6d5594ad48834598">initializeFinalImagePoints</a>(current_time, xdot, x, p, g, dbMode);
<a name="l00259"></a>00259     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1e008acff131377db975e6763e38e61f">getFinalImagePointValues</a>(current_time, xdot, x, p, g, dbMode);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     <span class="comment">// append &quot;final point&quot; data to output</span>
<a name="l00262"></a>00262     <span class="keywordflow">if</span>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a>.length() &gt; 0) {
<a name="l00263"></a>00263       std::fstream out; <span class="keywordtype">double</span> pathLength = 0.0;
<a name="l00264"></a>00264       out.open(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a>.c_str(), std::fstream::out | <a class="code" href="InterfaceTry_8cpp.html#a5687d6d7d8e1356f9cbed0616b9e7cec">std::fstream::app</a>);
<a name="l00265"></a>00265       out &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;% Saddle point path - interpolated &#39;final&#39; points&quot;</span> &lt;&lt; std::endl;
<a name="l00266"></a>00266       out &lt;&lt; <span class="stringliteral">&quot;% index xCoord yCoord value pathLength pointRadius&quot;</span> &lt;&lt; std::endl;
<a name="l00267"></a>00267       <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>.size(); i++) {
<a name="l00268"></a>00268   out &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].coords[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].coords[1] 
<a name="l00269"></a>00269       &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].value &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; pathLength &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].radius &lt;&lt; std::endl;
<a name="l00270"></a>00270   <span class="keywordflow">if</span>(i &lt; (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>.size()-1)) pathLength += <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].coords.distanceTo(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i+1].coords);
<a name="l00271"></a>00271       }
<a name="l00272"></a>00272       out.close();
<a name="l00273"></a>00273     }
<a name="l00274"></a>00274   }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276   <span class="comment">//  5) Fill response (g-vector) with values near the highest image point (computes current if desired)</span>
<a name="l00277"></a>00277   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#abf6ba82dbb25a70cdad8b72d27360240">fillSaddlePointData</a>(current_time, xdot, x, p, g, dbMode);
<a name="l00278"></a>00278 
<a name="l00279"></a>00279   <span class="keywordflow">return</span>;
<a name="l00280"></a>00280 }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="keywordtype">void</span>
<a name="l00284"></a>00284 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a996f928d67d97d4a421507ccb8c347c1" title="Helper functions for Nudged Elastic Band (NEB) algorithm, performed in evaluateResponse.">QCAD::SaddleValueResponseFunction::</a>
<a name="l00285"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a996f928d67d97d4a421507ccb8c347c1">00285</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a996f928d67d97d4a421507ccb8c347c1" title="Helper functions for Nudged Elastic Band (NEB) algorithm, performed in evaluateResponse.">initializeImagePoints</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l00286"></a>00286          <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l00287"></a>00287          <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l00288"></a>00288          <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l00289"></a>00289          Epetra_Vector&amp; <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>, <span class="keywordtype">int</span> dbMode)
<a name="l00290"></a>00290 {
<a name="l00291"></a>00291   <span class="comment">// 1) Determine initial and final points depending on region type</span>
<a name="l00292"></a>00292   <span class="comment">//     - Point: take point given directly</span>
<a name="l00293"></a>00293   <span class="comment">//     - Element Block: take minimum point within the specified element block (and allowed z-range)</span>
<a name="l00294"></a>00294   <span class="comment">//     - Polygon: take minimum point within specified 2D polygon and allowed z-range</span>
<a name="l00295"></a>00295   
<a name="l00296"></a>00296   <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  Beginning end point location&quot;</span> &lt;&lt; std::endl;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     <span class="comment">// Initialize intial/final points</span>
<a name="l00299"></a>00299   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].init(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>);
<a name="l00300"></a>00300   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].init(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f448b8545d73515c1606edbb9a4d664" title="mode of current evaluator operation (maybe not thread safe?)">mode</a> = <span class="stringliteral">&quot;Point location&quot;</span>;
<a name="l00303"></a>00303   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46" title="Evaluate responses.">Albany::FieldManagerScalarResponseFunction::evaluateResponse</a>(
<a name="l00304"></a>00304   current_time, xdot, NULL, x, p, g);
<a name="l00305"></a>00305   <span class="keywordflow">if</span>(dbMode &gt; 2) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:   -- done evaluation&quot;</span> &lt;&lt; std::endl;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a92332cbc05e63bcb209b4682dabcd751" title="data for beginning and ending regions">beginRegionType</a> == <span class="stringliteral">&quot;Point&quot;</span>) {
<a name="l00308"></a>00308     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1c056f042b14462cdd409a9c3ba5d805">beginPolygon</a>[0];
<a name="l00309"></a>00309   }
<a name="l00310"></a>00310   <span class="keywordflow">else</span> { 
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="comment">//MPI: get global min for begin point</span>
<a name="l00313"></a>00313     <span class="keywordtype">double</span> globalMin; <span class="keywordtype">int</span> procToBcast, winner;
<a name="l00314"></a>00314     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;MinAll( &amp;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].value, &amp;globalMin, 1);
<a name="l00315"></a>00315     <span class="keywordflow">if</span>( fabs(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].value - globalMin) &lt; 1e-8 ) 
<a name="l00316"></a>00316       procToBcast = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;MyPID();
<a name="l00317"></a>00317     <span class="keywordflow">else</span> procToBcast = -1;
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;MaxAll( &amp;procToBcast, &amp;winner, 1 );
<a name="l00320"></a>00320     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;Broadcast( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords.data(), <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>, winner); <span class="comment">//broadcast winner&#39;s min position to others</span>
<a name="l00321"></a>00321     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].value = globalMin;                               <span class="comment">//no need to broadcast winner&#39;s value</span>
<a name="l00322"></a>00322   }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a55bb9c99a5099665866ce146d9c9db2f">endRegionType</a>   == <span class="stringliteral">&quot;Point&quot;</span>) {
<a name="l00325"></a>00325     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d7a5d254466509a078a966310a5b498">endPolygon</a>[0];
<a name="l00326"></a>00326   }
<a name="l00327"></a>00327   <span class="keywordflow">else</span> { 
<a name="l00328"></a>00328 
<a name="l00329"></a>00329     <span class="comment">//MPI: get global min for end point</span>
<a name="l00330"></a>00330     <span class="keywordtype">double</span> globalMin; <span class="keywordtype">int</span> procToBcast, winner;
<a name="l00331"></a>00331     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;MinAll( &amp;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].value, &amp;globalMin, 1);
<a name="l00332"></a>00332     <span class="keywordflow">if</span>( fabs(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].value - globalMin) &lt; 1e-8 ) 
<a name="l00333"></a>00333       procToBcast = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;MyPID();
<a name="l00334"></a>00334     <span class="keywordflow">else</span> procToBcast = -1;
<a name="l00335"></a>00335 
<a name="l00336"></a>00336     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;MaxAll( &amp;procToBcast, &amp;winner, 1 );
<a name="l00337"></a>00337     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;Broadcast( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords.data(), <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>, winner); <span class="comment">//broadcast winner&#39;s min position to others</span>
<a name="l00338"></a>00338     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].value = globalMin;                               <span class="comment">//no need to broadcast winner&#39;s value</span>
<a name="l00339"></a>00339   }
<a name="l00340"></a>00340 
<a name="l00342"></a>00342   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a910e72d12939294612677c688243a5af">shortenBeginPc</a> &gt; 1e-6) {
<a name="l00343"></a>00343      <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a78083f6cfa7b40553dcc5a86ea469275">saddleGuessGiven</a>)
<a name="l00344"></a>00344        <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords + (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a522c5ddba4fcc442013aad5648b47def">saddlePointGuess</a> - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords) * (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a910e72d12939294612677c688243a5af">shortenBeginPc</a>/100.0);
<a name="l00345"></a>00345      <span class="keywordflow">else</span>
<a name="l00346"></a>00346        <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords + (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords) * (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a910e72d12939294612677c688243a5af">shortenBeginPc</a>/100.0);
<a name="l00347"></a>00347   }
<a name="l00348"></a>00348   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b44566fa28e8db917dd821b4f669b29">shortenEndPc</a> &gt; 1e-6) {
<a name="l00349"></a>00349      <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a78083f6cfa7b40553dcc5a86ea469275">saddleGuessGiven</a>)
<a name="l00350"></a>00350        <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords + (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a522c5ddba4fcc442013aad5648b47def">saddlePointGuess</a> - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords) * (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b44566fa28e8db917dd821b4f669b29">shortenEndPc</a>/100.0);
<a name="l00351"></a>00351      <span class="keywordflow">else</span>
<a name="l00352"></a>00352        <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords + (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords) * (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b44566fa28e8db917dd821b4f669b29">shortenEndPc</a>/100.0);
<a name="l00353"></a>00353   }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355   <span class="keywordflow">if</span>(dbMode &gt; 2) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:   -- done begin/end point initialization&quot;</span> &lt;&lt; std::endl;
<a name="l00356"></a>00356 
<a name="l00358"></a>00358   <span class="comment">//   interpolate between initial and final points (and possibly guess point) </span>
<a name="l00359"></a>00359   <span class="comment">//   to get all the image points</span>
<a name="l00360"></a>00360   <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; initialPt = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords;
<a name="l00361"></a>00361   <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; finalPt   = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363   <span class="comment">// Lock z-coordinate of initial and final points (and therefore of the rest of the points) if requested</span>
<a name="l00364"></a>00364   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a3dfbfb1de5e7cc235d821b982ae12c13">bLockToPlane</a> &amp;&amp; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &gt; 2)
<a name="l00365"></a>00365     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords[2] = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1].coords[2] = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a25d37323f7be8aa498372a703430d38d">lockedZ</a>;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a78083f6cfa7b40553dcc5a86ea469275">saddleGuessGiven</a>) {
<a name="l00368"></a>00368 
<a name="l00369"></a>00369     <span class="comment">// two line segements (legs) initialPt -&gt; guess, guess -&gt; finalPt</span>
<a name="l00370"></a>00370     <span class="keywordtype">int</span> nFirstLeg = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>+1)/2, nSecondLeg = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a> - nFirstLeg + 1; <span class="comment">// +1 because both legs include middle pt</span>
<a name="l00371"></a>00371     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i&lt;nFirstLeg-1; i++) {
<a name="l00372"></a>00372       <span class="keywordtype">double</span> s = i * 1.0/(nFirstLeg-1);
<a name="l00373"></a>00373       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].init(initialPt + (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a522c5ddba4fcc442013aad5648b47def">saddlePointGuess</a> - initialPt) * s, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>);
<a name="l00374"></a>00374     }
<a name="l00375"></a>00375     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nSecondLeg-1; i++) {
<a name="l00376"></a>00376       <span class="keywordtype">double</span> s = i * 1.0/(nSecondLeg-1);
<a name="l00377"></a>00377       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+nFirstLeg-1].init(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a522c5ddba4fcc442013aad5648b47def">saddlePointGuess</a> + (finalPt - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a522c5ddba4fcc442013aad5648b47def">saddlePointGuess</a>) * s, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>);
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379   }
<a name="l00380"></a>00380   <span class="keywordflow">else</span> {
<a name="l00381"></a>00381 
<a name="l00382"></a>00382     <span class="comment">// one line segment initialPt -&gt; finalPt</span>
<a name="l00383"></a>00383     <span class="keywordflow">for</span>(std::size_t i=1; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1; i++) {
<a name="l00384"></a>00384       <span class="keywordtype">double</span> s = i * 1.0/(nImagePts-1);   <span class="comment">// nIntervals = nImagePts-1</span>
<a name="l00385"></a>00385       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].init(initialPt + (finalPt - initialPt) * s, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>);
<a name="l00386"></a>00386     }     
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388  
<a name="l00389"></a>00389   <span class="comment">// Print initial point locations to stdout if requested</span>
<a name="l00390"></a>00390   <span class="keywordflow">if</span>(dbMode &gt; 1) {
<a name="l00391"></a>00391     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>; i++)
<a name="l00392"></a>00392       std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:   -- imagePt[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords &lt;&lt; std::endl;
<a name="l00393"></a>00393   }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   <span class="comment">// If we aggregate workset data then call evaluator once more to accumulate </span>
<a name="l00396"></a>00396   <span class="comment">//  field and coordinate data into vFieldValues and vCoords members.</span>
<a name="l00397"></a>00397   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8fdd456a00773defd2b33e0abe645ed9" title="data for memory-intensive but fast mode (hold entire proc&amp;#39;s data)">bAggregateWorksets</a>) {
<a name="l00398"></a>00398     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a7f7ef926162ac95e9027e6a761f2dfa6">vFieldValues</a>.clear();
<a name="l00399"></a>00399     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a07d6c1f20454560f5a2d56b2dcc47efc">vCoords</a>.clear();
<a name="l00400"></a>00400     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad2a4803f00148f8a686eb1a163ea8602">vGrads</a>.clear();
<a name="l00401"></a>00401 
<a name="l00402"></a>00402     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f448b8545d73515c1606edbb9a4d664" title="mode of current evaluator operation (maybe not thread safe?)">mode</a> = <span class="stringliteral">&quot;Accumulate all field data&quot;</span>;
<a name="l00403"></a>00403     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46" title="Evaluate responses.">Albany::FieldManagerScalarResponseFunction::evaluateResponse</a>(
<a name="l00404"></a>00404             current_time, xdot, NULL, x, p, g);
<a name="l00405"></a>00405     <span class="comment">//No MPI here - each proc only holds all of it&#39;s worksets -- not other procs worksets</span>
<a name="l00406"></a>00406   }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <span class="keywordflow">return</span>;
<a name="l00410"></a>00410 }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 <span class="keywordtype">void</span>
<a name="l00413"></a>00413 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a135424776e2da27a6d5594ad48834598">QCAD::SaddleValueResponseFunction::</a>
<a name="l00414"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a135424776e2da27a6d5594ad48834598">00414</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a135424776e2da27a6d5594ad48834598">initializeFinalImagePoints</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l00415"></a>00415          <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l00416"></a>00416          <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l00417"></a>00417          <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l00418"></a>00418          Epetra_Vector&amp; <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>, <span class="keywordtype">int</span> dbMode)
<a name="l00419"></a>00419 {
<a name="l00420"></a>00420   <span class="comment">// Determine the locations of the &quot;final&quot; image points, which interpolate between the image points used</span>
<a name="l00421"></a>00421   <span class="comment">//    in the nudged elastic band algorithm, and are used only as a means of getting more dense output data (more points along saddle path)</span>
<a name="l00422"></a>00422   
<a name="l00423"></a>00423   <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  Initializing Final Image Points&quot;</span> &lt;&lt; std::endl;
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="keywordtype">int</span> maxPoints = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab538db72e79b9f717b66270ea40db992" title="data for final points (just used at end to get more data pts along saddle path)">maxFinalPts</a>;    <span class="comment">// maximum number of total final image points</span>
<a name="l00426"></a>00426   
<a name="l00427"></a>00427   <span class="keywordtype">double</span>* segmentLength = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1]; <span class="comment">// segmentLength[i] == distance between imagePt[i] and imagePt[i+1]</span>
<a name="l00428"></a>00428   <span class="keywordtype">double</span> lengthBefore = 0.0, lengthAfter = 0.0;    <span class="comment">// path length before and after saddle point</span>
<a name="l00429"></a>00429   <span class="keywordtype">double</span> <a class="code" href="Interface_8cpp.html#a3f67c53b80389c5f53961936edba04c9">radius</a> = 0.0;
<a name="l00430"></a>00430   <span class="keywordtype">int</span> nPtsBefore = 0, nPtsAfter = 0, nFinalPts;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   <span class="comment">// Get the distances along each leg of the current (final) saddle path</span>
<a name="l00433"></a>00433   <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1; i++) {
<a name="l00434"></a>00434     segmentLength[i] = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords.distanceTo(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].coords);
<a name="l00435"></a>00435     radius += <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].radius;
<a name="l00436"></a>00436     <span class="keywordflow">if</span>( (<span class="keywordtype">int</span>)i &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a> ) lengthBefore += segmentLength[i];
<a name="l00437"></a>00437     <span class="keywordflow">else</span> lengthAfter += segmentLength[i];
<a name="l00438"></a>00438   }
<a name="l00439"></a>00439   
<a name="l00440"></a>00440   radius += <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].radius;
<a name="l00441"></a>00441   radius /= nImagePts;  <span class="comment">// average radius</span>
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 <span class="comment">/*</span>
<a name="l00444"></a>00444 <span class="comment">  // We&#39;d like to put equal number of final points on each side of the saddle point.  Compute here how </span>
<a name="l00445"></a>00445 <span class="comment">  //  many final points (fixed spacing) will lie on each side of the saddle point.</span>
<a name="l00446"></a>00446 <span class="comment">  if(maxPoints * ptSpacing &lt; lengthBefore + lengthAfter) {</span>
<a name="l00447"></a>00447 <span class="comment">    if( maxPoints * ptSpacing / 2 &gt; lengthBefore)</span>
<a name="l00448"></a>00448 <span class="comment">      nPtsBefore = int(lengthBefore / ptSpacing);</span>
<a name="l00449"></a>00449 <span class="comment">    else if( maxPoints * ptSpacing / 2 &gt; lengthAfter)</span>
<a name="l00450"></a>00450 <span class="comment">      nPtsBefore = maxPoints - int(lengthAfter / ptSpacing);</span>
<a name="l00451"></a>00451 <span class="comment">    else nPtsBefore = maxPoints / 2;</span>
<a name="l00452"></a>00452 <span class="comment"></span>
<a name="l00453"></a>00453 <span class="comment">    nPtsAfter = maxPoints - nPtsBefore;</span>
<a name="l00454"></a>00454 <span class="comment">  }</span>
<a name="l00455"></a>00455 <span class="comment">  else {</span>
<a name="l00456"></a>00456 <span class="comment">    nPtsBefore = int(lengthBefore / ptSpacing);</span>
<a name="l00457"></a>00457 <span class="comment">    nPtsAfter  = int(lengthAfter  / ptSpacing);</span>
<a name="l00458"></a>00458 <span class="comment">  }</span>
<a name="l00459"></a>00459 <span class="comment">*/</span>
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="comment">// calculate point spacing for the entire saddle path and given maxPoints</span>
<a name="l00462"></a>00462   <span class="keywordtype">double</span> ptSpacing = (lengthBefore + lengthAfter)/(maxPoints-1); 
<a name="l00463"></a>00463   
<a name="l00464"></a>00464   <span class="comment">// nPtsBefore = int(lengthBefore / ptSpacing);</span>
<a name="l00465"></a>00465   <span class="comment">// nPtsAfter  = int(lengthAfter  / ptSpacing);</span>
<a name="l00466"></a>00466   <span class="comment">// nFinalPts = nPtsBefore + nPtsAfter + 1;     // one extra for &quot;on/at&quot; saddle point</span>
<a name="l00467"></a>00467   
<a name="l00468"></a>00468   nFinalPts = maxPoints; 
<a name="l00469"></a>00469   
<a name="l00470"></a>00470   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>.resize(nFinalPts);
<a name="l00471"></a>00471   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a65cfb1b3cfc628bc78cbb71d45ae85e5">finalPtValues</a>.<a class="code" href="classQCAD_1_1mathVector.html#adea02471efe6c010c0ef58801b437de1">resize</a>(nFinalPts);
<a name="l00472"></a>00472   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ac7bb0be604afd45a2ae25d352314ee4f">finalPtWeights</a>.<a class="code" href="classQCAD_1_1mathVector.html#adea02471efe6c010c0ef58801b437de1">resize</a>(nFinalPts);
<a name="l00473"></a>00473 
<a name="l00479"></a>00479   
<a name="l00480"></a>00480   <span class="comment">// Assign the starting and ending image points to finalPts</span>
<a name="l00481"></a>00481   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[0].init(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].radius);
<a name="l00482"></a>00482   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[nFinalPts-1].init(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].coords, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].radius);
<a name="l00483"></a>00483   
<a name="l00484"></a>00484   <span class="keywordtype">double</span> offset = ptSpacing;  
<a name="l00485"></a>00485   <span class="keywordtype">int</span> iCurFinalPt = 1;
<a name="l00486"></a>00486   
<a name="l00487"></a>00487   <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; nImagePts-1; i++) {
<a name="l00488"></a>00488     <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; initialPt = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords;
<a name="l00489"></a>00489     <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; v = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords) * (1.0/segmentLength[i]);  <span class="comment">// normalized vector from initial -&gt; final pt</span>
<a name="l00490"></a>00490 
<a name="l00491"></a>00491     <span class="keywordflow">if</span>(segmentLength[i] &gt; offset) {
<a name="l00492"></a>00492       <span class="keywordtype">int</span> nPtSegs = int((segmentLength[i]-offset) / ptSpacing);
<a name="l00493"></a>00493       <span class="keywordtype">int</span> nPts = nPtSegs + 1;
<a name="l00494"></a>00494       <span class="keywordtype">double</span> leftover = (segmentLength[i]-offset) - ptSpacing * nPtSegs;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; nPts &amp;&amp; iCurFinalPt &lt; nFinalPts; j++) {
<a name="l00497"></a>00497         <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[iCurFinalPt].init(initialPt + v * (ptSpacing * j + offset), radius );
<a name="l00498"></a>00498         iCurFinalPt++;
<a name="l00499"></a>00499       }
<a name="l00500"></a>00500       offset = ptSpacing - leftover; <span class="comment">//how much to advance the first point of the next segment</span>
<a name="l00501"></a>00501     }
<a name="l00502"></a>00502     <span class="keywordflow">else</span> {
<a name="l00503"></a>00503       offset -= segmentLength[i];
<a name="l00504"></a>00504     }
<a name="l00505"></a>00505   }
<a name="l00506"></a>00506   
<a name="l00507"></a>00507   <span class="comment">//If there are any leftover points, initialize them too</span>
<a name="l00508"></a>00508   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = iCurFinalPt; j &lt; nFinalPts; j++) 
<a name="l00509"></a>00509     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[j].init(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].coords, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].radius);
<a name="l00510"></a>00510   
<a name="l00511"></a>00511 
<a name="l00512"></a>00512 <span class="comment">/*</span>
<a name="l00513"></a>00513 <span class="comment">  double offset = ptSpacing;</span>
<a name="l00514"></a>00514 <span class="comment">  int iCurFinalPt = nPtsBefore-1;</span>
<a name="l00515"></a>00515 <span class="comment">  for(int i = iSaddlePt-1; i &gt;= 0; i--) {</span>
<a name="l00516"></a>00516 <span class="comment">    const mathVector&amp; initialPt = imagePts[i+1].coords;</span>
<a name="l00517"></a>00517 <span class="comment">    const mathVector&amp; v = (imagePts[i].coords - imagePts[i+1].coords) * (1.0/segmentLength[i]);  // normalized vector from initial -&gt; final pt</span>
<a name="l00518"></a>00518 <span class="comment"></span>
<a name="l00519"></a>00519 <span class="comment">    if(segmentLength[i] &gt; offset) {</span>
<a name="l00520"></a>00520 <span class="comment">      int nPtSegs = int((segmentLength[i]-offset) / ptSpacing);</span>
<a name="l00521"></a>00521 <span class="comment">      int nPts = nPtSegs + 1;</span>
<a name="l00522"></a>00522 <span class="comment">      double leftover = (segmentLength[i]-offset) - ptSpacing * nPtSegs;</span>
<a name="l00523"></a>00523 <span class="comment"></span>
<a name="l00524"></a>00524 <span class="comment">      for(int j=0; j&lt;nPts &amp;&amp; iCurFinalPt &gt;= 0; j++) {</span>
<a name="l00525"></a>00525 <span class="comment">        //radius = (imagePts[i].radius + imagePts[i+1].radius)/2; // use average radius</span>
<a name="l00526"></a>00526 <span class="comment">        finalPts[iCurFinalPt].init(initialPt + v * (ptSpacing * j + offset), radius );</span>
<a name="l00527"></a>00527 <span class="comment">        iCurFinalPt--;</span>
<a name="l00528"></a>00528 <span class="comment">      }</span>
<a name="l00529"></a>00529 <span class="comment">      offset = ptSpacing - leftover; //how much to advance the first point of the next segment</span>
<a name="l00530"></a>00530 <span class="comment">    }</span>
<a name="l00531"></a>00531 <span class="comment">    else {</span>
<a name="l00532"></a>00532 <span class="comment">      offset -= segmentLength[i];</span>
<a name="l00533"></a>00533 <span class="comment">    }</span>
<a name="l00534"></a>00534 <span class="comment">  }</span>
<a name="l00535"></a>00535 <span class="comment"></span>
<a name="l00536"></a>00536 <span class="comment">  //If there are any leftover points (at beginning), initialize them too</span>
<a name="l00537"></a>00537 <span class="comment">  for(int j=0; j&lt;=iCurFinalPt; j++) </span>
<a name="l00538"></a>00538 <span class="comment">    finalPts[j].init(imagePts[0].coords, imagePts[0].radius);</span>
<a name="l00539"></a>00539 <span class="comment"></span>
<a name="l00540"></a>00540 <span class="comment"></span>
<a name="l00541"></a>00541 <span class="comment">  offset = ptSpacing;  //start initial point *after* saddle point this time</span>
<a name="l00542"></a>00542 <span class="comment">  iCurFinalPt = nPtsBefore+1;</span>
<a name="l00543"></a>00543 <span class="comment">  for(std::size_t i = iSaddlePt; i &lt; nImagePts-1; i++) {</span>
<a name="l00544"></a>00544 <span class="comment">    const mathVector&amp; initialPt = imagePts[i].coords;</span>
<a name="l00545"></a>00545 <span class="comment">    const mathVector&amp; v = (imagePts[i+1].coords - imagePts[i].coords) * (1.0/segmentLength[i]);  // normalized vector from initial -&gt; final pt</span>
<a name="l00546"></a>00546 <span class="comment"></span>
<a name="l00547"></a>00547 <span class="comment">    if(segmentLength[i] &gt; offset) {</span>
<a name="l00548"></a>00548 <span class="comment">      int nPtSegs = int((segmentLength[i]-offset) / ptSpacing);</span>
<a name="l00549"></a>00549 <span class="comment">      int nPts = nPtSegs + 1;</span>
<a name="l00550"></a>00550 <span class="comment">      double leftover = (segmentLength[i]-offset) - ptSpacing * nPtSegs;</span>
<a name="l00551"></a>00551 <span class="comment"></span>
<a name="l00552"></a>00552 <span class="comment">      for(int j=0; j&lt;nPts &amp;&amp; iCurFinalPt &lt; nFinalPts; j++) {</span>
<a name="l00553"></a>00553 <span class="comment">        // radius = (imagePts[i].radius + imagePts[i+1].radius)/2; // use average radius</span>
<a name="l00554"></a>00554 <span class="comment">        finalPts[iCurFinalPt].init(initialPt + v * (ptSpacing * j + offset), radius );</span>
<a name="l00555"></a>00555 <span class="comment">        iCurFinalPt++;</span>
<a name="l00556"></a>00556 <span class="comment">      }</span>
<a name="l00557"></a>00557 <span class="comment">      offset = ptSpacing - leftover; //how much to advance the first point of the next segment</span>
<a name="l00558"></a>00558 <span class="comment">    }</span>
<a name="l00559"></a>00559 <span class="comment">    else {</span>
<a name="l00560"></a>00560 <span class="comment">      offset -= segmentLength[i];</span>
<a name="l00561"></a>00561 <span class="comment">    }</span>
<a name="l00562"></a>00562 <span class="comment">  }</span>
<a name="l00563"></a>00563 <span class="comment"></span>
<a name="l00564"></a>00564 <span class="comment">  //If there are any leftover points, initialize them too</span>
<a name="l00565"></a>00565 <span class="comment">  for(int j=iCurFinalPt; j&lt;nFinalPts; j++) </span>
<a name="l00566"></a>00566 <span class="comment">    finalPts[j].init(imagePts[nImagePts-1].coords, imagePts[nImagePts-1].radius);</span>
<a name="l00567"></a>00567 <span class="comment"></span>
<a name="l00568"></a>00568 <span class="comment">*/</span>
<a name="l00569"></a>00569 
<a name="l00570"></a>00570   <span class="keywordflow">return</span>;
<a name="l00571"></a>00571 }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 
<a name="l00574"></a>00574 <span class="keywordtype">void</span>
<a name="l00575"></a>00575 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aefa1eebc84c37bd509a2723957b270b9">QCAD::SaddleValueResponseFunction::</a>
<a name="l00576"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aefa1eebc84c37bd509a2723957b270b9">00576</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aefa1eebc84c37bd509a2723957b270b9">doNudgedElasticBand</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l00577"></a>00577         <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l00578"></a>00578         <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l00579"></a>00579         <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l00580"></a>00580         Epetra_Vector&amp; <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>, <span class="keywordtype">int</span> dbMode)
<a name="l00581"></a>00581 {
<a name="l00582"></a>00582   <span class="comment">//  2) Perform Nudged Elastic Band Algorithm to find saddle point.</span>
<a name="l00583"></a>00583   <span class="comment">//      Iterate over field manager fills of each image point&#39;s value and gradient</span>
<a name="l00584"></a>00584   <span class="comment">//       then update image point positions user Verlet algorithm</span>
<a name="l00585"></a>00585 
<a name="l00586"></a>00586   std::size_t nIters, nInitialIterations;
<a name="l00587"></a>00587   <span class="keywordtype">double</span> dp, s;
<a name="l00588"></a>00588   <span class="keywordtype">double</span> gradScale, springScale, springBase;
<a name="l00589"></a>00589   <span class="keywordtype">double</span> avgForce=0, avgOpposingForce=0;
<a name="l00590"></a>00590   <span class="keywordtype">double</span> dt = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa95ae59806dfebdb6fb149ea933b3303">maxTimeStep</a>;
<a name="l00591"></a>00591   <span class="keywordtype">double</span> dt2 = dt*dt;
<a name="l00592"></a>00592   <span class="keywordtype">double</span> acceptedHighestPtGradNorm = -1.0, highestPtGradNorm;
<a name="l00593"></a>00593   <span class="keywordtype">int</span> iHighestPt, nConsecLowForceDiff=0;  
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> tangent(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);  
<a name="l00596"></a>00596   std::vector&lt;mathVector&gt; force(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>), lastForce(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>), lastPositions(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>), lastVelocities(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>);
<a name="l00597"></a>00597   std::vector&lt;double&gt; springConstants(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>-1, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ae8e506d9f60f12afcf63c2e700ae8b7e">minSpringConstant</a>);
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <span class="comment">//initialize force variables and last positions</span>
<a name="l00600"></a>00600   <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>; i++) {
<a name="l00601"></a>00601     force[i].resize(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>); force[i].fill(0.0);
<a name="l00602"></a>00602     lastForce[i] = force[i];
<a name="l00603"></a>00603     lastPositions[i] = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords;
<a name="l00604"></a>00604     lastVelocities[i] = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].velocity;
<a name="l00605"></a>00605   }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="comment">//get distance between initial and final points</span>
<a name="l00608"></a>00608   <span class="keywordtype">double</span> max_dCoords = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords.distanceTo( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].coords ) / nImagePts;
<a name="l00609"></a>00609 
<a name="l00610"></a>00610   nIters = 0;
<a name="l00611"></a>00611   nInitialIterations = 20; <span class="comment">// TODO: make into parameter?</span>
<a name="l00612"></a>00612   
<a name="l00613"></a>00613   <span class="comment">//Storage for aggrecated image point data (needed for MPI)</span>
<a name="l00614"></a>00614   <span class="keywordtype">double</span>*  globalPtValues   = <span class="keyword">new</span> <span class="keywordtype">double</span> [nImagePts];
<a name="l00615"></a>00615   <span class="keywordtype">double</span>*  globalPtWeights  = <span class="keyword">new</span> <span class="keywordtype">double</span> [nImagePts];
<a name="l00616"></a>00616   <span class="keywordtype">double</span>*  globalPtGrads    = <span class="keyword">new</span> <span class="keywordtype">double</span> [nImagePts*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>];
<a name="l00617"></a>00617 
<a name="l00618"></a>00618   <span class="comment">//Write header to debug file</span>
<a name="l00619"></a>00619   std::fstream fDebug;
<a name="l00620"></a>00620   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a14f626be3dcc22d873e69c225dbef70a">debugFilename</a>.length() &gt; 0) {
<a name="l00621"></a>00621     fDebug.open(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a14f626be3dcc22d873e69c225dbef70a">debugFilename</a>.c_str(), std::fstream::out);
<a name="l00622"></a>00622     fDebug &lt;&lt; <span class="stringliteral">&quot;% HighestValue  HighestIndex  AverageForce  TimeStep&quot;</span>
<a name="l00623"></a>00623      &lt;&lt; <span class="stringliteral">&quot;  HighestPtGradNorm  AverageOpposingForce  SpringBase&quot;</span> &lt;&lt; std::endl;
<a name="l00624"></a>00624   }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626   <span class="comment">// Begin NEB iteration loop</span>
<a name="l00627"></a>00627   <span class="keywordflow">while</span>( ++nIters &lt;= <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a11d86580790b7891f8184f9b4fd45fdc">maxIterations</a>) {
<a name="l00628"></a>00628 
<a name="l00629"></a>00629     <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  NEB Algorithm iteration &quot;</span> &lt;&lt; nIters &lt;&lt; <span class="stringliteral">&quot; -----------------------&quot;</span> &lt;&lt; std::endl;
<a name="l00630"></a>00630     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8613a720c4826c02c356bd5de724c868">writeOutput</a>(nIters);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 
<a name="l00633"></a>00633     <span class="keywordflow">if</span>(nIters &gt; 1) {
<a name="l00634"></a>00634       <span class="comment">//Update coordinates and velocity using (modified) Verlet integration. Reset</span>
<a name="l00635"></a>00635       <span class="comment">// the velocity to zero if it is directed opposite to force (reduces overshoot)</span>
<a name="l00636"></a>00636       <span class="keywordflow">for</span>(std::size_t i=1; i&lt;nImagePts-1; i++) {
<a name="l00637"></a>00637   dp = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].velocity.dot(force[i]);
<a name="l00638"></a>00638   <span class="keywordflow">if</span>(dp &lt; 0) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].velocity.fill(0.0);
<a name="l00639"></a>00639 
<a name="l00640"></a>00640   <span class="comment">//save last position &amp; velocity in case the new position brings </span>
<a name="l00641"></a>00641   <span class="comment">//  us outside the mesh or we need to backtrace</span>
<a name="l00642"></a>00642   lastPositions[i] = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords; 
<a name="l00643"></a>00643   lastVelocities[i] = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].velocity; <span class="comment">//Note: will be zero if force opposed velocity (above)</span>
<a name="l00644"></a>00644 
<a name="l00645"></a>00645   <span class="comment">// ** Update **</span>
<a name="l00646"></a>00646   <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> dCoords = lastVelocities[i] * dt + force[i] * dt2 * 0.5;
<a name="l00647"></a>00647   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords = lastPositions[i] + dCoords;
<a name="l00648"></a>00648   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].velocity = lastVelocities[i] + force[i] * dt;
<a name="l00649"></a>00649       }
<a name="l00650"></a>00650     }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa9f2a82562af0598ffbbc806d8948434" title="Helper functions for doNudgedElasticBand(...).">getImagePointValues</a>(current_time, xdot, x, p, g, 
<a name="l00653"></a>00653       globalPtValues, globalPtWeights, globalPtGrads,
<a name="l00654"></a>00654       lastPositions, dbMode);
<a name="l00655"></a>00655     iHighestPt = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1eeac704fd65f0835c39ba49668ae704" title="helper function to get the highest image point (the one with the largest value)">getHighestPtIndex</a>();
<a name="l00656"></a>00656     highestPtGradNorm = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[iHighestPt].grad.norm();
<a name="l00657"></a>00657 
<a name="l00658"></a>00658     <span class="comment">// Setup scaling factors on first iteration</span>
<a name="l00659"></a>00659     <span class="keywordflow">if</span>(nIters == 1) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d47596776438f31cb7944ea33bf57bd">initialIterationSetup</a>(gradScale, springScale, dbMode);
<a name="l00660"></a>00660 
<a name="l00661"></a>00661     <span class="comment">// If in &quot;backtrace&quot; mode, require grad norm to decrease (or take minimum timestep)</span>
<a name="l00662"></a>00662     <span class="keywordflow">if</span>(nIters &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a38ebd30b78f63593f7e41a6b6cf1e163">backtraceAfterIters</a>) {
<a name="l00663"></a>00663       <span class="keywordflow">while</span>(dt &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9fc297039b153fbaee78d1df7b325a4d">minTimeStep</a> &amp;&amp; highestPtGradNorm &gt; acceptedHighestPtGradNorm) {
<a name="l00664"></a>00664 
<a name="l00665"></a>00665   <span class="comment">//reduce dt</span>
<a name="l00666"></a>00666   dt = (dt/2 &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9fc297039b153fbaee78d1df7b325a4d">minTimeStep</a>) ? <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9fc297039b153fbaee78d1df7b325a4d">minTimeStep</a> : dt/2;
<a name="l00667"></a>00667   dt /= 2; dt2=dt*dt; 
<a name="l00668"></a>00668   
<a name="l00669"></a>00669   <span class="keywordflow">if</span>(dbMode &gt; 2) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  ** Backtrace dt =&gt; &quot;</span> &lt;&lt; dt &lt;&lt; std::endl;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <span class="comment">//Update coordinates and velocity using (modified) Verlet integration. Reset</span>
<a name="l00672"></a>00672   <span class="comment">// the velocity to zero if it is directed opposite to force (reduces overshoot)</span>
<a name="l00673"></a>00673   <span class="keywordflow">for</span>(std::size_t i=1; i&lt;nImagePts-1; i++) {
<a name="l00674"></a>00674     <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> dCoords = lastVelocities[i] * dt + force[i] * dt2 * 0.5;
<a name="l00675"></a>00675     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords = lastPositions[i] + dCoords;
<a name="l00676"></a>00676     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].velocity = lastVelocities[i] + force[i] * dt;
<a name="l00677"></a>00677   }
<a name="l00678"></a>00678   
<a name="l00679"></a>00679   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa9f2a82562af0598ffbbc806d8948434" title="Helper functions for doNudgedElasticBand(...).">getImagePointValues</a>(current_time, xdot, x, p, g, 
<a name="l00680"></a>00680           globalPtValues, globalPtWeights, globalPtGrads,
<a name="l00681"></a>00681           lastPositions, dbMode);
<a name="l00682"></a>00682   iHighestPt = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1eeac704fd65f0835c39ba49668ae704" title="helper function to get the highest image point (the one with the largest value)">getHighestPtIndex</a>();
<a name="l00683"></a>00683   highestPtGradNorm = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[iHighestPt].grad.norm();
<a name="l00684"></a>00684       }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686       <span class="keywordflow">if</span>(dt == <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9fc297039b153fbaee78d1df7b325a4d">minTimeStep</a> &amp;&amp; highestPtGradNorm &gt; acceptedHighestPtGradNorm &amp;&amp; dbMode &gt; 2)
<a name="l00687"></a>00687   std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  ** Warning: backtrace hit min dt == &quot;</span> &lt;&lt; dt &lt;&lt; std::endl;
<a name="l00688"></a>00688     } 
<a name="l00689"></a>00689     acceptedHighestPtGradNorm = highestPtGradNorm;
<a name="l00690"></a>00690 
<a name="l00691"></a>00691     <span class="comment">// Compute spring base constant for this iteration</span>
<a name="l00692"></a>00692     s = ((double)nIters-1.0)/<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a11d86580790b7891f8184f9b4fd45fdc">maxIterations</a>;    
<a name="l00693"></a>00693     springBase = springScale * ( (1.0-s)*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ae8e506d9f60f12afcf63c2e700ae8b7e">minSpringConstant</a> + s*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6780efc76dd1113175f601e6a6892915">maxSpringConstant</a> ); 
<a name="l00694"></a>00694     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;nImagePts-1; i++) springConstants[i] = springBase;
<a name="l00695"></a>00695     
<a name="l00696"></a>00696     avgForce = avgOpposingForce = 0.0;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     <span class="comment">// Compute force acting on each image point</span>
<a name="l00699"></a>00699     <span class="keywordflow">for</span>(std::size_t i=1; i&lt;nImagePts-1; i++) {
<a name="l00700"></a>00700       <span class="keywordflow">if</span>(dbMode &gt; 2) std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  &gt;&gt; Updating pt[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;]:&quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i];
<a name="l00701"></a>00701 
<a name="l00702"></a>00702       <span class="comment">// compute the tangent vector for the ith image point</span>
<a name="l00703"></a>00703       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6392c40d838c3a665c2e8f570f8e55cf">computeTangent</a>(i, tangent, dbMode);
<a name="l00704"></a>00704 
<a name="l00705"></a>00705       <span class="comment">// compute the force vector for the ith image point</span>
<a name="l00706"></a>00706       <span class="keywordflow">if</span>((<span class="keywordtype">int</span>)i == iHighestPt &amp;&amp; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad03496cc58cc9ffb598ecf2e8e232478">bClimbing</a> &amp;&amp; nIters &gt; nInitialIterations)
<a name="l00707"></a>00707   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9b7cfe4a5d2300c90a8d2d98a8fa96b2">computeClimbingForce</a>(i, tangent, gradScale, force[i], dbMode);
<a name="l00708"></a>00708       <span class="keywordflow">else</span>
<a name="l00709"></a>00709   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aac8a5fbe0867c0a81d0c6742ac4ded94">computeForce</a>(i, tangent, springConstants, gradScale, springScale,
<a name="l00710"></a>00710          force[i], dt, dt2, dbMode);
<a name="l00711"></a>00711 
<a name="l00712"></a>00712       <span class="comment">// update avgForce and avgOpposingForce</span>
<a name="l00713"></a>00713       avgForce += force[i].norm();
<a name="l00714"></a>00714       dp = force[i].dot(lastForce[i]) / (force[i].norm() * lastForce[i].norm()); 
<a name="l00715"></a>00715       <span class="keywordflow">if</span>( dp &lt; 0 ) {  <span class="comment">//if current force and last force point in &quot;opposite&quot; directions</span>
<a name="l00716"></a>00716   <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> v = force[i] - lastForce[i];
<a name="l00717"></a>00717   avgOpposingForce += v.<a class="code" href="classQCAD_1_1mathVector.html#a2dc5bb04ad9b71819e888a2b9df5eada">norm</a>() / (force[i].norm() + lastForce[i].norm());
<a name="l00718"></a>00718   <span class="comment">//avgOpposingForce += dp;  //an alternate implementation</span>
<a name="l00719"></a>00719       } 
<a name="l00720"></a>00720     } <span class="comment">// end of loop over image points </span>
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     avgForce /= (nImagePts-2);
<a name="l00723"></a>00723     avgOpposingForce /= (nImagePts-2);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     <span class="comment">//print debug output</span>
<a name="l00727"></a>00727     <span class="keywordflow">if</span>(dbMode &gt; 1) 
<a name="l00728"></a>00728       std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  ** Summary:&quot;</span>
<a name="l00729"></a>00729     &lt;&lt; <span class="stringliteral">&quot;  highest val[&quot;</span> &lt;&lt; iHighestPt &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[iHighestPt].value
<a name="l00730"></a>00730     &lt;&lt; <span class="stringliteral">&quot;  AverageForce = &quot;</span> &lt;&lt; avgForce &lt;&lt; <span class="stringliteral">&quot;  dt = &quot;</span> &lt;&lt; dt 
<a name="l00731"></a>00731     &lt;&lt; <span class="stringliteral">&quot;  gradNorm = &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[iHighestPt].grad.norm() 
<a name="l00732"></a>00732     &lt;&lt; <span class="stringliteral">&quot;  AvgOpposingForce = &quot;</span> &lt;&lt; avgOpposingForce 
<a name="l00733"></a>00733     &lt;&lt; <span class="stringliteral">&quot;  SpringBase = &quot;</span> &lt;&lt; springBase &lt;&lt; std::endl;
<a name="l00734"></a>00734     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a14f626be3dcc22d873e69c225dbef70a">debugFilename</a>.length() &gt; 0)
<a name="l00735"></a>00735       fDebug &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[iHighestPt].value &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; iHighestPt &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l00736"></a>00736        &lt;&lt; avgForce &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>  &lt;&lt; dt &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[iHighestPt].grad.norm() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l00737"></a>00737        &lt;&lt; avgOpposingForce &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; springBase &lt;&lt; std::endl;
<a name="l00738"></a>00738 
<a name="l00739"></a>00739 
<a name="l00740"></a>00740     <span class="comment">// Check for convergence in gradient norm</span>
<a name="l00741"></a>00741     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[iHighestPt].grad.norm() &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a2e1227060d5dfabbbeafdf3628f63216">convergeTolerance</a>) {
<a name="l00742"></a>00742       <span class="keywordflow">if</span>(dbMode &gt; 2) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  ** Converged (grad norm &quot;</span> &lt;&lt; 
<a name="l00743"></a>00743          <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[iHighestPt].grad.norm() &lt;&lt; <span class="stringliteral">&quot; &lt; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a2e1227060d5dfabbbeafdf3628f63216">convergeTolerance</a> &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
<a name="l00744"></a>00744       <span class="keywordflow">break</span>; <span class="comment">// exit iterations loop</span>
<a name="l00745"></a>00745     }
<a name="l00746"></a>00746     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nIters == <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a11d86580790b7891f8184f9b4fd45fdc">maxIterations</a>) <span class="keywordflow">break</span>; <span class="comment">//max iterations reached -- exit iterations loop now</span>
<a name="l00747"></a>00747                                             <span class="comment">// (important so coords &amp; radii don&#39;t get updated)</span>
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     <span class="comment">// Save last force for next iteration</span>
<a name="l00750"></a>00750     <span class="keywordflow">for</span>(std::size_t i=1; i&lt;nImagePts-1; i++) lastForce[i] = force[i];
<a name="l00751"></a>00751     
<a name="l00752"></a>00752     <span class="comment">// If all forces have remained in the same direction, tally this.  If this happens too many times</span>
<a name="l00753"></a>00753     <span class="comment">//  increase dt, as this is a sign the time step is too small.</span>
<a name="l00754"></a>00754     <span class="keywordflow">if</span>(avgOpposingForce &lt; 1e-6) nConsecLowForceDiff++; <span class="keywordflow">else</span> nConsecLowForceDiff = 0;
<a name="l00755"></a>00755     <span class="keywordflow">if</span>(nConsecLowForceDiff &gt;= 3 &amp;&amp; dt &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa95ae59806dfebdb6fb149ea933b3303">maxTimeStep</a>) { 
<a name="l00756"></a>00756       dt *= 2; dt2=dt*dt; nConsecLowForceDiff = 0;
<a name="l00757"></a>00757       <span class="keywordflow">if</span>(dbMode &gt; 2) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  ** Consecutive low dForce =&gt; dt = &quot;</span> &lt;&lt; dt &lt;&lt; std::endl;
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760     <span class="comment">//Shouldn&#39;t be necessary since grad_z == 0, but just to be sure all points </span>
<a name="l00761"></a>00761     <span class="comment">//  are locked to their given (initial) z-coordinate</span>
<a name="l00762"></a>00762     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a3dfbfb1de5e7cc235d821b982ae12c13">bLockToPlane</a> &amp;&amp; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &gt; 2) {
<a name="l00763"></a>00763       <span class="keywordflow">for</span>(std::size_t i=1; i&lt;nImagePts-1; i++) force[i][2] = 0.0;
<a name="l00764"></a>00764     }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766     <span class="comment">//Reduce dt if movement of any point exceeds initial average distance btwn pts</span>
<a name="l00767"></a>00767     <span class="keywordtype">bool</span> reduce_dt = <span class="keyword">true</span>;
<a name="l00768"></a>00768     <span class="keywordflow">while</span>(reduce_dt &amp;&amp; dt/2 &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9fc297039b153fbaee78d1df7b325a4d">minTimeStep</a>) {
<a name="l00769"></a>00769       reduce_dt = <span class="keyword">false</span>;
<a name="l00770"></a>00770       <span class="keywordflow">for</span>(std::size_t i=1; i&lt;nImagePts-1; i++) {
<a name="l00771"></a>00771   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].velocity.norm() * dt &gt; max_dCoords) { reduce_dt = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }
<a name="l00772"></a>00772   <span class="keywordflow">if</span>(0.5 * force[i].norm() * dt2 &gt; max_dCoords) { reduce_dt = <span class="keyword">true</span>; <span class="keywordflow">break</span>; }
<a name="l00773"></a>00773       }
<a name="l00774"></a>00774       <span class="keywordflow">if</span>(reduce_dt) { 
<a name="l00775"></a>00775   dt /= 2; dt2=dt*dt;
<a name="l00776"></a>00776   <span class="keywordflow">if</span>(dbMode &gt; 2) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  ** Warning: dCoords too large: dt =&gt; &quot;</span> &lt;&lt; dt &lt;&lt; std::endl;
<a name="l00777"></a>00777       }
<a name="l00778"></a>00778     }
<a name="l00779"></a>00779     
<a name="l00780"></a>00780     <span class="comment">// adjust image point size based on weight (if requested)</span>
<a name="l00781"></a>00781     <span class="comment">//  --&gt; try to get weight between MIN/MAX target weights by varying image pt size</span>
<a name="l00782"></a>00782     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ae2b96d9132a7ff7bf8e04d119907fb04">bAdaptivePointSize</a>) {
<a name="l00783"></a>00783       <span class="keywordflow">for</span>(std::size_t i=0; i&lt;nImagePts; i++) {
<a name="l00784"></a>00784   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].weight &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9e79fbe9346261b217f99c2a982e02b8">minAdaptivePointWt</a>) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].radius *= 2;
<a name="l00785"></a>00785   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].weight &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1457d05d60c7f82d5494893860519bcf">maxAdaptivePointWt</a>) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].radius /= 2;
<a name="l00786"></a>00786       }
<a name="l00787"></a>00787     }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789   }  <span class="comment">// end of NEB iteration loops</span>
<a name="l00790"></a>00790 
<a name="l00791"></a>00791   <span class="comment">//deallocate storage used for MPI communication</span>
<a name="l00792"></a>00792   <span class="keyword">delete</span> [] globalPtValues; 
<a name="l00793"></a>00793   <span class="keyword">delete</span> [] globalPtWeights;
<a name="l00794"></a>00794   <span class="keyword">delete</span> [] globalPtGrads;  
<a name="l00795"></a>00795 
<a name="l00796"></a>00796   <span class="comment">// Check if converged: nIters &lt; maxIters ?</span>
<a name="l00797"></a>00797   <span class="keywordflow">if</span>(dbMode) {
<a name="l00798"></a>00798     <span class="keywordflow">if</span>(nIters &lt;= <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a11d86580790b7891f8184f9b4fd45fdc">maxIterations</a>) 
<a name="l00799"></a>00799       std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  NEB Converged after &quot;</span> &lt;&lt; nIters &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;
<a name="l00800"></a>00800     <span class="keywordflow">else</span>
<a name="l00801"></a>00801       std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  NEB Giving up after &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a11d86580790b7891f8184f9b4fd45fdc">maxIterations</a> &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;nImagePts; i++) {
<a name="l00804"></a>00804       std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  --   Final pt[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].value 
<a name="l00805"></a>00805     &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords &lt;&lt; <span class="stringliteral">&quot;  (wt = &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].weight &lt;&lt; <span class="stringliteral">&quot; )&quot;</span> 
<a name="l00806"></a>00806     &lt;&lt; <span class="stringliteral">&quot;  (r= &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].radius &lt;&lt; <span class="stringliteral">&quot; )&quot;</span> &lt;&lt; std::endl;
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808   }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <span class="comment">// Choose image point with highest value (and positive weight) as saddle point</span>
<a name="l00811"></a>00811   std::size_t imax = 0;
<a name="l00812"></a>00812   <span class="keywordflow">for</span>(std::size_t i=0; i&lt;nImagePts; i++) {
<a name="l00813"></a>00813     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].weight &gt; 0) { imax = i; <span class="keywordflow">break</span>; }
<a name="l00814"></a>00814   }
<a name="l00815"></a>00815   <span class="keywordflow">for</span>(std::size_t i=imax+1; i&lt;nImagePts; i++) {
<a name="l00816"></a>00816     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].value &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[imax].value &amp;&amp; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].weight &gt; 0) imax = i;
<a name="l00817"></a>00817   }
<a name="l00818"></a>00818   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a> = imax;
<a name="l00819"></a>00819 
<a name="l00820"></a>00820   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a14f626be3dcc22d873e69c225dbef70a">debugFilename</a>.length() &gt; 0) fDebug.close();
<a name="l00821"></a>00821   <span class="keywordflow">return</span>;
<a name="l00822"></a>00822 }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824 <span class="keywordtype">void</span>
<a name="l00825"></a>00825 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#abf6ba82dbb25a70cdad8b72d27360240">QCAD::SaddleValueResponseFunction::</a>
<a name="l00826"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#abf6ba82dbb25a70cdad8b72d27360240">00826</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#abf6ba82dbb25a70cdad8b72d27360240">fillSaddlePointData</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l00827"></a>00827         <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l00828"></a>00828         <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l00829"></a>00829         <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l00830"></a>00830         Epetra_Vector&amp; <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>, <span class="keywordtype">int</span> dbMode)
<a name="l00831"></a>00831 {
<a name="l00832"></a>00832   <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  Begin filling saddle point data&quot;</span> &lt;&lt; std::endl;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8fdd456a00773defd2b33e0abe645ed9" title="data for memory-intensive but fast mode (hold entire proc&amp;#39;s data)">bAggregateWorksets</a>) {  <span class="comment">//in aggregate workset mode, there are currently no x-y cutoffs imposed on points in getImagePointValues</span>
<a name="l00835"></a>00835     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a> = -1e10; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a> = 1e10; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a> = -1e10; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a> = 1e10;
<a name="l00836"></a>00836   }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f448b8545d73515c1606edbb9a4d664" title="mode of current evaluator operation (maybe not thread safe?)">mode</a> = <span class="stringliteral">&quot;Fill saddle point&quot;</span>;
<a name="l00839"></a>00839   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46" title="Evaluate responses.">Albany::FieldManagerScalarResponseFunction::evaluateResponse</a>(
<a name="l00840"></a>00840            current_time, xdot, NULL, x, p, g);
<a name="l00841"></a>00841   <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  Done filling saddle point data&quot;</span> &lt;&lt; std::endl;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843   <span class="comment">//Note: MPI: saddle weight is already summed in evaluator&#39;s </span>
<a name="l00844"></a>00844   <span class="comment">//   postEvaluate, so no need to do anything here</span>
<a name="l00845"></a>00845 
<a name="l00846"></a>00846   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa92848b0ec3bc572a589cb7fdf009f4c">returnFieldVal</a> = g[0];
<a name="l00847"></a>00847   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].value = g[1];
<a name="l00848"></a>00848   
<a name="l00849"></a>00849   <span class="comment">// Overwrite response indices 2+ with saddle point coordinates</span>
<a name="l00850"></a>00850   <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; i++) g[2+i] = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].coords[i]; 
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="keywordflow">if</span>(dbMode) {
<a name="l00853"></a>00853     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  Return Field value = &quot;</span> &lt;&lt; g[0] &lt;&lt; std::endl;
<a name="l00854"></a>00854     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:         Field value = &quot;</span> &lt;&lt; g[1] &lt;&lt; std::endl;
<a name="l00855"></a>00855     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;numDims; i++)
<a name="l00856"></a>00856       std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:         Coord[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; g[2+i] &lt;&lt; std::endl;
<a name="l00857"></a>00857   }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859   <span class="keywordflow">if</span>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a>.length() &gt; 0) {
<a name="l00860"></a>00860     std::fstream out; <span class="keywordtype">double</span> pathLength = 0.0;
<a name="l00861"></a>00861     out.open(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a>.c_str(), std::fstream::out | <a class="code" href="InterfaceTry_8cpp.html#a5687d6d7d8e1356f9cbed0616b9e7cec">std::fstream::app</a>);
<a name="l00862"></a>00862     out &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;% Saddle point path - Image points&quot;</span> &lt;&lt; std::endl;
<a name="l00863"></a>00863     out &lt;&lt; <span class="stringliteral">&quot;% index xCoord yCoord value pathLength pointRadius&quot;</span> &lt;&lt; std::endl;
<a name="l00864"></a>00864     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>; i++) {
<a name="l00865"></a>00865       out &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[1]
<a name="l00866"></a>00866     &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].value &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; pathLength &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].radius &lt;&lt; std::endl;
<a name="l00867"></a>00867       <span class="keywordflow">if</span>(i&lt;nImagePts-1) pathLength += <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords.distanceTo(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].coords);
<a name="l00868"></a>00868     }    
<a name="l00869"></a>00869     out.close();
<a name="l00870"></a>00870   }
<a name="l00871"></a>00871 
<a name="l00872"></a>00872   <span class="keywordflow">return</span>;
<a name="l00873"></a>00873 }
<a name="l00874"></a>00874 
<a name="l00875"></a>00875 
<a name="l00876"></a>00876 
<a name="l00877"></a>00877 <span class="keywordtype">void</span>
<a name="l00878"></a>00878 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aef9194b98a66f3150b3f507b2612cc1f" title="Helper functions for level-set algorithm, performed in evaluateResponse.">QCAD::SaddleValueResponseFunction::</a>
<a name="l00879"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aef9194b98a66f3150b3f507b2612cc1f">00879</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aef9194b98a66f3150b3f507b2612cc1f" title="Helper functions for level-set algorithm, performed in evaluateResponse.">doLevelSet</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l00880"></a>00880      <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l00881"></a>00881      <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l00882"></a>00882      <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l00883"></a>00883      Epetra_Vector&amp; <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>, <span class="keywordtype">int</span> dbMode)
<a name="l00884"></a>00884 {
<a name="l00885"></a>00885   <span class="keywordtype">int</span> result;
<a name="l00886"></a>00886 
<a name="l00887"></a>00887   <span class="keywordflow">if</span>( fabs(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a19bd8b4b06d315c750dff8d2a0d3ee15">levelSetRadius</a>) &lt; 1e-9 ) <span class="keywordflow">return</span>; <span class="comment">//don&#39;t run if level-set radius is zero</span>
<a name="l00888"></a>00888 
<a name="l00889"></a>00889   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a77eeed70b4b7250af29ce4137b60ab94" title="data for level set method">vlsFieldValues</a>.clear(); <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af2c7272a66b5ab84b03908fad7a28690">vlsCellAreas</a>.clear();
<a name="l00890"></a>00890   <span class="keywordflow">for</span>(std::size_t k=0; k&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; k++) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9a0f97f85f49301a344419b25446c038">vlsCoords</a>[k].clear();
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f448b8545d73515c1606edbb9a4d664" title="mode of current evaluator operation (maybe not thread safe?)">mode</a> = <span class="stringliteral">&quot;Level set data collection&quot;</span>;
<a name="l00893"></a>00893   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46" title="Evaluate responses.">Albany::FieldManagerScalarResponseFunction::evaluateResponse</a>(
<a name="l00894"></a>00894            current_time, xdot, NULL, x, p, g);
<a name="l00895"></a>00895 
<a name="l00897"></a>00897   std::vector&lt;double&gt; allFieldVals;
<a name="l00898"></a>00898   std::vector&lt;double&gt; allCellAreas;
<a name="l00899"></a>00899   std::vector&lt;double&gt; allCoords[MAX_DIMENSIONS];
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   <a class="code" href="namespaceQCAD.html#a985bf075550ffc548624607851d93d1e" title="Helper functions.">QCAD::gatherVector</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a77eeed70b4b7250af29ce4137b60ab94" title="data for level set method">vlsFieldValues</a>, allFieldVals, *<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>);  
<a name="l00902"></a>00902   <a class="code" href="namespaceQCAD.html#a985bf075550ffc548624607851d93d1e" title="Helper functions.">QCAD::gatherVector</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af2c7272a66b5ab84b03908fad7a28690">vlsCellAreas</a>, allCellAreas, *<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>);
<a name="l00903"></a>00903   <span class="keywordflow">for</span>(std::size_t k=0; k&lt;numDims; k++)
<a name="l00904"></a>00904     <a class="code" href="namespaceQCAD.html#a985bf075550ffc548624607851d93d1e" title="Helper functions.">QCAD::gatherVector</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9a0f97f85f49301a344419b25446c038">vlsCoords</a>[k], allCoords[k], *<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>);
<a name="l00905"></a>00905 
<a name="l00907"></a>00907   <span class="keywordflow">if</span>( allFieldVals.size()  == 0 ) <span class="keywordflow">return</span>;
<a name="l00908"></a>00908 
<a name="l00910"></a>00910   <span class="keywordflow">if</span>(dbMode) {
<a name="l00911"></a>00911     std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;--- Begin Saddle Level Set Algorithm ---&quot;</span> &lt;&lt; std::endl;
<a name="l00912"></a>00912     std::cout &lt;&lt; <span class="stringliteral">&quot;--- Saddle Level Set: local size (this proc) = &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a77eeed70b4b7250af29ce4137b60ab94" title="data for level set method">vlsFieldValues</a>.size()
<a name="l00913"></a>00913         &lt;&lt; <span class="stringliteral">&quot;, gathered size (all procs) = &quot;</span> &lt;&lt; allFieldVals.size() &lt;&lt; std::endl;
<a name="l00914"></a>00914   }
<a name="l00915"></a>00915 
<a name="l00917"></a>00917   std::vector&lt;int&gt; ordering;
<a name="l00918"></a>00918   <a class="code" href="namespaceQCAD.html#a8146e2aea1832644a7a0dced84e9d80c">QCAD::getOrdering</a>(allFieldVals, ordering);
<a name="l00919"></a>00919 
<a name="l00920"></a>00920 
<a name="l00922"></a>00922   <span class="keywordtype">double</span> maxFieldVal = allFieldVals[0], minFieldVal = allFieldVals[0];
<a name="l00923"></a>00923   <span class="keywordtype">double</span> maxCoords[3], minCoords[3];
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   <span class="keywordflow">for</span>(std::size_t k=0; k&lt;numDims &amp;&amp; k &lt; 3; k++)
<a name="l00926"></a>00926     maxCoords[k] = minCoords[k] = allCoords[k][0];
<a name="l00927"></a>00927 
<a name="l00928"></a>00928   std::size_t N = allFieldVals.size();
<a name="l00929"></a>00929   <span class="keywordflow">for</span>(std::size_t i=0; i&lt;N; i++) {
<a name="l00930"></a>00930     <span class="keywordflow">for</span>(std::size_t k=0; k&lt;numDims &amp;&amp; k &lt; 3; k++) {
<a name="l00931"></a>00931       <span class="keywordflow">if</span>(allCoords[k][i] &gt; maxCoords[k]) maxCoords[k] = allCoords[k][i];
<a name="l00932"></a>00932       <span class="keywordflow">if</span>(allCoords[k][i] &lt; minCoords[k]) minCoords[k] = allCoords[k][i];
<a name="l00933"></a>00933     }
<a name="l00934"></a>00934     <span class="keywordflow">if</span>(allFieldVals[i] &gt; maxFieldVal) maxFieldVal = allFieldVals[i];
<a name="l00935"></a>00935     <span class="keywordflow">if</span>(allFieldVals[i] &lt; minFieldVal) minFieldVal = allFieldVals[i];
<a name="l00936"></a>00936   }
<a name="l00937"></a>00937   
<a name="l00938"></a>00938   <span class="keywordtype">double</span> avgCellLength = pow(<a class="code" href="namespaceQCAD.html#a60ab2fe2fbbbd5d8e573d61cf5a09f41">QCAD::averageOfVector</a>(allCellAreas), 0.5); <span class="comment">//assume 2D areas</span>
<a name="l00939"></a>00939   <span class="keywordtype">double</span> maxFieldDifference = fabs(maxFieldVal - minFieldVal);
<a name="l00940"></a>00940   <span class="keywordtype">double</span> currentSaddleValue = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].value;
<a name="l00941"></a>00941   
<a name="l00942"></a>00942 
<a name="l00943"></a>00943   <span class="keywordflow">if</span>(dbMode &gt; 1) {
<a name="l00944"></a>00944     std::cout &lt;&lt; <span class="stringliteral">&quot;--- Saddle Level Set: max field difference = &quot;</span> &lt;&lt; maxFieldDifference
<a name="l00945"></a>00945         &lt;&lt; <span class="stringliteral">&quot;, avg cell length = &quot;</span> &lt;&lt; avgCellLength &lt;&lt; std::endl;
<a name="l00946"></a>00946   }
<a name="l00947"></a>00947 
<a name="l00949"></a>00949   <span class="keywordtype">double</span> cutoffDistance, cutoffFieldVal, minDepth;
<a name="l00950"></a>00950   cutoffDistance = avgCellLength * <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a80a75097d3e22f7ce0a9064069bd0b9c">distanceCutoffFctr</a>;
<a name="l00951"></a>00951   cutoffFieldVal = maxFieldDifference * <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a960cd671db6d61697a25bbbc7cb11963">fieldCutoffFctr</a>;
<a name="l00952"></a>00952   minDepth = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab533be8589780edc525b58128d140f9d">minPoolDepthFctr</a> * (currentSaddleValue - minFieldVal) / 2.0; <span class="comment">//maxFieldDifference * minPoolDepthFctr;</span>
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   result = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad69806833d3a7148140a7cdbe2df463c" title="Level-set Algorithm for finding saddle point.">FindSaddlePoint_LevelSet</a>(allFieldVals, allCoords, ordering,
<a name="l00955"></a>00955          cutoffDistance, cutoffFieldVal, minDepth, dbMode, g);
<a name="l00956"></a>00956   <span class="comment">// result == 0 ==&gt; success: found 2 &quot;deep&quot; pools &amp; saddle pt</span>
<a name="l00957"></a>00957   <span class="keywordflow">if</span>(result == 0) { 
<a name="l00958"></a>00958     <span class="comment">//update imagePts[iSaddlePt] to be newly found saddle value</span>
<a name="l00959"></a>00959     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;numDims; i++) <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].coords[i] = g[2+i];
<a name="l00960"></a>00960     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].value = g[1];
<a name="l00961"></a>00961     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].radius = 1e-5; <span class="comment">//very small so only pick up point of interest?</span>
<a name="l00962"></a>00962     <span class="comment">//set weight?</span>
<a name="l00963"></a>00963   }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965   <span class="keywordflow">return</span>;
<a name="l00966"></a>00966 }
<a name="l00967"></a>00967 
<a name="l00969"></a>00969 <span class="keywordtype">int</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad69806833d3a7148140a7cdbe2df463c" title="Level-set Algorithm for finding saddle point.">QCAD::SaddleValueResponseFunction::</a>
<a name="l00970"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad69806833d3a7148140a7cdbe2df463c">00970</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad69806833d3a7148140a7cdbe2df463c" title="Level-set Algorithm for finding saddle point.">FindSaddlePoint_LevelSet</a>(std::vector&lt;double&gt;&amp; allFieldVals,
<a name="l00971"></a>00971     std::vector&lt;double&gt;* allCoords, std::vector&lt;int&gt;&amp; ordering,
<a name="l00972"></a>00972     <span class="keywordtype">double</span> cutoffDistance, <span class="keywordtype">double</span> cutoffFieldVal, <span class="keywordtype">double</span> minDepth, <span class="keywordtype">int</span> dbMode,
<a name="l00973"></a>00973     Epetra_Vector&amp; <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>)
<a name="l00974"></a>00974 {
<a name="l00975"></a>00975   <span class="keywordflow">if</span>(dbMode) {
<a name="l00976"></a>00976     std::cout &lt;&lt; <span class="stringliteral">&quot;--- Saddle Level Set: distance cutoff = &quot;</span> &lt;&lt; cutoffDistance
<a name="l00977"></a>00977         &lt;&lt; <span class="stringliteral">&quot;, field cutoff = &quot;</span> &lt;&lt; cutoffFieldVal 
<a name="l00978"></a>00978         &lt;&lt; <span class="stringliteral">&quot;, min depth = &quot;</span> &lt;&lt; minDepth &lt;&lt; std::endl;
<a name="l00979"></a>00979   }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981   <span class="comment">// Walk through sorted data.  At current point, walk backward in list </span>
<a name="l00982"></a>00982   <span class="comment">//  until either 1) a &quot;close&quot; point is found, as given by tolerance -&gt; join to tree</span>
<a name="l00983"></a>00983   <span class="comment">//            or 2) the change in field value exceeds some maximium -&gt; new tree</span>
<a name="l00984"></a>00984   std::size_t N = allFieldVals.size();
<a name="l00985"></a>00985   std::vector&lt;int&gt; treeIDs(N, -1);
<a name="l00986"></a>00986   std::vector&lt;double&gt; minFieldVals; <span class="comment">//for each tree</span>
<a name="l00987"></a>00987   std::vector&lt;int&gt; treeSizes; <span class="comment">//for each tree</span>
<a name="l00988"></a>00988   <span class="keywordtype">int</span> nextAvailableTreeID = 0;
<a name="l00989"></a>00989 
<a name="l00990"></a>00990   <span class="keywordtype">int</span> nTrees = 0, nMaxTrees = 0;
<a name="l00991"></a>00991   <span class="keywordtype">int</span> nDeepTrees=0, lastDeepTrees=0, treeIDtoReplace;
<a name="l00992"></a>00992   <span class="keywordtype">int</span> I, J, K;
<a name="l00993"></a>00993   <span class="keywordflow">for</span>(std::size_t i=0; i &lt; N; i++) {
<a name="l00994"></a>00994     I = ordering[i];
<a name="l00995"></a>00995 
<a name="l00996"></a>00996     <span class="keywordflow">if</span>(dbMode &gt; 1) {
<a name="l00997"></a>00997       nDeepTrees = 0;
<a name="l00998"></a>00998       <span class="keywordflow">for</span>(std::size_t t=0; t &lt; treeSizes.size(); t++) {
<a name="l00999"></a>00999   <span class="keywordflow">if</span>(treeSizes[t] &gt; 0 &amp;&amp; (allFieldVals[I]-minFieldVals[t]) &gt; minDepth) nDeepTrees++;
<a name="l01000"></a>01000       }
<a name="l01001"></a>01001     }
<a name="l01002"></a>01002 
<a name="l01003"></a>01003     <span class="keywordflow">if</span>(dbMode &gt; 3) std::cout &lt;&lt; <span class="stringliteral">&quot;DEBUG: i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;( I = &quot;</span> &lt;&lt; I &lt;&lt; <span class="stringliteral">&quot;), val=&quot;</span>
<a name="l01004"></a>01004        &lt;&lt; allFieldVals[I] &lt;&lt; <span class="stringliteral">&quot;, loc=(&quot;</span> &lt;&lt; allCoords[0][I] 
<a name="l01005"></a>01005        &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; allCoords[1][I] &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; <span class="stringliteral">&quot; nD=&quot;</span> &lt;&lt; nDeepTrees;
<a name="l01006"></a>01006 
<a name="l01007"></a>01007     <span class="keywordflow">if</span>(dbMode &gt; 1 &amp;&amp; lastDeepTrees != nDeepTrees) {
<a name="l01008"></a>01008       std::cout &lt;&lt; <span class="stringliteral">&quot;--- Saddle: i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; new deep pool: nPools=&quot;</span> &lt;&lt; nTrees 
<a name="l01009"></a>01009     &lt;&lt; <span class="stringliteral">&quot; nDeep=&quot;</span> &lt;&lt; nDeepTrees &lt;&lt; std::endl;
<a name="l01010"></a>01010       lastDeepTrees = nDeepTrees;
<a name="l01011"></a>01011     }
<a name="l01012"></a>01012 
<a name="l01013"></a>01013     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=i-1; j &gt;= 0 &amp;&amp; fabs(allFieldVals[I] - allFieldVals[ordering[j]]) &lt; cutoffFieldVal; j--) {
<a name="l01014"></a>01014       J = ordering[j];
<a name="l01015"></a>01015 
<a name="l01016"></a>01016       <span class="keywordflow">if</span>( <a class="code" href="namespaceQCAD.html#a42ea78e1e6778716622135e795f00909">QCAD::distance</a>(allCoords, I, J, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>) &lt; cutoffDistance ) {
<a name="l01017"></a>01017   <span class="keywordflow">if</span>(treeIDs[I] == -1) {
<a name="l01018"></a>01018     treeIDs[I] = treeIDs[J];
<a name="l01019"></a>01019     treeSizes[treeIDs[I]]++;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021     <span class="keywordflow">if</span>(dbMode &gt; 3) std::cout &lt;&lt; <span class="stringliteral">&quot; --&gt; tree &quot;</span> &lt;&lt; treeIDs[J] 
<a name="l01022"></a>01022              &lt;&lt; <span class="stringliteral">&quot; ( size=&quot;</span> &lt;&lt; treeSizes[treeIDs[J]] &lt;&lt; <span class="stringliteral">&quot;, depth=&quot;</span> 
<a name="l01023"></a>01023              &lt;&lt; (allFieldVals[I]-minFieldVals[treeIDs[J]]) &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
<a name="l01024"></a>01024   }
<a name="l01025"></a>01025   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(treeIDs[I] != treeIDs[J]) {
<a name="l01026"></a>01026 
<a name="l01027"></a>01027     <span class="comment">//update number of deep trees</span>
<a name="l01028"></a>01028     nDeepTrees = 0;
<a name="l01029"></a>01029     <span class="keywordflow">for</span>(std::size_t t=0; t &lt; treeSizes.size(); t++) {
<a name="l01030"></a>01030       <span class="keywordflow">if</span>(treeSizes[t] &gt; 0 &amp;&amp; (allFieldVals[I]-minFieldVals[t]) &gt; minDepth) nDeepTrees++;
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="keywordtype">bool</span> mergingTwoDeepTrees = <span class="keyword">false</span>;
<a name="l01034"></a>01034     <span class="keywordflow">if</span>((allFieldVals[I]-minFieldVals[treeIDs[I]]) &gt; minDepth &amp;&amp; 
<a name="l01035"></a>01035        (allFieldVals[I]-minFieldVals[treeIDs[J]]) &gt; minDepth) {
<a name="l01036"></a>01036       mergingTwoDeepTrees = <span class="keyword">true</span>;
<a name="l01037"></a>01037       nDeepTrees--;
<a name="l01038"></a>01038     }
<a name="l01039"></a>01039 
<a name="l01040"></a>01040     treeIDtoReplace = treeIDs[I];
<a name="l01041"></a>01041     <span class="keywordflow">if</span>( minFieldVals[treeIDtoReplace] &lt; minFieldVals[treeIDs[J]] )
<a name="l01042"></a>01042       minFieldVals[treeIDs[J]] = minFieldVals[treeIDtoReplace];
<a name="l01043"></a>01043 
<a name="l01044"></a>01044     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=i; k &gt;=0; k--) {
<a name="l01045"></a>01045       K = ordering[k];
<a name="l01046"></a>01046       <span class="keywordflow">if</span>(treeIDs[K] == treeIDtoReplace) {
<a name="l01047"></a>01047         treeIDs[K] = treeIDs[J];
<a name="l01048"></a>01048         treeSizes[treeIDs[J]]++;
<a name="l01049"></a>01049       }
<a name="l01050"></a>01050     }
<a name="l01051"></a>01051     treeSizes[treeIDtoReplace] = 0;
<a name="l01052"></a>01052     nTrees -= 1;
<a name="l01053"></a>01053 
<a name="l01054"></a>01054     <span class="keywordflow">if</span>(dbMode &gt; 3) std::cout &lt;&lt; <span class="stringliteral">&quot;DEBUG:   also --&gt; &quot;</span> &lt;&lt; treeIDs[J] 
<a name="l01055"></a>01055              &lt;&lt; <span class="stringliteral">&quot; [merged] size=&quot;</span> &lt;&lt; treeSizes[treeIDs[J]]
<a name="l01056"></a>01056              &lt;&lt; <span class="stringliteral">&quot; (treecount after merge = &quot;</span> &lt;&lt; nTrees &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
<a name="l01057"></a>01057 
<a name="l01058"></a>01058     <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; <span class="stringliteral">&quot;--- Saddle: i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;merge: nPools=&quot;</span> &lt;&lt; nTrees 
<a name="l01059"></a>01059            &lt;&lt; <span class="stringliteral">&quot; nDeep=&quot;</span> &lt;&lt; nDeepTrees &lt;&lt; std::endl;
<a name="l01060"></a>01060 
<a name="l01061"></a>01061 
<a name="l01062"></a>01062     <span class="keywordflow">if</span>(mergingTwoDeepTrees &amp;&amp; nDeepTrees == 1) {
<a name="l01063"></a>01063       <span class="keywordflow">if</span>(dbMode &gt; 3) std::cout &lt;&lt; <span class="stringliteral">&quot;DEBUG: FOUND SADDLE! exiting.&quot;</span> &lt;&lt; std::endl;
<a name="l01064"></a>01064       <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; <span class="stringliteral">&quot;--- Saddle: i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; Found saddle at &quot;</span>;
<a name="l01065"></a>01065 
<a name="l01066"></a>01066             <span class="comment">//Found saddle at I</span>
<a name="l01067"></a>01067       g[0] = 0; <span class="comment">//TODO - change this g[.] interface to something more readable -- and we don&#39;t use g[0] now</span>
<a name="l01068"></a>01068             g[1] = allFieldVals[I];
<a name="l01069"></a>01069             <span class="keywordflow">for</span>(std::size_t k=0; k&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &amp;&amp; k &lt; 3; k++) {
<a name="l01070"></a>01070               g[2+k] = allCoords[k][I];
<a name="l01071"></a>01071               <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; allCoords[k][I] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l01072"></a>01072       }
<a name="l01073"></a>01073             
<a name="l01074"></a>01074       <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; <span class="stringliteral">&quot;ret=&quot;</span> &lt;&lt; g[0] &lt;&lt; std::endl;
<a name="l01075"></a>01075             <span class="keywordflow">return</span> 0; <span class="comment">//success</span>
<a name="l01076"></a>01076     }
<a name="l01077"></a>01077 
<a name="l01078"></a>01078   }
<a name="l01079"></a>01079       }
<a name="l01080"></a>01080 
<a name="l01081"></a>01081     } <span class="comment">//end j loop</span>
<a name="l01082"></a>01082     
<a name="l01083"></a>01083     <span class="keywordflow">if</span>(treeIDs[I] == -1) {
<a name="l01084"></a>01084       <span class="keywordflow">if</span>(dbMode &gt; 3) std::cout &lt;&lt; <span class="stringliteral">&quot; --&gt; new tree with ID &quot;</span> &lt;&lt; nextAvailableTreeID
<a name="l01085"></a>01085              &lt;&lt; <span class="stringliteral">&quot; (treecount after new = &quot;</span> &lt;&lt; (nTrees+1) &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
<a name="l01086"></a>01086       <span class="keywordflow">if</span>(dbMode &gt; 1) std::cout &lt;&lt; <span class="stringliteral">&quot;--- Saddle: i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; new pool: nPools=&quot;</span> &lt;&lt; (nTrees+1) 
<a name="l01087"></a>01087              &lt;&lt; <span class="stringliteral">&quot; nDeep=&quot;</span> &lt;&lt; nDeepTrees &lt;&lt; std::endl;
<a name="l01088"></a>01088 
<a name="l01089"></a>01089       treeIDs[I] = nextAvailableTreeID++;
<a name="l01090"></a>01090       minFieldVals.push_back(allFieldVals[I]);
<a name="l01091"></a>01091       treeSizes.push_back(1);
<a name="l01092"></a>01092 
<a name="l01093"></a>01093       nTrees += 1;
<a name="l01094"></a>01094       <span class="keywordflow">if</span>(nTrees &gt; nMaxTrees) nMaxTrees = nTrees;
<a name="l01095"></a>01095     }
<a name="l01096"></a>01096 
<a name="l01097"></a>01097   } <span class="comment">// end i loop</span>
<a name="l01098"></a>01098 
<a name="l01099"></a>01099   <span class="comment">// if no saddle found, return all zeros</span>
<a name="l01100"></a>01100   <span class="keywordflow">if</span>(dbMode &gt; 3) std::cout &lt;&lt; <span class="stringliteral">&quot;DEBUG: NO SADDLE. exiting.&quot;</span> &lt;&lt; std::endl;
<a name="l01101"></a>01101   <span class="keywordflow">for</span>(std::size_t k=0; k&lt;5; k++) g[k] = 0;
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   <span class="comment">// if two or more trees where found, then reason for failure is that not</span>
<a name="l01104"></a>01104   <span class="comment">//  enough deep pools were found - so could try to reduce minDepth and re-run.</span>
<a name="l01105"></a>01105   <span class="keywordflow">if</span>(nMaxTrees &gt;= 2) <span class="keywordflow">return</span> 1;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107   <span class="comment">// nMaxTrees &lt; 2 - so we need more trees.  Could try to increase cutoffDistance and/or cutoffFieldVal.</span>
<a name="l01108"></a>01108   <span class="keywordflow">return</span> 2;
<a name="l01109"></a>01109 }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 
<a name="l01112"></a>01112 <span class="keywordtype">double</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a4e8f33287ccd79dcf2f5639bf96eb658">QCAD::SaddleValueResponseFunction::getCurrent</a>
<a name="l01113"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a4e8f33287ccd79dcf2f5639bf96eb658">01113</a>   (<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lattTemp, <span class="keyword">const</span> Teuchos::RCP&lt;QCAD::MaterialDatabase&gt;&amp; materialDB) <span class="keyword">const</span>
<a name="l01114"></a>01114 {
<a name="l01115"></a>01115   <span class="keyword">const</span> <span class="keywordtype">double</span> kB = 8.617332e-5;  <span class="comment">// eV/K</span>
<a name="l01116"></a>01116   <span class="keywordtype">double</span> Temp = lattTemp;   <span class="comment">// K</span>
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <span class="comment">// segmentLength[i] == distance between imagePt[i] and imagePt[i+1]</span>
<a name="l01119"></a>01119   <span class="keywordtype">double</span>* segmentLength = <span class="keyword">new</span> <span class="keywordtype">double</span>[nImagePts-1]; 
<a name="l01120"></a>01120 
<a name="l01121"></a>01121   <span class="comment">// path length before and after saddle point</span>
<a name="l01122"></a>01122   <span class="keywordtype">double</span> lengthBefore = 0.0, lengthAfter = 0.0;    
<a name="l01123"></a>01123 
<a name="l01124"></a>01124   <span class="comment">// get the distances along each leg of the final saddle path</span>
<a name="l01125"></a>01125   <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; nImagePts-1; i++) 
<a name="l01126"></a>01126   {
<a name="l01127"></a>01127     segmentLength[i] = imagePts[i].coords.distanceTo(imagePts[i+1].coords);
<a name="l01128"></a>01128     <span class="keywordflow">if</span>( (<span class="keywordtype">int</span>)i &lt; iSaddlePt ) 
<a name="l01129"></a>01129       lengthBefore += segmentLength[i];
<a name="l01130"></a>01130     <span class="keywordflow">else</span> 
<a name="l01131"></a>01131       lengthAfter += segmentLength[i];
<a name="l01132"></a>01132   }
<a name="l01133"></a>01133   
<a name="l01134"></a>01134   <span class="comment">// recalculate gfGridSpacing to obtain an integer number of points for GF-CBR calculation,</span>
<a name="l01135"></a>01135   <span class="comment">// this strategy produces path length that is slightly non-equally spaced due to precision.</span>
<a name="l01136"></a>01136   <span class="comment">// int nGFPts = int( (lengthBefore + lengthAfter)/gfGridSpacing ) + 1;</span>
<a name="l01137"></a>01137   <span class="comment">// double ptSpacing = (lengthBefore + lengthAfter)/(nGFPts-1);  // actual GF Grid Spacing</span>
<a name="l01138"></a>01138   
<a name="l01139"></a>01139   <span class="comment">// set actual grid spacing to user-defined value for GF-CBR calculation,</span>
<a name="l01140"></a>01140   <span class="keywordtype">double</span> ptSpacing = gfGridSpacing;
<a name="l01141"></a>01141   <span class="keywordtype">int</span> nGFPts = int( (lengthBefore + lengthAfter)/gfGridSpacing );
<a name="l01142"></a>01142   std::cout &lt;&lt; <span class="stringliteral">&quot;nGFPts = &quot;</span> &lt;&lt; nGFPts &lt;&lt; <span class="stringliteral">&quot;, actual gfGridSpacing = &quot;</span> &lt;&lt; ptSpacing &lt;&lt; std::endl; 
<a name="l01143"></a>01143 
<a name="l01144"></a>01144   <span class="comment">// hard-code eff. mass along the saddle path using Reference Material&#39;s transverse eff. mass</span>
<a name="l01145"></a>01145   std::string refMtrlName = materialDB-&gt;getParam&lt;std::string&gt;(<span class="stringliteral">&quot;Reference Material&quot;</span>);
<a name="l01146"></a>01146   <span class="keywordtype">double</span> effMass = materialDB-&gt;getMaterialParam&lt;<span class="keywordtype">double</span>&gt;(refMtrlName,<span class="stringliteral">&quot;Transverse Electron Effective Mass&quot;</span>);
<a name="l01147"></a>01147 
<a name="l01148"></a>01148   <span class="comment">// hard-code electron affinity using the Reference Material&#39;s value</span>
<a name="l01149"></a>01149   <span class="keywordtype">double</span> matChi = materialDB-&gt;getMaterialParam&lt;<span class="keywordtype">double</span>&gt;(refMtrlName,<span class="stringliteral">&quot;Electron Affinity&quot;</span>);
<a name="l01150"></a>01150 
<a name="l01151"></a>01151   <span class="comment">// unscale the Field Scaling Factor to obtain the actual Potential in [V]</span>
<a name="l01152"></a>01152   Teuchos::RCP&lt;std::vector&lt;double&gt; &gt; pot = Teuchos::rcp( <span class="keyword">new</span> std::vector&lt;double&gt;(finalPts.size()) );
<a name="l01153"></a>01153   <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; finalPts.size(); i++)
<a name="l01154"></a>01154     (*pot)[i] = finalPts[i].value / fieldScaling;
<a name="l01155"></a>01155     
<a name="l01156"></a>01156   <span class="comment">// compute energy reference</span>
<a name="l01157"></a>01157   <span class="keywordtype">double</span> qPhiRef;
<a name="l01158"></a>01158   {
<a name="l01159"></a>01159     std::string category = materialDB-&gt;getMaterialParam&lt;std::string&gt;(refMtrlName,<span class="stringliteral">&quot;Category&quot;</span>);
<a name="l01160"></a>01160     <span class="keywordflow">if</span> (category == <span class="stringliteral">&quot;Semiconductor&quot;</span>) 
<a name="l01161"></a>01161     {
<a name="l01162"></a>01162       <span class="comment">// Same qPhiRef needs to be used for the entire structure</span>
<a name="l01163"></a>01163       <span class="keywordtype">double</span> mdn = materialDB-&gt;getMaterialParam&lt;<span class="keywordtype">double</span>&gt;(refMtrlName,<span class="stringliteral">&quot;Electron DOS Effective Mass&quot;</span>);
<a name="l01164"></a>01164       <span class="keywordtype">double</span> mdp = materialDB-&gt;getMaterialParam&lt;<span class="keywordtype">double</span>&gt;(refMtrlName,<span class="stringliteral">&quot;Hole DOS Effective Mass&quot;</span>);
<a name="l01165"></a>01165       <span class="keywordtype">double</span> Chi = materialDB-&gt;getMaterialParam&lt;<span class="keywordtype">double</span>&gt;(refMtrlName,<span class="stringliteral">&quot;Electron Affinity&quot;</span>);
<a name="l01166"></a>01166       <span class="keywordtype">double</span> Eg0 = materialDB-&gt;getMaterialParam&lt;<span class="keywordtype">double</span>&gt;(refMtrlName,<span class="stringliteral">&quot;Zero Temperature Band Gap&quot;</span>);
<a name="l01167"></a>01167       <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a4d08741b97fea3938089670d2a84c598">alpha</a> = materialDB-&gt;getMaterialParam&lt;<span class="keywordtype">double</span>&gt;(refMtrlName,<span class="stringliteral">&quot;Band Gap Alpha Coefficient&quot;</span>);
<a name="l01168"></a>01168       <span class="keywordtype">double</span> beta = materialDB-&gt;getMaterialParam&lt;<span class="keywordtype">double</span>&gt;(refMtrlName,<span class="stringliteral">&quot;Band Gap Beta Coefficient&quot;</span>);
<a name="l01169"></a>01169       
<a name="l01170"></a>01170       <span class="keywordtype">double</span> Eg = Eg0 - alpha*pow(Temp,2.0)/(beta+Temp); <span class="comment">// in [eV]</span>
<a name="l01171"></a>01171       <span class="keywordtype">double</span> kbT = kB * Temp;      <span class="comment">// in [eV]</span>
<a name="l01172"></a>01172       <span class="keywordtype">double</span> Eic = -Eg/2. + 3./4.*kbT*log(mdp/mdn);  <span class="comment">// (Ei-Ec) in [eV]</span>
<a name="l01173"></a>01173       qPhiRef = Chi - Eic;  <span class="comment">// (Evac-Ei) in [eV] where Evac = vacuum level</span>
<a name="l01174"></a>01174     }
<a name="l01175"></a>01175     <span class="keywordflow">else</span> 
<a name="l01176"></a>01176       TEUCHOS_TEST_FOR_EXCEPTION (<span class="keyword">true</span>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l01177"></a>01177         &lt;&lt; <span class="stringliteral">&quot;Error!  Invalid category &quot;</span> &lt;&lt; category &lt;&lt; <span class="stringliteral">&quot; for reference material !&quot;</span> &lt;&lt; std::endl);
<a name="l01178"></a>01178   }  
<a name="l01179"></a>01179   
<a name="l01180"></a>01180   <span class="comment">// compute conduction band [eV] from the potential</span>
<a name="l01181"></a>01181   Teuchos::RCP&lt;std::vector&lt;double&gt; &gt; Ec = Teuchos::rcp( <span class="keyword">new</span> std::vector&lt;double&gt;(finalPts.size()) );
<a name="l01182"></a>01182   Teuchos::RCP&lt;std::vector&lt;double&gt; &gt; pathLen = Teuchos::rcp( <span class="keyword">new</span> std::vector&lt;double&gt;(finalPts.size()) );
<a name="l01183"></a>01183   
<a name="l01184"></a>01184   <span class="keywordtype">double</span> pathLength = 0.0;
<a name="l01185"></a>01185   <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; finalPts.size(); i++)
<a name="l01186"></a>01186   {
<a name="l01187"></a>01187     (*Ec)[i] = qPhiRef - matChi - (*pot)[i];
<a name="l01188"></a>01188     (*pathLen)[i] = pathLength;  
<a name="l01189"></a>01189     <span class="keywordflow">if</span> (i &lt; (finalPts.size()-1))
<a name="l01190"></a>01190       pathLength += finalPts[i].coords.distanceTo(finalPts[i+1].coords);
<a name="l01191"></a>01191   }
<a name="l01192"></a>01192     
<a name="l01193"></a>01193   <span class="comment">// append the computed Ec data to output file</span>
<a name="l01194"></a>01194   <span class="keywordflow">if</span>( outputFilename.length() &gt; 0) 
<a name="l01195"></a>01195   {
<a name="l01196"></a>01196     std::fstream out; 
<a name="l01197"></a>01197     out.open(outputFilename.c_str(), std::fstream::out | <a class="code" href="InterfaceTry_8cpp.html#a5687d6d7d8e1356f9cbed0616b9e7cec">std::fstream::app</a>);
<a name="l01198"></a>01198     out &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;% Computed conduction band Ec (assumes field is Potential) -- &#39;final&#39; points&quot;</span> &lt;&lt; std::endl;
<a name="l01199"></a>01199     out &lt;&lt; <span class="stringliteral">&quot;% index xCoord yCoord Ec pathLength pointRadius&quot;</span> &lt;&lt; std::endl;
<a name="l01200"></a>01200     <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; finalPts.size(); i++) 
<a name="l01201"></a>01201     {
<a name="l01202"></a>01202       out &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; finalPts[i].coords[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; finalPts[i].coords[1] 
<a name="l01203"></a>01203           &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; (*Ec)[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; (*pathLen)[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; finalPts[i].radius &lt;&lt; std::endl;
<a name="l01204"></a>01204     }
<a name="l01205"></a>01205     out.close();
<a name="l01206"></a>01206   }   
<a name="l01207"></a>01207 
<a name="l01208"></a>01208   <span class="keywordtype">double</span> I = 0.0; 
<a name="l01209"></a>01209 
<a name="l01210"></a>01210   <span class="comment">// instantiate the GF-CBR solver to compute current</span>
<a name="l01211"></a>01211   <a class="code" href="classQCAD_1_1GreensFunctionTunnelingSolver.html">QCAD::GreensFunctionTunnelingSolver</a> <a class="code" href="felix__driver_8cpp.html#a972cd8f5f47d36a2a3cea6e71a0ffa11">solver</a>(Ec, pathLen, nGFPts, ptSpacing, effMass, <a class="code" href="felix__driver_8cpp.html#ab048c6f9fcbcfaa57ce68b00263dbebe">comm</a>, outputFilename); <span class="comment">//Teuchos::rcp(comm.Clone())</span>
<a name="l01212"></a>01212   
<a name="l01213"></a>01213   <span class="comment">// set the eigensolver to be used</span>
<a name="l01214"></a>01214   <span class="keywordtype">bool</span> bUseAnasazi = <span class="keyword">false</span>; 
<a name="l01215"></a>01215   <span class="keywordflow">if</span> (gfEigensolver == <span class="stringliteral">&quot;Anasazi&quot;</span>)
<a name="l01216"></a>01216      bUseAnasazi = <span class="keyword">true</span>; 
<a name="l01217"></a>01217   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gfEigensolver == <span class="stringliteral">&quot;tql2&quot;</span>)
<a name="l01218"></a>01218      bUseAnasazi = <span class="keyword">false</span>; 
<a name="l01219"></a>01219   <span class="keywordflow">else</span>
<a name="l01220"></a>01220      TEUCHOS_TEST_FOR_EXCEPTION (<span class="keyword">true</span>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l01221"></a>01221         &lt;&lt; <span class="stringliteral">&quot;Error!  Invalid GF-CBR Method Eigensolver, must be either Anasazi or tql2 !&quot;</span> &lt;&lt; std::endl);
<a name="l01222"></a>01222   
<a name="l01223"></a>01223   <span class="comment">// compute the currents for a range of Vds values</span>
<a name="l01224"></a>01224   <span class="keywordflow">if</span> (bSweepVds)   
<a name="l01225"></a>01225   {
<a name="l01226"></a>01226     <span class="keywordtype">int</span> ptsVds = stepsVds + 1;  <span class="comment">// include the ending point</span>
<a name="l01227"></a>01227     std::vector&lt;double&gt; rangeVds(ptsVds, 0.0);
<a name="l01228"></a>01228     std::vector&lt;double&gt; rangeIds(ptsVds, 0.0); 
<a name="l01229"></a>01229     
<a name="l01230"></a>01230     <span class="keywordtype">double</span> deltaVds = (finalVds - initVds) / <span class="keywordtype">double</span>(ptsVds-1); 
<a name="l01231"></a>01231     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ptsVds; i++)
<a name="l01232"></a>01232       rangeVds[i] = initVds + deltaVds * <span class="keywordtype">double</span>(i); 
<a name="l01233"></a>01233     
<a name="l01234"></a>01234     solver.<a class="code" href="classQCAD_1_1GreensFunctionTunnelingSolver.html#a5e8a40b013c714f533d476bc1861f26e">computeCurrentRange</a>(rangeVds, kB * Temp, current_Ecutoff_offset_from_Emax, rangeIds, bUseAnasazi);
<a name="l01235"></a>01235     
<a name="l01236"></a>01236     <span class="comment">// set I to the last value of rangeIds</span>
<a name="l01237"></a>01237     I = rangeIds[ptsVds-1];
<a name="l01238"></a>01238 
<a name="l01239"></a>01239     <span class="comment">// write Vds vs. Ids data to file</span>
<a name="l01240"></a>01240     <span class="keywordflow">if</span> ( outputFilename.length() &gt; 0) 
<a name="l01241"></a>01241     {
<a name="l01242"></a>01242       std::fstream out; 
<a name="l01243"></a>01243       out.open(outputFilename.c_str(), std::fstream::out | <a class="code" href="InterfaceTry_8cpp.html#a5687d6d7d8e1356f9cbed0616b9e7cec">std::fstream::app</a>);
<a name="l01244"></a>01244       out &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;% Current vs Voltage IV curve (GF-CBR method)&quot;</span> &lt;&lt; std::endl;
<a name="l01245"></a>01245       out &lt;&lt; <span class="stringliteral">&quot;% index, Vds [V] vs Ids [A] data&quot;</span> &lt;&lt; std::endl;
<a name="l01246"></a>01246       <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; rangeVds.size(); i++) 
<a name="l01247"></a>01247         out &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rangeVds[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rangeIds[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::endl;
<a name="l01248"></a>01248       out.close();
<a name="l01249"></a>01249     }
<a name="l01250"></a>01250     
<a name="l01251"></a>01251   }  <span class="comment">// end of if (bSweepVds)</span>
<a name="l01252"></a>01252   
<a name="l01253"></a>01253   <span class="comment">// compute the current for a single Vds value</span>
<a name="l01254"></a>01254   <span class="keywordflow">else</span>             
<a name="l01255"></a>01255     I = solver.<a class="code" href="classQCAD_1_1GreensFunctionTunnelingSolver.html#a33cd2a7d544fa9a028827b513334ce6e">computeCurrent</a>(finalVds, kB * Temp, current_Ecutoff_offset_from_Emax, bUseAnasazi); <span class="comment">// overwrite &quot;Return Field Val&quot; with current</span>
<a name="l01256"></a>01256   
<a name="l01257"></a>01257   std::cout &lt;&lt; <span class="stringliteral">&quot;Final Vds = &quot;</span> &lt;&lt; finalVds &lt;&lt; <span class="stringliteral">&quot; V, Current Ids = &quot;</span> &lt;&lt; I &lt;&lt; <span class="stringliteral">&quot; Amps&quot;</span> &lt;&lt; std::endl;
<a name="l01258"></a>01258   
<a name="l01259"></a>01259   <span class="keywordflow">return</span> I;
<a name="l01260"></a>01260 }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262 
<a name="l01263"></a>01263 <span class="keywordtype">void</span>
<a name="l01264"></a>01264 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f8dc13bf289c6d2ac6422f5ee271d8a" title="Evaluate tangent = dg/dx*dx/dp + dg/dxdot*dxdot/dp + dg/dp.">QCAD::SaddleValueResponseFunction::</a>
<a name="l01265"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f8dc13bf289c6d2ac6422f5ee271d8a">01265</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f8dc13bf289c6d2ac6422f5ee271d8a" title="Evaluate tangent = dg/dx*dx/dp + dg/dxdot*dxdot/dp + dg/dp.">evaluateTangent</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a4d08741b97fea3938089670d2a84c598">alpha</a>, 
<a name="l01266"></a>01266     <span class="keyword">const</span> <span class="keywordtype">double</span> beta,
<a name="l01267"></a>01267     <span class="keyword">const</span> <span class="keywordtype">double</span> omega,
<a name="l01268"></a>01268     <span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l01269"></a>01269     <span class="keywordtype">bool</span> sum_derivs,
<a name="l01270"></a>01270     <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l01271"></a>01271     <span class="keyword">const</span> Epetra_Vector* xdotdot,
<a name="l01272"></a>01272     <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l01273"></a>01273     <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l01274"></a>01274     <a class="code" href="Albany__DataTypes_8hpp.html#aa17b892cdb0cb1ec55119bb8b01cb49e">ParamVec</a>* deriv_p,
<a name="l01275"></a>01275     <span class="keyword">const</span> Epetra_MultiVector* Vxdot,
<a name="l01276"></a>01276     <span class="keyword">const</span> Epetra_MultiVector* Vxdotdot,
<a name="l01277"></a>01277     <span class="keyword">const</span> Epetra_MultiVector* Vx,
<a name="l01278"></a>01278     <span class="keyword">const</span> Epetra_MultiVector* Vp,
<a name="l01279"></a>01279     Epetra_Vector* <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>,
<a name="l01280"></a>01280     Epetra_MultiVector* gx,
<a name="l01281"></a>01281     Epetra_MultiVector* gp)
<a name="l01282"></a>01282 {
<a name="l01283"></a>01283 
<a name="l01284"></a>01284   <span class="comment">// Require that g be computed to get tangent info </span>
<a name="l01285"></a>01285   <span class="keywordflow">if</span>(g != NULL) {
<a name="l01286"></a>01286     
<a name="l01287"></a>01287     <span class="comment">// HACK: for now do not evaluate response when tangent is requested,</span>
<a name="l01288"></a>01288     <span class="comment">//   as it is assumed that evaluateResponse has already been called</span>
<a name="l01289"></a>01289     <span class="comment">//   directly or by evaluateGradient.  This prevents repeated calling </span>
<a name="l01290"></a>01290     <span class="comment">//   of evaluateResponse within the dg/dp loop of Albany::ModelEvaluator&#39;s</span>
<a name="l01291"></a>01291     <span class="comment">//   evalModel(...) function.  matchesCurrentResults(...) would be able to </span>
<a name="l01292"></a>01292     <span class="comment">//   determine if evaluateResponse needs to be run, but </span>
<a name="l01293"></a>01293     <span class="comment">//   Albany::AggregateScalarReponseFunction does not copy from global g </span>
<a name="l01294"></a>01294     <span class="comment">//   to local g so the g parameter passed to this function will always </span>
<a name="l01295"></a>01295     <span class="comment">//   be zeros when used in an aggregate response fn.  Change this?</span>
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     <span class="comment">// Evaluate response g and run algorithm (if it hasn&#39;t run already)</span>
<a name="l01298"></a>01298     <span class="comment">//if(!matchesCurrentResults(*g)) </span>
<a name="l01299"></a>01299     <span class="comment">//  evaluateResponse(current_time, xdot, x, p, *g);</span>
<a name="l01300"></a>01300 
<a name="l01301"></a>01301     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f448b8545d73515c1606edbb9a4d664" title="mode of current evaluator operation (maybe not thread safe?)">mode</a> = <span class="stringliteral">&quot;Fill saddle point&quot;</span>;
<a name="l01302"></a>01302     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f8dc13bf289c6d2ac6422f5ee271d8a" title="Evaluate tangent = dg/dx*dx/dp + dg/dxdot*dxdot/dp + dg/dp.">Albany::FieldManagerScalarResponseFunction::evaluateTangent</a>(
<a name="l01303"></a>01303                 alpha, beta, omega, current_time, sum_derivs, xdot, xdotdot,
<a name="l01304"></a>01304             x, p, deriv_p, Vxdot, Vxdotdot, Vx, Vp, g, gx, gp);
<a name="l01305"></a>01305   }
<a name="l01306"></a>01306   <span class="keywordflow">else</span> {
<a name="l01307"></a>01307     <span class="keywordflow">if</span> (gx != NULL) gx-&gt;PutScalar(0.0);
<a name="l01308"></a>01308     <span class="keywordflow">if</span> (gp != NULL) gp-&gt;PutScalar(0.0);
<a name="l01309"></a>01309   }
<a name="l01310"></a>01310 }
<a name="l01311"></a>01311 
<a name="l01312"></a>01312 <span class="keywordtype">void</span>
<a name="l01313"></a>01313 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aae52a7711d87151841e69b620097b3c0" title="Evaluate gradient = dg/dx, dg/dxdot, dg/dp.">QCAD::SaddleValueResponseFunction::</a>
<a name="l01314"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aae52a7711d87151841e69b620097b3c0">01314</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aae52a7711d87151841e69b620097b3c0" title="Evaluate gradient = dg/dx, dg/dxdot, dg/dp.">evaluateGradient</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l01315"></a>01315      <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l01316"></a>01316      <span class="keyword">const</span> Epetra_Vector* xdotdot,
<a name="l01317"></a>01317      <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l01318"></a>01318      <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l01319"></a>01319      <a class="code" href="Albany__DataTypes_8hpp.html#aa17b892cdb0cb1ec55119bb8b01cb49e">ParamVec</a>* deriv_p,
<a name="l01320"></a>01320      Epetra_Vector* <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>,
<a name="l01321"></a>01321      Epetra_MultiVector* dg_dx,
<a name="l01322"></a>01322      Epetra_MultiVector* dg_dxdot,
<a name="l01323"></a>01323      Epetra_MultiVector* dg_dxdotdot,
<a name="l01324"></a>01324      Epetra_MultiVector* dg_dp)
<a name="l01325"></a>01325 {
<a name="l01326"></a>01326 
<a name="l01327"></a>01327   <span class="comment">// Require that g be computed to get gradient info </span>
<a name="l01328"></a>01328   <span class="keywordflow">if</span>(g != NULL) {
<a name="l01329"></a>01329 
<a name="l01330"></a>01330     <span class="comment">// Evaluate response g and run algorithm (if it hasn&#39;t run already)</span>
<a name="l01331"></a>01331     <span class="keywordflow">if</span>(!<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6fa86918fe3859e2f74c71d12b9517a8">matchesCurrentResults</a>(*g)) 
<a name="l01332"></a>01332       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46" title="Evaluate responses.">evaluateResponse</a>(current_time, xdot, xdotdot, x, p, *g);
<a name="l01333"></a>01333 
<a name="l01334"></a>01334     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f448b8545d73515c1606edbb9a4d664" title="mode of current evaluator operation (maybe not thread safe?)">mode</a> = <span class="stringliteral">&quot;Fill saddle point&quot;</span>;
<a name="l01335"></a>01335     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aae52a7711d87151841e69b620097b3c0" title="Evaluate gradient = dg/dx, dg/dxdot, dg/dp.">Albany::FieldManagerScalarResponseFunction::evaluateGradient</a>(
<a name="l01336"></a>01336      current_time, xdot, xdotdot, x, p, deriv_p, g, dg_dx, dg_dxdot, dg_dxdotdot, dg_dp);
<a name="l01337"></a>01337   }
<a name="l01338"></a>01338   <span class="keywordflow">else</span> {
<a name="l01339"></a>01339     <span class="keywordflow">if</span> (dg_dx != NULL)    dg_dx-&gt;PutScalar(0.0);
<a name="l01340"></a>01340     <span class="keywordflow">if</span> (dg_dxdot != NULL) dg_dxdot-&gt;PutScalar(0.0);
<a name="l01341"></a>01341     <span class="keywordflow">if</span> (dg_dp != NULL)    dg_dp-&gt;PutScalar(0.0);
<a name="l01342"></a>01342   }
<a name="l01343"></a>01343 }
<a name="l01344"></a>01344 
<a name="l01345"></a>01345 <span class="keywordtype">void</span> 
<a name="l01346"></a>01346 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a43e3e761b8d15f48888032bb74643b26" title="Post process responses.">QCAD::SaddleValueResponseFunction::</a>
<a name="l01347"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a43e3e761b8d15f48888032bb74643b26">01347</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a43e3e761b8d15f48888032bb74643b26" title="Post process responses.">postProcessResponses</a>(<span class="keyword">const</span> Epetra_Comm&amp; comm_, <span class="keyword">const</span> Teuchos::RCP&lt;Epetra_Vector&gt;&amp; <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>)
<a name="l01348"></a>01348 {
<a name="l01349"></a>01349 }
<a name="l01350"></a>01350 
<a name="l01351"></a>01351 <span class="keywordtype">void</span> 
<a name="l01352"></a>01352 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ae61b8109a5f54af591f85f37500d174d" title="Post process response derivatives.">QCAD::SaddleValueResponseFunction::</a>
<a name="l01353"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ae61b8109a5f54af591f85f37500d174d">01353</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ae61b8109a5f54af591f85f37500d174d" title="Post process response derivatives.">postProcessResponseDerivatives</a>(<span class="keyword">const</span> Epetra_Comm&amp; comm_, <span class="keyword">const</span> Teuchos::RCP&lt;Epetra_MultiVector&gt;&amp; gt)
<a name="l01354"></a>01354 {
<a name="l01355"></a>01355 }
<a name="l01356"></a>01356 
<a name="l01357"></a>01357 
<a name="l01358"></a>01358 <span class="keywordtype">void</span>
<a name="l01359"></a>01359 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa9f2a82562af0598ffbbc806d8948434" title="Helper functions for doNudgedElasticBand(...).">QCAD::SaddleValueResponseFunction::</a>
<a name="l01360"></a>01360 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa9f2a82562af0598ffbbc806d8948434" title="Helper functions for doNudgedElasticBand(...).">getImagePointValues</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l01361"></a>01361         <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l01362"></a>01362         <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l01363"></a>01363         <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l01364"></a>01364         Epetra_Vector&amp; <a class="code" href="namespaceFELIX.html#a6288e24787bb4182b95927dafefba8fe">g</a>, 
<a name="l01365"></a>01365         <span class="keywordtype">double</span>* globalPtValues,
<a name="l01366"></a>01366         <span class="keywordtype">double</span>* globalPtWeights,
<a name="l01367"></a>01367         <span class="keywordtype">double</span>* globalPtGrads,
<a name="l01368"></a>01368         std::vector&lt;QCAD::mathVector&gt; lastPositions,
<a name="l01369"></a>01369         <span class="keywordtype">int</span> dbMode)
<a name="l01370"></a>01370 {
<a name="l01371"></a>01371   <span class="comment">//Set xmax,xmin,ymax,ymin based on points</span>
<a name="l01372"></a>01372   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a> = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a> = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords[0];
<a name="l01373"></a>01373   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a> = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a> = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords[1];
<a name="l01374"></a>01374   <span class="keywordflow">for</span>(std::size_t i=1; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6eb505656123ef131464841770970e7e">nImagePts</a>; i++) {
<a name="l01375"></a>01375     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a> = std::min(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[0],<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a>);
<a name="l01376"></a>01376     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a> = std::max(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[0],<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a>);
<a name="l01377"></a>01377     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a> = std::min(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[1],<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a>);
<a name="l01378"></a>01378     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a> = std::max(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[1],<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a>);
<a name="l01379"></a>01379   }
<a name="l01380"></a>01380   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a> -= 5*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a> += 5*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>;
<a name="l01381"></a>01381   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a> -= 5*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a> += 5*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>;
<a name="l01382"></a>01382     
<a name="l01383"></a>01383   <span class="comment">//Reset value, weight, and gradient of image points as these are accumulated by evaluator fill</span>
<a name="l01384"></a>01384   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a60d3435342ec9032dd55e4dac1378533" title="accumulation vectors for evaluator to fill">imagePtValues</a>.fill(0.0);
<a name="l01385"></a>01385   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab59d0d98b3cec0fbab0055e4941d33b5">imagePtWeights</a>.fill(0.0);
<a name="l01386"></a>01386   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d706bcd0aab5b33aa17e424145b074b">imagePtGradComps</a>.fill(0.0);
<a name="l01387"></a>01387 
<a name="l01388"></a>01388   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8fdd456a00773defd2b33e0abe645ed9" title="data for memory-intensive but fast mode (hold entire proc&amp;#39;s data)">bAggregateWorksets</a>) {
<a name="l01389"></a>01389     <span class="comment">//Use cached field and coordinate values to perform fill    </span>
<a name="l01390"></a>01390     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a7f7ef926162ac95e9027e6a761f2dfa6">vFieldValues</a>.size(); i++) {
<a name="l01391"></a>01391       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a18e45351e8f507ccf31aadcbb8d15241">addImagePointData</a>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a07d6c1f20454560f5a2d56b2dcc47efc">vCoords</a>[i].data, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a7f7ef926162ac95e9027e6a761f2dfa6">vFieldValues</a>[i], <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad2a4803f00148f8a686eb1a163ea8602">vGrads</a>[i].data );
<a name="l01392"></a>01392     } 
<a name="l01393"></a>01393   }
<a name="l01394"></a>01394   <span class="keywordflow">else</span> {
<a name="l01395"></a>01395     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f448b8545d73515c1606edbb9a4d664" title="mode of current evaluator operation (maybe not thread safe?)">mode</a> = <span class="stringliteral">&quot;Collect image point data&quot;</span>;
<a name="l01396"></a>01396     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46" title="Evaluate responses.">Albany::FieldManagerScalarResponseFunction::evaluateResponse</a>(
<a name="l01397"></a>01397              current_time, xdot, NULL, x, p, g);
<a name="l01398"></a>01398   }
<a name="l01399"></a>01399 
<a name="l01400"></a>01400   <span class="comment">//MPI -- sum weights, value, and gradient for each image pt</span>
<a name="l01401"></a>01401   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;SumAll( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a60d3435342ec9032dd55e4dac1378533" title="accumulation vectors for evaluator to fill">imagePtValues</a>.data(),    globalPtValues,  nImagePts );
<a name="l01402"></a>01402   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;SumAll( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab59d0d98b3cec0fbab0055e4941d33b5">imagePtWeights</a>.data(),   globalPtWeights, nImagePts );
<a name="l01403"></a>01403   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;SumAll( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d706bcd0aab5b33aa17e424145b074b">imagePtGradComps</a>.data(), globalPtGrads,   nImagePts*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> );
<a name="l01404"></a>01404 
<a name="l01405"></a>01405   <span class="comment">// Put summed data into imagePts, normalizing value and </span>
<a name="l01406"></a>01406   <span class="comment">//   gradient from different cell contributions</span>
<a name="l01407"></a>01407   <span class="keywordflow">for</span>(std::size_t i=0; i&lt;nImagePts; i++) {
<a name="l01408"></a>01408     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].weight = globalPtWeights[i];
<a name="l01409"></a>01409     <span class="keywordflow">if</span>(globalPtWeights[i] &gt; 1e-6) {
<a name="l01410"></a>01410       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].value = globalPtValues[i] / <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].weight;
<a name="l01411"></a>01411       <span class="keywordflow">for</span>(std::size_t k=0; k&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; k++) 
<a name="l01412"></a>01412   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].grad[k] = globalPtGrads[k*nImagePts+i] / <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].weight;
<a name="l01413"></a>01413     }
<a name="l01414"></a>01414     <span class="keywordflow">else</span> { 
<a name="l01415"></a>01415       <span class="comment">//assume point has drifted off region: leave value as, set gradient to zero, and reset position</span>
<a name="l01416"></a>01416       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].grad.fill(0.0);
<a name="l01417"></a>01417       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords = lastPositions[i];
<a name="l01418"></a>01418     }
<a name="l01419"></a>01419   }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421   <span class="keywordflow">return</span>;
<a name="l01422"></a>01422 }
<a name="l01423"></a>01423 
<a name="l01424"></a>01424 <span class="keywordtype">void</span>
<a name="l01425"></a>01425 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1e008acff131377db975e6763e38e61f">QCAD::SaddleValueResponseFunction::</a>
<a name="l01426"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1e008acff131377db975e6763e38e61f">01426</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1e008acff131377db975e6763e38e61f">getFinalImagePointValues</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> current_time,
<a name="l01427"></a>01427         <span class="keyword">const</span> Epetra_Vector* xdot,
<a name="l01428"></a>01428         <span class="keyword">const</span> Epetra_Vector&amp; x,
<a name="l01429"></a>01429         <span class="keyword">const</span> Teuchos::Array&lt;ParamVec&gt;&amp; p,
<a name="l01430"></a>01430         Epetra_Vector&amp; g, 
<a name="l01431"></a>01431         <span class="keywordtype">int</span> dbMode)
<a name="l01432"></a>01432 {
<a name="l01433"></a>01433   <span class="comment">//Set xmax,xmin,ymax,ymin based on points</span>
<a name="l01434"></a>01434   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a> = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a> = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords[0];
<a name="l01435"></a>01435   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a> = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a> = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords[1];
<a name="l01436"></a>01436   <span class="keywordflow">for</span>(std::size_t i=1; i&lt;nImagePts; i++) {
<a name="l01437"></a>01437     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a> = std::min(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[0],<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a>);
<a name="l01438"></a>01438     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a> = std::max(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[0],<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a>);
<a name="l01439"></a>01439     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a> = std::min(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[1],<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a>);
<a name="l01440"></a>01440     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a> = std::max(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[1],<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a>);
<a name="l01441"></a>01441   }
<a name="l01442"></a>01442   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a> -= 5*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a> += 5*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>;
<a name="l01443"></a>01443   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a> -= 5*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a> += 5*<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a800f01f0d5050eb6c272c501b5fe5b8d">imagePtSize</a>;
<a name="l01444"></a>01444     
<a name="l01445"></a>01445   <span class="comment">//Reset value and weight of final image points as these are accumulated by evaluator fill</span>
<a name="l01446"></a>01446   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a65cfb1b3cfc628bc78cbb71d45ae85e5">finalPtValues</a>.<a class="code" href="classQCAD_1_1mathVector.html#a1bd648d130f88b46ab4aa13ec15a77cb">fill</a>(0.0);
<a name="l01447"></a>01447   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ac7bb0be604afd45a2ae25d352314ee4f">finalPtWeights</a>.<a class="code" href="classQCAD_1_1mathVector.html#a1bd648d130f88b46ab4aa13ec15a77cb">fill</a>(0.0);
<a name="l01448"></a>01448 
<a name="l01449"></a>01449   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8fdd456a00773defd2b33e0abe645ed9" title="data for memory-intensive but fast mode (hold entire proc&amp;#39;s data)">bAggregateWorksets</a>) {
<a name="l01450"></a>01450     <span class="comment">//Use cached field and coordinate values to perform fill    </span>
<a name="l01451"></a>01451     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a7f7ef926162ac95e9027e6a761f2dfa6">vFieldValues</a>.size(); i++) {
<a name="l01452"></a>01452       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d1077b6c59512446865c598f344b269">addFinalImagePointData</a>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a07d6c1f20454560f5a2d56b2dcc47efc">vCoords</a>[i].data, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a7f7ef926162ac95e9027e6a761f2dfa6">vFieldValues</a>[i] );
<a name="l01453"></a>01453     } 
<a name="l01454"></a>01454   }
<a name="l01455"></a>01455   <span class="keywordflow">else</span> {
<a name="l01456"></a>01456     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f448b8545d73515c1606edbb9a4d664" title="mode of current evaluator operation (maybe not thread safe?)">mode</a> = <span class="stringliteral">&quot;Collect final image point data&quot;</span>;
<a name="l01457"></a>01457     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab9993d763e145f1f2eb99944342bba46" title="Evaluate responses.">Albany::FieldManagerScalarResponseFunction::evaluateResponse</a>(
<a name="l01458"></a>01458              current_time, xdot, NULL, x, p, g);
<a name="l01459"></a>01459   }
<a name="l01460"></a>01460 
<a name="l01461"></a>01461   <span class="comment">//MPI -- sum weights, value, and gradient for each image pt</span>
<a name="l01462"></a>01462   std::size_t nFinalPts = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>.size();
<a name="l01463"></a>01463   <span class="keywordflow">if</span>(nFinalPts &gt; 0) {
<a name="l01464"></a>01464     <span class="keywordtype">double</span>*  globalPtValues   = <span class="keyword">new</span> <span class="keywordtype">double</span> [nFinalPts];
<a name="l01465"></a>01465     <span class="keywordtype">double</span>*  globalPtWeights  = <span class="keyword">new</span> <span class="keywordtype">double</span> [nFinalPts];
<a name="l01466"></a>01466     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;SumAll( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a65cfb1b3cfc628bc78cbb71d45ae85e5">finalPtValues</a>.<a class="code" href="classQCAD_1_1mathVector.html#a730d5d6b8e52f9f8ad628041e9efd74d">data</a>(),    globalPtValues,  nFinalPts );
<a name="l01467"></a>01467     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af257a2d54473ad16580460dc5d05c511" title="Epetra Communicator.">comm</a>-&gt;SumAll( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ac7bb0be604afd45a2ae25d352314ee4f">finalPtWeights</a>.<a class="code" href="classQCAD_1_1mathVector.html#a730d5d6b8e52f9f8ad628041e9efd74d">data</a>(),   globalPtWeights, nFinalPts );
<a name="l01468"></a>01468 
<a name="l01469"></a>01469     <span class="comment">// Put summed data into imagePts, normalizing value from different cell contributions</span>
<a name="l01470"></a>01470     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;nFinalPts; i++) {
<a name="l01471"></a>01471       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].weight = globalPtWeights[i];
<a name="l01472"></a>01472       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].grad.fill(0.0); <span class="comment">// don&#39;t use gradient -- always fill with zeros</span>
<a name="l01473"></a>01473 
<a name="l01474"></a>01474       <span class="keywordflow">if</span>(globalPtWeights[i] &gt; 1e-6) 
<a name="l01475"></a>01475   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].value = globalPtValues[i] / <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].weight;
<a name="l01476"></a>01476       <span class="keywordflow">else</span> 
<a name="l01477"></a>01477   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].value = 0.0; <span class="comment">// no weight, so just set value to zero</span>
<a name="l01478"></a>01478     }
<a name="l01479"></a>01479   }
<a name="l01480"></a>01480 
<a name="l01481"></a>01481   <span class="keywordflow">return</span>;
<a name="l01482"></a>01482 }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484 
<a name="l01485"></a>01485 
<a name="l01486"></a>01486 <span class="keywordtype">void</span>
<a name="l01487"></a>01487 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8613a720c4826c02c356bd5de724c868">QCAD::SaddleValueResponseFunction::</a>
<a name="l01488"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8613a720c4826c02c356bd5de724c868">01488</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8613a720c4826c02c356bd5de724c868">writeOutput</a>(<span class="keywordtype">int</span> nIters)
<a name="l01489"></a>01489 {
<a name="l01490"></a>01490   <span class="comment">// Write output every nEvery iterations</span>
<a name="l01491"></a>01491   <span class="keywordflow">if</span>( (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a3b4f189eadef077456f2d80944c32cf2">nEvery</a> &gt; 0) &amp;&amp; (nIters % <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a3b4f189eadef077456f2d80944c32cf2">nEvery</a> == 1) &amp;&amp; (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a>.length() &gt; 0)) {
<a name="l01492"></a>01492     std::fstream out; <span class="keywordtype">double</span> pathLength = 0.0;
<a name="l01493"></a>01493     out.open(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a611da312f447e8bc3b0cd10f7f0bdff5">outputFilename</a>.c_str(), std::fstream::out | <a class="code" href="InterfaceTry_8cpp.html#a5687d6d7d8e1356f9cbed0616b9e7cec">std::fstream::app</a>);
<a name="l01494"></a>01494     out &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;% NEB Iteration &quot;</span> &lt;&lt; nIters &lt;&lt; std::endl;
<a name="l01495"></a>01495     out &lt;&lt; <span class="stringliteral">&quot;% index xCoord yCoord value pathLength pointRadius&quot;</span> &lt;&lt; std::endl;
<a name="l01496"></a>01496     <span class="keywordflow">for</span>(std::size_t i=0; i&lt;nImagePts; i++) {
<a name="l01497"></a>01497       out &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords[1]
<a name="l01498"></a>01498     &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].value &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; pathLength &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].radius &lt;&lt; std::endl;
<a name="l01499"></a>01499       <span class="keywordflow">if</span>(i&lt;nImagePts-1) pathLength += <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords.distanceTo(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].coords);
<a name="l01500"></a>01500     }    
<a name="l01501"></a>01501     out.close();
<a name="l01502"></a>01502   }
<a name="l01503"></a>01503 }
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 <span class="keywordtype">void</span>
<a name="l01506"></a>01506 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d47596776438f31cb7944ea33bf57bd">QCAD::SaddleValueResponseFunction::</a>
<a name="l01507"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d47596776438f31cb7944ea33bf57bd">01507</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d47596776438f31cb7944ea33bf57bd">initialIterationSetup</a>(<span class="keywordtype">double</span>&amp; gradScale, <span class="keywordtype">double</span>&amp; springScale, <span class="keywordtype">int</span> dbMode)
<a name="l01508"></a>01508 {
<a name="l01509"></a>01509   <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; initialPt = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords;
<a name="l01510"></a>01510   <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; finalPt = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].coords;
<a name="l01511"></a>01511 
<a name="l01512"></a>01512   <span class="keywordtype">double</span> maxGradMag = 0.0, avgWeight = 0.0, ifDist;
<a name="l01513"></a>01513   <span class="keywordflow">for</span>(std::size_t i=0; i&lt;nImagePts; i++) {
<a name="l01514"></a>01514     maxGradMag = std::max(maxGradMag, <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].grad.norm());
<a name="l01515"></a>01515     avgWeight += <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].weight;
<a name="l01516"></a>01516   }
<a name="l01517"></a>01517   ifDist = initialPt.<a class="code" href="classQCAD_1_1mathVector.html#a2a1cfe47ce9d7559688d87bc5e1c7660">distanceTo</a>(finalPt);
<a name="l01518"></a>01518   avgWeight /= nImagePts;
<a name="l01519"></a>01519   gradScale = ifDist / maxGradMag;  <span class="comment">// want scale*maxGradMag*(dt=1.0) = distance btw initial &amp; final pts</span>
<a name="l01520"></a>01520 
<a name="l01521"></a>01521   <span class="comment">// want springScale * (baseSpringConst=1.0) * (initial distance btwn pts) = scale*maxGradMag = distance btwn initial &amp; final pts</span>
<a name="l01522"></a>01522   <span class="comment">//  so springScale = (nImagePts-1)</span>
<a name="l01523"></a>01523   springScale = (double) (nImagePts-1);
<a name="l01524"></a>01524 
<a name="l01525"></a>01525   <span class="keywordflow">if</span>(dbMode) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  First iteration:  maxGradMag=&quot;</span> &lt;&lt; maxGradMag
<a name="l01526"></a>01526            &lt;&lt; <span class="stringliteral">&quot; |init-final|=&quot;</span> &lt;&lt; ifDist &lt;&lt; <span class="stringliteral">&quot; gradScale=&quot;</span> &lt;&lt; gradScale 
<a name="l01527"></a>01527            &lt;&lt; <span class="stringliteral">&quot; springScale=&quot;</span> &lt;&lt; springScale &lt;&lt; <span class="stringliteral">&quot; avgWeight=&quot;</span> &lt;&lt; avgWeight &lt;&lt; std::endl;
<a name="l01528"></a>01528   <span class="keywordflow">return</span>;
<a name="l01529"></a>01529 }
<a name="l01530"></a>01530 
<a name="l01531"></a>01531 <span class="keywordtype">void</span>
<a name="l01532"></a>01532 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6392c40d838c3a665c2e8f570f8e55cf">QCAD::SaddleValueResponseFunction::</a>
<a name="l01533"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6392c40d838c3a665c2e8f570f8e55cf">01533</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6392c40d838c3a665c2e8f570f8e55cf">computeTangent</a>(std::size_t i, <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; tangent, <span class="keywordtype">int</span> dbMode)
<a name="l01534"></a>01534 {
<a name="l01535"></a>01535   <span class="comment">// Compute tangent vector: use only higher neighboring imagePt.  </span>
<a name="l01536"></a>01536   <span class="comment">//   Linear combination if both neighbors are above/below to smoothly interpolate cases</span>
<a name="l01537"></a>01537   <span class="keywordtype">double</span> dValuePrev = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i-1].value - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].value;
<a name="l01538"></a>01538   <span class="keywordtype">double</span> dValueNext = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].value - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].value;
<a name="l01539"></a>01539 
<a name="l01540"></a>01540   <span class="keywordflow">if</span>(dValuePrev * dValueNext &lt; 0.0) { <span class="comment">//if both neighbors are either above or below current pt</span>
<a name="l01541"></a>01541     <span class="keywordtype">double</span> dmax = std::max( fabs(dValuePrev), fabs(dValueNext) );
<a name="l01542"></a>01542     <span class="keywordtype">double</span> dmin = std::min( fabs(dValuePrev), fabs(dValueNext) );
<a name="l01543"></a>01543     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i-1].value &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].value)
<a name="l01544"></a>01544       tangent = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords) * dmin + (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i-1].coords) * dmax;
<a name="l01545"></a>01545     <span class="keywordflow">else</span>
<a name="l01546"></a>01546       tangent = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords) * dmax + (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i-1].coords) * dmin;
<a name="l01547"></a>01547   }
<a name="l01548"></a>01548   <span class="keywordflow">else</span> {  <span class="comment">//if one neighbor is above, the other below, just use the higher neighbor</span>
<a name="l01549"></a>01549     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].value &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].value)
<a name="l01550"></a>01550       tangent = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords);
<a name="l01551"></a>01551     <span class="keywordflow">else</span>
<a name="l01552"></a>01552       tangent = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i-1].coords);
<a name="l01553"></a>01553   }
<a name="l01554"></a>01554   tangent.<a class="code" href="classQCAD_1_1mathVector.html#a734bb85a062395679b874b9c69e39a9f">normalize</a>();
<a name="l01555"></a>01555   <span class="keywordflow">return</span>;
<a name="l01556"></a>01556 }
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="keywordtype">void</span>
<a name="l01559"></a>01559 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9b7cfe4a5d2300c90a8d2d98a8fa96b2">QCAD::SaddleValueResponseFunction::</a>
<a name="l01560"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9b7cfe4a5d2300c90a8d2d98a8fa96b2">01560</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9b7cfe4a5d2300c90a8d2d98a8fa96b2">computeClimbingForce</a>(std::size_t i, <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; tangent, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; gradScale,
<a name="l01561"></a>01561          <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; force, <span class="keywordtype">int</span> dbMode)
<a name="l01562"></a>01562 {
<a name="l01563"></a>01563   <span class="comment">// Special case for highest point in climbing-NEB: force has full -Grad(V) but with parallel </span>
<a name="l01564"></a>01564   <span class="comment">//    component reversed and no force from springs (Future: add some perp spring force to avoid plateaus?)</span>
<a name="l01565"></a>01565   <span class="keywordtype">double</span> dp = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].grad.dot( tangent );
<a name="l01566"></a>01566   force = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].grad * -1.0 + (tangent*dp) * 2) * gradScale; <span class="comment">// force += -Grad(V) + 2*Grad(V)_parallel</span>
<a name="l01567"></a>01567 
<a name="l01568"></a>01568   <span class="keywordflow">if</span>(dbMode &gt; 2) {
<a name="l01569"></a>01569     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  --   tangent = &quot;</span> &lt;&lt; tangent &lt;&lt; std::endl;
<a name="l01570"></a>01570     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  --   grad along tangent = &quot;</span> &lt;&lt; dp &lt;&lt; std::endl;
<a name="l01571"></a>01571     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  --   total force (climbing) = &quot;</span> &lt;&lt; force[i] &lt;&lt; std::endl;
<a name="l01572"></a>01572   }
<a name="l01573"></a>01573 }
<a name="l01574"></a>01574 
<a name="l01575"></a>01575 <span class="keywordtype">void</span>
<a name="l01576"></a>01576 <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aac8a5fbe0867c0a81d0c6742ac4ded94">QCAD::SaddleValueResponseFunction::</a>
<a name="l01577"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aac8a5fbe0867c0a81d0c6742ac4ded94">01577</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aac8a5fbe0867c0a81d0c6742ac4ded94">computeForce</a>(std::size_t i, <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; tangent, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; springConstants,
<a name="l01578"></a>01578        <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; gradScale,  <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; springScale, <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; force,
<a name="l01579"></a>01579        <span class="keywordtype">double</span>&amp; dt, <span class="keywordtype">double</span>&amp; dt2, <span class="keywordtype">int</span> dbMode)
<a name="l01580"></a>01580 {
<a name="l01581"></a>01581   force.<a class="code" href="classQCAD_1_1mathVector.html#a1bd648d130f88b46ab4aa13ec15a77cb">fill</a>(0.0);
<a name="l01582"></a>01582   
<a name="l01583"></a>01583   <span class="comment">// Get gradient projected perpendicular to the tangent and add to the force</span>
<a name="l01584"></a>01584   <span class="keywordtype">double</span> dp = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].grad.dot( tangent );
<a name="l01585"></a>01585   force -= (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].grad - tangent * dp) * gradScale; <span class="comment">// force += -Grad(V)_perp</span>
<a name="l01586"></a>01586 
<a name="l01587"></a>01587   <span class="keywordflow">if</span>(dbMode &gt; 2) {
<a name="l01588"></a>01588     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  --   tangent = &quot;</span> &lt;&lt; tangent &lt;&lt; std::endl;
<a name="l01589"></a>01589     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  --   grad along tangent = &quot;</span> &lt;&lt; dp &lt;&lt; std::endl;
<a name="l01590"></a>01590     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  --   grad force = &quot;</span> &lt;&lt; force[i] &lt;&lt; std::endl;
<a name="l01591"></a>01591   }
<a name="l01592"></a>01592 
<a name="l01593"></a>01593   <span class="comment">// Get spring force projected parallel to the tangent and add to the force</span>
<a name="l01594"></a>01594   <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> dNext(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>), dPrev(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);
<a name="l01595"></a>01595   <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> parallelSpringForce(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>), perpSpringForce(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);
<a name="l01596"></a>01596   <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> springForce(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>);
<a name="l01597"></a>01597 
<a name="l01598"></a>01598   dPrev = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i-1].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords;
<a name="l01599"></a>01599   dNext = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i+1].coords - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords;
<a name="l01600"></a>01600 
<a name="l01601"></a>01601   <span class="keywordtype">double</span> prevNorm = dPrev.<a class="code" href="classQCAD_1_1mathVector.html#a2dc5bb04ad9b71819e888a2b9df5eada">norm</a>();
<a name="l01602"></a>01602   <span class="keywordtype">double</span> nextNorm = dNext.norm();
<a name="l01603"></a>01603 
<a name="l01604"></a>01604   <span class="keywordtype">double</span> perpFactor = 0.5 * (1 + cos(3.141592 * fabs(dPrev.<a class="code" href="classQCAD_1_1mathVector.html#af1c3abf72cc444e45a5c0ed6752d0921">dot</a>(dNext) / (prevNorm * nextNorm))));
<a name="l01605"></a>01605   springForce = ((dNext * springConstants[i]) + (dPrev * springConstants[i-1]));
<a name="l01606"></a>01606   parallelSpringForce = tangent * springForce.<a class="code" href="classQCAD_1_1mathVector.html#af1c3abf72cc444e45a5c0ed6752d0921">dot</a>(tangent);
<a name="l01607"></a>01607   perpSpringForce = (springForce - tangent * springForce.<a class="code" href="classQCAD_1_1mathVector.html#af1c3abf72cc444e45a5c0ed6752d0921">dot</a>(tangent) );
<a name="l01608"></a>01608   
<a name="l01609"></a>01609   springForce = parallelSpringForce + perpSpringForce * (perpFactor * <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ac54f7aaee83b91ed0f2398fa709d12ec">antiKinkFactor</a>);  
<a name="l01610"></a>01610   <span class="keywordflow">while</span>(springForce.<a class="code" href="classQCAD_1_1mathVector.html#a2dc5bb04ad9b71819e888a2b9df5eada">norm</a>() * dt2 &gt; std::max(dPrev.<a class="code" href="classQCAD_1_1mathVector.html#a2dc5bb04ad9b71819e888a2b9df5eada">norm</a>(),dNext.norm()) &amp;&amp; dt &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9fc297039b153fbaee78d1df7b325a4d">minTimeStep</a>) {
<a name="l01611"></a>01611     dt /= 2; dt2=dt*dt;
<a name="l01612"></a>01612     <span class="keywordflow">if</span>(dbMode &gt; 2) std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  ** Warning: spring forces seem too large: dt =&gt; &quot;</span> &lt;&lt; dt &lt;&lt; std::endl;
<a name="l01613"></a>01613   }
<a name="l01614"></a>01614 
<a name="l01615"></a>01615   force += springForce; <span class="comment">// force += springForce_parallel + part of springForce_perp</span>
<a name="l01616"></a>01616 
<a name="l01617"></a>01617   <span class="keywordflow">if</span>(dbMode &gt; 2) {
<a name="l01618"></a>01618     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  --   spring force = &quot;</span> &lt;&lt; springForce &lt;&lt; std::endl;
<a name="l01619"></a>01619     std::cout &lt;&lt; <span class="stringliteral">&quot;Saddle Point:  --   total force = &quot;</span> &lt;&lt; force[i] &lt;&lt; std::endl;
<a name="l01620"></a>01620   }
<a name="l01621"></a>01621 }
<a name="l01622"></a>01622 
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 
<a name="l01625"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab473c7080583bfd076160835a11c4402">01625</a> std::string <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab473c7080583bfd076160835a11c4402" title="Called by evaluator to interface with class data that persists across worksets.">QCAD::SaddleValueResponseFunction::getMode</a>()
<a name="l01626"></a>01626 {
<a name="l01627"></a>01627   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8f448b8545d73515c1606edbb9a4d664" title="mode of current evaluator operation (maybe not thread safe?)">mode</a>;
<a name="l01628"></a>01628 }
<a name="l01629"></a>01629 
<a name="l01630"></a>01630 
<a name="l01631"></a>01631 <span class="keywordtype">bool</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a08a436782dcee83bdb7e26b768392a43">QCAD::SaddleValueResponseFunction::</a>
<a name="l01632"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a08a436782dcee83bdb7e26b768392a43">01632</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a08a436782dcee83bdb7e26b768392a43">pointIsInImagePtRegion</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* p, <span class="keywordtype">double</span> refZ)<span class="keyword"> const</span>
<a name="l01633"></a>01633 <span class="keyword"></span>{
<a name="l01634"></a>01634   <span class="comment">//assumes at least 2 dimensions</span>
<a name="l01635"></a>01635   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &gt; 2 &amp;&amp; (refZ &lt; zmin || refZ &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a09cf85ec53115a72e0c81b8704046ec5">zmax</a>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01636"></a>01636   <span class="keywordflow">return</span> !(p[0] &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a725f3d8a5f7b0295ce611b6b5e40ab54">xmin</a> || p[1] &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6e44e22641303607543edbcad058a11a">ymin</a> || p[0] &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa141b87b185373c1d4fa2635e039d443">xmax</a> || p[1] &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a67e9de675f85bfbd0898d7e487d1a85b">ymax</a>);
<a name="l01637"></a>01637 }
<a name="l01638"></a>01638 
<a name="l01639"></a>01639 <span class="keywordtype">bool</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a71dda98b35efd2f3e53e372bb9eb3fbd">QCAD::SaddleValueResponseFunction::</a>
<a name="l01640"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a71dda98b35efd2f3e53e372bb9eb3fbd">01640</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a71dda98b35efd2f3e53e372bb9eb3fbd">pointIsInAccumRegion</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* p, <span class="keywordtype">double</span> refZ)<span class="keyword"> const</span>
<a name="l01641"></a>01641 <span class="keyword"></span>{
<a name="l01642"></a>01642   <span class="comment">//assumes at least 2 dimensions</span>
<a name="l01643"></a>01643   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &gt; 2 &amp;&amp; (refZ &lt; zmin || refZ &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a09cf85ec53115a72e0c81b8704046ec5">zmax</a>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01644"></a>01644   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01645"></a>01645 }
<a name="l01646"></a>01646 
<a name="l01647"></a>01647 <span class="keywordtype">bool</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a2e9258715e6b5aa5f0e7c2c8cc7c357f">QCAD::SaddleValueResponseFunction::</a>
<a name="l01648"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a2e9258715e6b5aa5f0e7c2c8cc7c357f">01648</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a2e9258715e6b5aa5f0e7c2c8cc7c357f">pointIsInLevelSetRegion</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* p, <span class="keywordtype">double</span> refZ)<span class="keyword"> const</span>
<a name="l01649"></a>01649 <span class="keyword"></span>{
<a name="l01650"></a>01650   <span class="comment">//assumes at least 2 dimensions</span>
<a name="l01651"></a>01651   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &gt; 2 &amp;&amp; (refZ &lt; zmin || refZ &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a09cf85ec53115a72e0c81b8704046ec5">zmax</a>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01652"></a>01652   <span class="keywordflow">return</span> (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].coords.distanceTo(p) &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a19bd8b4b06d315c750dff8d2a0d3ee15">levelSetRadius</a>);
<a name="l01653"></a>01653 }
<a name="l01654"></a>01654 
<a name="l01655"></a>01655 
<a name="l01656"></a>01656 
<a name="l01657"></a>01657 <span class="keywordtype">void</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a453463e2a515cd962d76b0c05b9caede">QCAD::SaddleValueResponseFunction::</a>
<a name="l01658"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a453463e2a515cd962d76b0c05b9caede">01658</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a453463e2a515cd962d76b0c05b9caede">addBeginPointData</a>(<span class="keyword">const</span> std::string&amp; elementBlock, <span class="keyword">const</span> <span class="keywordtype">double</span>* p, <span class="keywordtype">double</span> value)
<a name="l01659"></a>01659 {
<a name="l01660"></a>01660   <span class="comment">//&quot;Point&quot; case: no need to process anything</span>
<a name="l01661"></a>01661   <span class="keywordflow">if</span>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a92332cbc05e63bcb209b4682dabcd751" title="data for beginning and ending regions">beginRegionType</a> == <span class="stringliteral">&quot;Point&quot;</span> ) <span class="keywordflow">return</span>;
<a name="l01662"></a>01662 
<a name="l01663"></a>01663   <span class="comment">//&quot;Element Block&quot; case: keep track of point with minimum value</span>
<a name="l01664"></a>01664   <span class="keywordflow">if</span>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a92332cbc05e63bcb209b4682dabcd751" title="data for beginning and ending regions">beginRegionType</a> == <span class="stringliteral">&quot;Element Block&quot;</span> ) {
<a name="l01665"></a>01665     <span class="keywordflow">if</span>(elementBlock == <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af4bf80d249a7563bfe291c7dda2f08ab">beginElementBlock</a>) {
<a name="l01666"></a>01666       <span class="keywordflow">if</span>( value &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].value || <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].weight == 0 ) {
<a name="l01667"></a>01667   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].value = value;
<a name="l01668"></a>01668   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].weight = 1.0; <span class="comment">//positive weight flags initialization</span>
<a name="l01669"></a>01669   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords.fill(p);
<a name="l01670"></a>01670       }
<a name="l01671"></a>01671     }
<a name="l01672"></a>01672     <span class="keywordflow">return</span>;
<a name="l01673"></a>01673   }
<a name="l01674"></a>01674 
<a name="l01675"></a>01675   <span class="comment">//&quot;Polygon&quot; case: keep track of point with minimum value</span>
<a name="l01676"></a>01676   <span class="keywordflow">if</span>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a92332cbc05e63bcb209b4682dabcd751" title="data for beginning and ending regions">beginRegionType</a> == <span class="stringliteral">&quot;Polygon&quot;</span> ) {
<a name="l01677"></a>01677     <span class="keywordflow">if</span>( <a class="code" href="namespaceQCAD.html#ac9df0a8006b5ec2519d3f46a3103f687" title="Helper functions.">QCAD::ptInPolygon</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1c056f042b14462cdd409a9c3ba5d805">beginPolygon</a>, p) ) {
<a name="l01678"></a>01678       <span class="keywordflow">if</span>( value &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].value || <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].weight == 0 ) {
<a name="l01679"></a>01679   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].value = value;
<a name="l01680"></a>01680   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].weight = 1.0; <span class="comment">//positive weight flags initialization</span>
<a name="l01681"></a>01681   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[0].coords.fill(p);
<a name="l01682"></a>01682       }
<a name="l01683"></a>01683     }
<a name="l01684"></a>01684     <span class="keywordflow">return</span>;
<a name="l01685"></a>01685   }
<a name="l01686"></a>01686 
<a name="l01687"></a>01687   TEUCHOS_TEST_FOR_EXCEPTION (<span class="keyword">true</span>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l01688"></a>01688       &lt;&lt; <span class="stringliteral">&quot;Invalid region type: &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a92332cbc05e63bcb209b4682dabcd751" title="data for beginning and ending regions">beginRegionType</a> &lt;&lt; <span class="stringliteral">&quot; for begin pt&quot;</span> &lt;&lt; std::endl); 
<a name="l01689"></a>01689   <span class="keywordflow">return</span>;
<a name="l01690"></a>01690 }
<a name="l01691"></a>01691 
<a name="l01692"></a>01692 <span class="keywordtype">void</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad6393e581435726e27585a500446acc6">QCAD::SaddleValueResponseFunction::</a>
<a name="l01693"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad6393e581435726e27585a500446acc6">01693</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad6393e581435726e27585a500446acc6">addEndPointData</a>(<span class="keyword">const</span> std::string&amp; elementBlock, <span class="keyword">const</span> <span class="keywordtype">double</span>* p, <span class="keywordtype">double</span> value)
<a name="l01694"></a>01694 {
<a name="l01695"></a>01695   <span class="comment">//&quot;Point&quot; case: no need to process anything</span>
<a name="l01696"></a>01696   <span class="keywordflow">if</span>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a55bb9c99a5099665866ce146d9c9db2f">endRegionType</a> == <span class="stringliteral">&quot;Point&quot;</span> ) <span class="keywordflow">return</span>;
<a name="l01697"></a>01697 
<a name="l01698"></a>01698   <span class="comment">//&quot;Element Block&quot; case: keep track of point with minimum value</span>
<a name="l01699"></a>01699   <span class="keywordflow">if</span>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a55bb9c99a5099665866ce146d9c9db2f">endRegionType</a> == <span class="stringliteral">&quot;Element Block&quot;</span> ) {
<a name="l01700"></a>01700     <span class="keywordflow">if</span>(elementBlock == <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1a5918863849eba95eaa460cfc0bbe8f">endElementBlock</a>) {
<a name="l01701"></a>01701       <span class="keywordflow">if</span>( value &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].value || <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].weight == 0 ) {
<a name="l01702"></a>01702   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].value = value;
<a name="l01703"></a>01703   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].weight = 1.0; <span class="comment">//positive weight flags initialization</span>
<a name="l01704"></a>01704   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].coords.fill(p);
<a name="l01705"></a>01705       }
<a name="l01706"></a>01706     }
<a name="l01707"></a>01707     <span class="keywordflow">return</span>;
<a name="l01708"></a>01708   }
<a name="l01709"></a>01709 
<a name="l01710"></a>01710   <span class="comment">//&quot;Polygon&quot; case: keep track of point with minimum value</span>
<a name="l01711"></a>01711   <span class="keywordflow">if</span>( <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a55bb9c99a5099665866ce146d9c9db2f">endRegionType</a> == <span class="stringliteral">&quot;Polygon&quot;</span> ) {
<a name="l01712"></a>01712     <span class="keywordflow">if</span>( <a class="code" href="namespaceQCAD.html#ac9df0a8006b5ec2519d3f46a3103f687" title="Helper functions.">QCAD::ptInPolygon</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d7a5d254466509a078a966310a5b498">endPolygon</a>, p) ) {
<a name="l01713"></a>01713       <span class="keywordflow">if</span>( value &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].value || <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].weight == 0 ) {
<a name="l01714"></a>01714   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].value = value;
<a name="l01715"></a>01715   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].weight = 1.0; <span class="comment">//positive weight flags initialization</span>
<a name="l01716"></a>01716   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[nImagePts-1].coords.fill(p);
<a name="l01717"></a>01717       }
<a name="l01718"></a>01718     }
<a name="l01719"></a>01719     <span class="keywordflow">return</span>;
<a name="l01720"></a>01720   }
<a name="l01721"></a>01721 
<a name="l01722"></a>01722   TEUCHOS_TEST_FOR_EXCEPTION (<span class="keyword">true</span>, Teuchos::Exceptions::InvalidParameter, std::endl 
<a name="l01723"></a>01723       &lt;&lt; <span class="stringliteral">&quot;Invalid region type: &quot;</span> &lt;&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a55bb9c99a5099665866ce146d9c9db2f">endRegionType</a> &lt;&lt; <span class="stringliteral">&quot; for end pt&quot;</span> &lt;&lt; std::endl); 
<a name="l01724"></a>01724   <span class="keywordflow">return</span>;
<a name="l01725"></a>01725 }
<a name="l01726"></a>01726 
<a name="l01727"></a>01727 
<a name="l01728"></a>01728 <span class="keywordtype">void</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a18e45351e8f507ccf31aadcbb8d15241">QCAD::SaddleValueResponseFunction::</a>
<a name="l01729"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a18e45351e8f507ccf31aadcbb8d15241">01729</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a18e45351e8f507ccf31aadcbb8d15241">addImagePointData</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* p, <span class="keywordtype">double</span> value, <span class="keywordtype">double</span>* grad)
<a name="l01730"></a>01730 {
<a name="l01731"></a>01731   <span class="keywordtype">double</span> w, effDims = (<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a3dfbfb1de5e7cc235d821b982ae12c13">bLockToPlane</a> &amp;&amp; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a> &gt; 2) ? 2 : <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>;
<a name="l01732"></a>01732   <span class="keywordflow">for</span>(std::size_t i=0; i&lt;nImagePts; i++) {
<a name="l01733"></a>01733     w = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a98388916408aaf1d9ddf46828f7b7b5c" title="function giving distribution of weights for &amp;quot;point&amp;quot;">pointFn</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].coords.distanceTo(p) , <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].radius );
<a name="l01734"></a>01734     <span class="keywordflow">if</span>(w &gt; 0) {
<a name="l01735"></a>01735       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ab59d0d98b3cec0fbab0055e4941d33b5">imagePtWeights</a>[i] += w;
<a name="l01736"></a>01736       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a60d3435342ec9032dd55e4dac1378533" title="accumulation vectors for evaluator to fill">imagePtValues</a>[i] += w*value;
<a name="l01737"></a>01737       <span class="keywordflow">for</span>(std::size_t k=0; k&lt;effDims; k++)
<a name="l01738"></a>01738   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d706bcd0aab5b33aa17e424145b074b">imagePtGradComps</a>[k*nImagePts+i] += w*grad[k];
<a name="l01739"></a>01739       <span class="comment">//std::cout &lt;&lt; &quot;DEBUG Image Pt &quot; &lt;&lt; i &lt;&lt; &quot; close to (&quot; &lt;&lt; p[0] &lt;&lt; &quot;,&quot; &lt;&lt; p[1] &lt;&lt; &quot;,&quot; &lt;&lt; p[2] &lt;&lt; &quot;)=&quot; &lt;&lt; value</span>
<a name="l01740"></a>01740       <span class="comment">//  &lt;&lt; &quot;  wt=&quot; &lt;&lt; w &lt;&lt; &quot;  totalW=&quot; &lt;&lt; imagePtWeights[i] &lt;&lt; &quot;  totalVal=&quot; &lt;&lt; imagePtValues[i]</span>
<a name="l01741"></a>01741       <span class="comment">//  &lt;&lt; &quot;  val=&quot; &lt;&lt; imagePtValues[i] / imagePtWeights[i] &lt;&lt; std::endl;</span>
<a name="l01742"></a>01742     }
<a name="l01743"></a>01743   }
<a name="l01744"></a>01744   <span class="keywordflow">return</span>;
<a name="l01745"></a>01745 }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747 <span class="keywordtype">void</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d1077b6c59512446865c598f344b269">QCAD::SaddleValueResponseFunction::</a>
<a name="l01748"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d1077b6c59512446865c598f344b269">01748</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a8d1077b6c59512446865c598f344b269">addFinalImagePointData</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* p, <span class="keywordtype">double</span> value)
<a name="l01749"></a>01749 {
<a name="l01750"></a>01750   <span class="keywordtype">double</span> w;
<a name="l01751"></a>01751   <span class="keywordflow">for</span>(std::size_t i=0; i&lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>.size(); i++) {
<a name="l01752"></a>01752     w = <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a98388916408aaf1d9ddf46828f7b7b5c" title="function giving distribution of weights for &amp;quot;point&amp;quot;">pointFn</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].coords.distanceTo(p) , <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aeaace46326563841bd1dbe51aea876ae">finalPts</a>[i].radius );
<a name="l01753"></a>01753     <span class="keywordflow">if</span>(w &gt; 0) {
<a name="l01754"></a>01754       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ac7bb0be604afd45a2ae25d352314ee4f">finalPtWeights</a>[i] += w;
<a name="l01755"></a>01755       <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a65cfb1b3cfc628bc78cbb71d45ae85e5">finalPtValues</a>[i] += w*value;
<a name="l01756"></a>01756     }
<a name="l01757"></a>01757   }
<a name="l01758"></a>01758   <span class="keywordflow">return</span>;
<a name="l01759"></a>01759 }
<a name="l01760"></a>01760 
<a name="l01761"></a>01761 <span class="keywordtype">void</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d9857b24a9cd2a535991672f32ea8b6">QCAD::SaddleValueResponseFunction::</a>
<a name="l01762"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d9857b24a9cd2a535991672f32ea8b6">01762</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6d9857b24a9cd2a535991672f32ea8b6">accumulatePointData</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* p, <span class="keywordtype">double</span> value, <span class="keywordtype">double</span>* grad)
<a name="l01763"></a>01763 {
<a name="l01764"></a>01764   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a7f7ef926162ac95e9027e6a761f2dfa6">vFieldValues</a>.push_back(value);
<a name="l01765"></a>01765   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a07d6c1f20454560f5a2d56b2dcc47efc">vCoords</a>.push_back( <a class="code" href="structQCAD_1_1maxDimPt.html">QCAD::maxDimPt</a>(p,<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>) );
<a name="l01766"></a>01766   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#ad2a4803f00148f8a686eb1a163ea8602">vGrads</a>.push_back( <a class="code" href="structQCAD_1_1maxDimPt.html">QCAD::maxDimPt</a>(grad,<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>) );
<a name="l01767"></a>01767 }
<a name="l01768"></a>01768 
<a name="l01769"></a>01769 
<a name="l01770"></a>01770 <span class="keywordtype">void</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a27a9d4ecbc90d25b3d86a7fc9fe7565e">QCAD::SaddleValueResponseFunction::</a>
<a name="l01771"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a27a9d4ecbc90d25b3d86a7fc9fe7565e">01771</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a27a9d4ecbc90d25b3d86a7fc9fe7565e">accumulateLevelSetData</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* p, <span class="keywordtype">double</span> value, <span class="keywordtype">double</span> cellArea)
<a name="l01772"></a>01772 {
<a name="l01773"></a>01773   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a77eeed70b4b7250af29ce4137b60ab94" title="data for level set method">vlsFieldValues</a>.push_back(value);
<a name="l01774"></a>01774   <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#af2c7272a66b5ab84b03908fad7a28690">vlsCellAreas</a>.push_back(cellArea);
<a name="l01775"></a>01775   <span class="keywordflow">for</span>(std::size_t i=0; i &lt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; ++i)
<a name="l01776"></a>01776     <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9a0f97f85f49301a344419b25446c038">vlsCoords</a>[i].push_back(p[i]);
<a name="l01777"></a>01777 }
<a name="l01778"></a>01778  
<a name="l01779"></a>01779 
<a name="l01780"></a>01780 <span class="comment">//Adds and returns the weight of a point relative to the saddle point position.</span>
<a name="l01781"></a>01781 <span class="keywordtype">double</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ef503388d150c37c56be53978f7cc48">QCAD::SaddleValueResponseFunction::</a>
<a name="l01782"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ef503388d150c37c56be53978f7cc48">01782</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ef503388d150c37c56be53978f7cc48">getSaddlePointWeight</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* p)<span class="keyword"> const</span>
<a name="l01783"></a>01783 <span class="keyword"></span>{
<a name="l01784"></a>01784   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a98388916408aaf1d9ddf46828f7b7b5c" title="function giving distribution of weights for &amp;quot;point&amp;quot;">pointFn</a>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].coords.distanceTo(p) , <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].radius );
<a name="l01785"></a>01785 }
<a name="l01786"></a>01786 
<a name="l01787"></a>01787 <span class="keywordtype">double</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa108633408e906acf750acd5895cade7">QCAD::SaddleValueResponseFunction::</a>
<a name="l01788"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa108633408e906acf750acd5895cade7">01788</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa108633408e906acf750acd5895cade7">getTotalSaddlePointWeight</a>()<span class="keyword"> const</span>
<a name="l01789"></a>01789 <span class="keyword"></span>{
<a name="l01790"></a>01790   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].weight;
<a name="l01791"></a>01791 }
<a name="l01792"></a>01792 
<a name="l01793"></a>01793 <span class="keyword">const</span> <span class="keywordtype">double</span>* <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1094e9b6a5a25ffc6c2cb8643cc4431a">QCAD::SaddleValueResponseFunction::</a>
<a name="l01794"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1094e9b6a5a25ffc6c2cb8643cc4431a">01794</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1094e9b6a5a25ffc6c2cb8643cc4431a">getSaddlePointPosition</a>()<span class="keyword"> const</span>
<a name="l01795"></a>01795 <span class="keyword"></span>{
<a name="l01796"></a>01796   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].coords.data();
<a name="l01797"></a>01797 }
<a name="l01798"></a>01798 
<a name="l01799"></a>01799 <span class="keywordtype">bool</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6fa86918fe3859e2f74c71d12b9517a8">QCAD::SaddleValueResponseFunction::</a>
<a name="l01800"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6fa86918fe3859e2f74c71d12b9517a8">01800</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a6fa86918fe3859e2f74c71d12b9517a8">matchesCurrentResults</a>(Epetra_Vector&amp; g)<span class="keyword"> const</span>
<a name="l01801"></a>01801 <span class="keyword"></span>{
<a name="l01802"></a>01802   <span class="keyword">const</span> <span class="keywordtype">double</span> TOL = 1e-8;
<a name="l01803"></a>01803 
<a name="l01804"></a>01804   <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a> &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01805"></a>01805 
<a name="l01806"></a>01806   <span class="keywordflow">if</span>( fabs(g[0] - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#aa92848b0ec3bc572a589cb7fdf009f4c">returnFieldVal</a>) &gt; TOL || fabs(g[1] - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].value) &gt; TOL)
<a name="l01807"></a>01807     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01808"></a>01808 
<a name="l01809"></a>01809   <span class="keywordflow">for</span>(std::size_t i=0; i&lt;<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#afa5b11a927c52a1ce7308fd5e2ebe2a7" title="data used across worksets and processors in saddle point algorithm">numDims</a>; i++) {
<a name="l01810"></a>01810     <span class="keywordflow">if</span>(  fabs(g[2+i] - <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a5b17eccef67d952738c195e42cfaf68f">iSaddlePt</a>].coords[i]) &gt; TOL ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01811"></a>01811   }
<a name="l01812"></a>01812 
<a name="l01813"></a>01813   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01814"></a>01814 }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 
<a name="l01817"></a>01817 <span class="keywordtype">double</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a98388916408aaf1d9ddf46828f7b7b5c" title="function giving distribution of weights for &amp;quot;point&amp;quot;">QCAD::SaddleValueResponseFunction::</a>
<a name="l01818"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a98388916408aaf1d9ddf46828f7b7b5c">01818</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a98388916408aaf1d9ddf46828f7b7b5c" title="function giving distribution of weights for &amp;quot;point&amp;quot;">pointFn</a>(<span class="keywordtype">double</span> d, <span class="keywordtype">double</span> <a class="code" href="Interface_8cpp.html#a3f67c53b80389c5f53961936edba04c9">radius</a>)<span class="keyword"> const </span>{
<a name="l01819"></a>01819   <span class="comment">//return ( d &lt; radius ) ? 1.0 : 0.0;  //alternative?</span>
<a name="l01820"></a>01820 
<a name="l01821"></a>01821   <span class="keyword">const</span> <span class="keywordtype">double</span> N = 1.0;
<a name="l01822"></a>01822   <span class="keywordtype">double</span> val = N*exp(-d*d / (2*radius*radius));
<a name="l01823"></a>01823   <span class="keywordflow">return</span> (val &gt;= 1e-2) ? val : 0.0;
<a name="l01824"></a>01824 }
<a name="l01825"></a>01825 
<a name="l01826"></a>01826 <span class="keywordtype">int</span> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1eeac704fd65f0835c39ba49668ae704" title="helper function to get the highest image point (the one with the largest value)">QCAD::SaddleValueResponseFunction::</a>
<a name="l01827"></a><a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1eeac704fd65f0835c39ba49668ae704">01827</a> <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a1eeac704fd65f0835c39ba49668ae704" title="helper function to get the highest image point (the one with the largest value)">getHighestPtIndex</a>()<span class="keyword"> const </span>
<a name="l01828"></a>01828 <span class="keyword"></span>{
<a name="l01829"></a>01829   <span class="comment">// Find the highest image point </span>
<a name="l01830"></a>01830   <span class="keywordtype">int</span> iHighestPt = 0; <span class="comment">// init to the first point being the highest</span>
<a name="l01831"></a>01831   <span class="keywordflow">for</span>(std::size_t i=1; i&lt;nImagePts; i++) {
<a name="l01832"></a>01832     <span class="keywordflow">if</span>(<a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[i].value &gt; <a class="code" href="classQCAD_1_1SaddleValueResponseFunction.html#a9ebd474eaf6d4db694f2c13afd782920">imagePts</a>[iHighestPt].value) iHighestPt = i;
<a name="l01833"></a>01833   }
<a name="l01834"></a>01834   <span class="keywordflow">return</span> iHighestPt;
<a name="l01835"></a>01835 }
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 
<a name="l01838"></a>01838 
<a name="l01839"></a>01839 <span class="comment">/*************************************************************/</span>
<a name="l01841"></a>01841 <span class="comment">/*************************************************************/</span>
<a name="l01842"></a>01842 
<a name="l01843"></a>01843 <span class="comment">/*double distanceFromLineSegment(const double* p, const double* p1, const double* p2, int dims)</span>
<a name="l01844"></a>01844 <span class="comment">{</span>
<a name="l01845"></a>01845 <span class="comment">  //get pt c, the point along the full line p1-&gt;p2 closest to p</span>
<a name="l01846"></a>01846 <span class="comment">  double s, dp = 0, mag2 = 0; </span>
<a name="l01847"></a>01847 <span class="comment"></span>
<a name="l01848"></a>01848 <span class="comment">  for(int k=0; k&lt;dims; k++) mag2 += pow(p2[k]-p1[k],2);</span>
<a name="l01849"></a>01849 <span class="comment">  for(int k=0; k&lt;dims; k++) dp += (p[k]-p1[k])*(p2[k]-p1[k]);</span>
<a name="l01850"></a>01850 <span class="comment">  s = dp / sqrt(mag2); // &lt; 0 or &gt; 1 if c is outside segment, 0 &lt;= s &lt;= 1 if c is on segment</span>
<a name="l01851"></a>01851 <span class="comment"></span>
<a name="l01852"></a>01852 <span class="comment">  if(0 &lt;= s &amp;&amp; s &lt;= 1) { //just return distance between c and p</span>
<a name="l01853"></a>01853 <span class="comment">    double cp = 0;</span>
<a name="l01854"></a>01854 <span class="comment">    for(int k=0; k&lt;dims; k++) cp += pow(p[k] - (p1[k]+s*(p2[k]-p1[k])),2);</span>
<a name="l01855"></a>01855 <span class="comment">    return sqrt(cp);</span>
<a name="l01856"></a>01856 <span class="comment">  }</span>
<a name="l01857"></a>01857 <span class="comment">  else { //take closer distance from the endpoints</span>
<a name="l01858"></a>01858 <span class="comment">    double d1=0, d2=0;</span>
<a name="l01859"></a>01859 <span class="comment">    for(int k=0; k&lt;dims; k++) d1 += pow(p[k]-p1[k],2);</span>
<a name="l01860"></a>01860 <span class="comment">    for(int k=0; k&lt;dims; k++) d2 += pow(p[k]-p2[k],2);</span>
<a name="l01861"></a>01861 <span class="comment">    if(d1 &lt; d2) return sqrt(d1);</span>
<a name="l01862"></a>01862 <span class="comment">    else return sqrt(d2);</span>
<a name="l01863"></a>01863 <span class="comment">  }</span>
<a name="l01864"></a>01864 <span class="comment">  }*/</span>
<a name="l01865"></a>01865 
<a name="l01866"></a>01866 <span class="comment">// Returns true if point is inside polygon, false otherwise</span>
<a name="l01867"></a>01867 <span class="comment">//  Assumes 2D points (more dims ok, but uses only first two components)</span>
<a name="l01868"></a>01868 <span class="comment">//  Algorithm = ray trace along positive x-axis</span>
<a name="l01869"></a><a class="code" href="namespaceQCAD.html#ac9df0a8006b5ec2519d3f46a3103f687">01869</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceQCAD.html#ac9df0a8006b5ec2519d3f46a3103f687" title="Helper functions.">QCAD::ptInPolygon</a>(<span class="keyword">const</span> std::vector&lt;QCAD::mathVector&gt;&amp; polygon, <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; pt) 
<a name="l01870"></a>01870 {
<a name="l01871"></a>01871   <span class="keywordflow">return</span> <a class="code" href="namespaceQCAD.html#ac9df0a8006b5ec2519d3f46a3103f687" title="Helper functions.">QCAD::ptInPolygon</a>(polygon, pt.<a class="code" href="classQCAD_1_1mathVector.html#a730d5d6b8e52f9f8ad628041e9efd74d">data</a>());
<a name="l01872"></a>01872 }
<a name="l01873"></a>01873 
<a name="l01874"></a><a class="code" href="namespaceQCAD.html#ad4553bf785d2cf45801bfaa82f703614">01874</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceQCAD.html#ac9df0a8006b5ec2519d3f46a3103f687" title="Helper functions.">QCAD::ptInPolygon</a>(<span class="keyword">const</span> std::vector&lt;QCAD::mathVector&gt;&amp; polygon, <span class="keyword">const</span> <span class="keywordtype">double</span>* pt)
<a name="l01875"></a>01875 {
<a name="l01876"></a>01876   <span class="keywordtype">bool</span> c = <span class="keyword">false</span>;
<a name="l01877"></a>01877   <span class="keywordtype">int</span> <a class="code" href="MOR__ExtendedEpetraLapack_8cpp.html#af5da5165aa5eeff113accece5748c995">n</a> = (int)polygon.size();
<a name="l01878"></a>01878   <span class="keywordtype">double</span> x=pt[0], y=pt[1];
<a name="l01879"></a>01879   <span class="keyword">const</span> <span class="keywordtype">int</span> X=0,Y=1;
<a name="l01880"></a>01880 
<a name="l01881"></a>01881   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, j = n-1; i &lt; n; j = i++) {
<a name="l01882"></a>01882     <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; <a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a> = polygon[i];
<a name="l01883"></a>01883     <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; pj = polygon[j];
<a name="l01884"></a>01884     <span class="keywordflow">if</span> ((((pi[Y] &lt;= y) &amp;&amp; (y &lt; pj[Y])) ||
<a name="l01885"></a>01885    ((pj[Y] &lt;= y) &amp;&amp; (y &lt; pi[Y]))) &amp;&amp;
<a name="l01886"></a>01886   (x &lt; (pj[X] - pi[X]) * (y - pi[Y]) / (pj[Y] - pi[Y]) + pi[X]))
<a name="l01887"></a>01887       c = !c;
<a name="l01888"></a>01888   }
<a name="l01889"></a>01889   <span class="keywordflow">return</span> c;
<a name="l01890"></a>01890 }
<a name="l01891"></a>01891 
<a name="l01892"></a>01892 
<a name="l01893"></a>01893 <span class="comment">//Not used - but keep for reference</span>
<a name="l01894"></a>01894 <span class="comment">// Returns true if point is inside polygon, false otherwise</span>
<a name="l01895"></a>01895 <span class="comment">/*bool orig_ptInPolygon(int npol, float *xp, float *yp, float x, float y)</span>
<a name="l01896"></a>01896 <span class="comment">{</span>
<a name="l01897"></a>01897 <span class="comment">  int i, j; bool c = false;</span>
<a name="l01898"></a>01898 <span class="comment">  for (i = 0, j = npol-1; i &lt; npol; j = i++) {</span>
<a name="l01899"></a>01899 <span class="comment">    if ((((yp[i] &lt;= y) &amp;&amp; (y &lt; yp[j])) ||</span>
<a name="l01900"></a>01900 <span class="comment">   ((yp[j] &lt;= y) &amp;&amp; (y &lt; yp[i]))) &amp;&amp;</span>
<a name="l01901"></a>01901 <span class="comment">  (x &lt; (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))</span>
<a name="l01902"></a>01902 <span class="comment">      c = !c;</span>
<a name="l01903"></a>01903 <span class="comment">  }</span>
<a name="l01904"></a>01904 <span class="comment">  return c;</span>
<a name="l01905"></a>01905 <span class="comment">}*/</span>
<a name="l01906"></a>01906 
<a name="l01907"></a>01907 
<a name="l01908"></a>01908 
<a name="l01909"></a>01909 
<a name="l01910"></a>01910 
<a name="l01911"></a>01911 
<a name="l01912"></a>01912 
<a name="l01913"></a>01913 <span class="comment">/*************************************************************/</span>
<a name="l01915"></a>01915 <span class="comment">/*************************************************************/</span>
<a name="l01916"></a>01916 
<a name="l01917"></a><a class="code" href="classQCAD_1_1mathVector.html#a087d358b3c21fd70af57d6b8f057e197">01917</a> <a class="code" href="classQCAD_1_1mathVector.html#a087d358b3c21fd70af57d6b8f057e197" title="mathVector class: a vector with math operations (helper class)">QCAD::mathVector::mathVector</a>() 
<a name="l01918"></a>01918 {
<a name="l01919"></a>01919   <a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a> = -1;
<a name="l01920"></a>01920 }
<a name="l01921"></a>01921 
<a name="l01922"></a><a class="code" href="classQCAD_1_1mathVector.html#a352bfb573e933397bca81581e4a2af8c">01922</a> <a class="code" href="classQCAD_1_1mathVector.html#a087d358b3c21fd70af57d6b8f057e197" title="mathVector class: a vector with math operations (helper class)">QCAD::mathVector::mathVector</a>(<span class="keywordtype">int</span> <a class="code" href="MOR__ExtendedEpetraLapack_8cpp.html#af5da5165aa5eeff113accece5748c995">n</a>) 
<a name="l01923"></a>01923  :data_(n) 
<a name="l01924"></a>01924 { 
<a name="l01925"></a>01925   <a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a> = n;
<a name="l01926"></a>01926 }
<a name="l01927"></a>01927 
<a name="l01928"></a>01928 
<a name="l01929"></a><a class="code" href="classQCAD_1_1mathVector.html#a04779767bdc253176cd672a4613443fc">01929</a> <a class="code" href="classQCAD_1_1mathVector.html#a087d358b3c21fd70af57d6b8f057e197" title="mathVector class: a vector with math operations (helper class)">QCAD::mathVector::mathVector</a>(<span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; copy) 
<a name="l01930"></a>01930 { 
<a name="l01931"></a>01931   <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a> = copy.<a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>;
<a name="l01932"></a>01932   <a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a> = copy.<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>;
<a name="l01933"></a>01933 }
<a name="l01934"></a>01934 
<a name="l01935"></a><a class="code" href="classQCAD_1_1mathVector.html#ad3bcd28a99b1555fc3861dbd88cb7158">01935</a> <a class="code" href="classQCAD_1_1mathVector.html#ad3bcd28a99b1555fc3861dbd88cb7158">QCAD::mathVector::~mathVector</a>() 
<a name="l01936"></a>01936 {
<a name="l01937"></a>01937 }
<a name="l01938"></a>01938 
<a name="l01939"></a>01939 
<a name="l01940"></a>01940 <span class="keywordtype">void</span> 
<a name="l01941"></a><a class="code" href="classQCAD_1_1mathVector.html#adea02471efe6c010c0ef58801b437de1">01941</a> <a class="code" href="classQCAD_1_1mathVector.html#adea02471efe6c010c0ef58801b437de1">QCAD::mathVector::resize</a>(std::size_t <a class="code" href="MOR__ExtendedEpetraLapack_8cpp.html#af5da5165aa5eeff113accece5748c995">n</a>) 
<a name="l01942"></a>01942 { 
<a name="l01943"></a>01943   <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>.resize(n); 
<a name="l01944"></a>01944   <a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a> = n;
<a name="l01945"></a>01945 }
<a name="l01946"></a>01946 
<a name="l01947"></a>01947 <span class="keywordtype">void</span> 
<a name="l01948"></a><a class="code" href="classQCAD_1_1mathVector.html#a1bd648d130f88b46ab4aa13ec15a77cb">01948</a> <a class="code" href="classQCAD_1_1mathVector.html#a1bd648d130f88b46ab4aa13ec15a77cb">QCAD::mathVector::fill</a>(<span class="keywordtype">double</span> d) 
<a name="l01949"></a>01949 { 
<a name="l01950"></a>01950   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i] = d;
<a name="l01951"></a>01951 }
<a name="l01952"></a>01952 
<a name="l01953"></a>01953 <span class="keywordtype">void</span> 
<a name="l01954"></a><a class="code" href="classQCAD_1_1mathVector.html#af6ccf6c70ab95848b13325eaaa17d693">01954</a> <a class="code" href="classQCAD_1_1mathVector.html#a1bd648d130f88b46ab4aa13ec15a77cb">QCAD::mathVector::fill</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* vec) 
<a name="l01955"></a>01955 { 
<a name="l01956"></a>01956   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i] = vec[i];
<a name="l01957"></a>01957 }
<a name="l01958"></a>01958 
<a name="l01959"></a>01959 <span class="keywordtype">double</span> 
<a name="l01960"></a><a class="code" href="classQCAD_1_1mathVector.html#af1c3abf72cc444e45a5c0ed6752d0921">01960</a> <a class="code" href="AAdapt__STKUnifSizeField_8cpp.html#aeb773ac1ea10e7543bbc142b40cf00aa">QCAD::mathVector::dot</a>(<span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; v2)<span class="keyword"> const</span>
<a name="l01961"></a>01961 <span class="keyword"></span>{
<a name="l01962"></a>01962   <span class="keywordtype">double</span> d=0;
<a name="l01963"></a>01963   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++)
<a name="l01964"></a>01964     d += <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i] * v2[i];
<a name="l01965"></a>01965   <span class="keywordflow">return</span> d;
<a name="l01966"></a>01966 }
<a name="l01967"></a>01967 
<a name="l01968"></a>01968 <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; 
<a name="l01969"></a><a class="code" href="classQCAD_1_1mathVector.html#a583cacfec3a702c6bb812be6a60c6156">01969</a> <a class="code" href="classQCAD_1_1mathVector.html#a583cacfec3a702c6bb812be6a60c6156">QCAD::mathVector::operator=</a>(<span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; rhs)
<a name="l01970"></a>01970 {
<a name="l01971"></a>01971   <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a> = rhs.<a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>;
<a name="l01972"></a>01972   <a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a> = rhs.<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>;
<a name="l01973"></a>01973   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01974"></a>01974 }
<a name="l01975"></a>01975 
<a name="l01976"></a>01976 <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a> 
<a name="l01977"></a><a class="code" href="classQCAD_1_1mathVector.html#af712dfd9cac2188772ae8e773316571f">01977</a> <a class="code" href="classQCAD_1_1mathVector.html#af712dfd9cac2188772ae8e773316571f">QCAD::mathVector::operator+</a>(<span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; v2)<span class="keyword"> const</span>
<a name="l01978"></a>01978 <span class="keyword"></span>{
<a name="l01979"></a>01979   <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> result(<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>);
<a name="l01980"></a>01980   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) result[i] = <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i] + v2[i];
<a name="l01981"></a>01981   <span class="keywordflow">return</span> result;
<a name="l01982"></a>01982 }
<a name="l01983"></a>01983 
<a name="l01984"></a>01984 <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a> 
<a name="l01985"></a><a class="code" href="classQCAD_1_1mathVector.html#a2111280aa359d89541c41b7752ef5fec">01985</a> <a class="code" href="classQCAD_1_1mathVector.html#a2111280aa359d89541c41b7752ef5fec">QCAD::mathVector::operator-</a>(<span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; v2)<span class="keyword"> const</span>
<a name="l01986"></a>01986 <span class="keyword"></span>{
<a name="l01987"></a>01987   <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> result(<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>);
<a name="l01988"></a>01988   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) result[i] = <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i] - v2[i];
<a name="l01989"></a>01989   <span class="keywordflow">return</span> result;
<a name="l01990"></a>01990 }
<a name="l01991"></a>01991 
<a name="l01992"></a>01992 <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>
<a name="l01993"></a><a class="code" href="classQCAD_1_1mathVector.html#a2f3af6f61a1eee99e96fc7a5e1b77f80">01993</a> <a class="code" href="classQCAD_1_1mathVector.html#a2f3af6f61a1eee99e96fc7a5e1b77f80">QCAD::mathVector::operator*</a>(<span class="keywordtype">double</span> scale)<span class="keyword"> const </span>
<a name="l01994"></a>01994 <span class="keyword"></span>{
<a name="l01995"></a>01995   <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a> result(<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>);
<a name="l01996"></a>01996   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) result[i] = scale*<a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i];
<a name="l01997"></a>01997   <span class="keywordflow">return</span> result;
<a name="l01998"></a>01998 }
<a name="l01999"></a>01999 
<a name="l02000"></a>02000 <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; 
<a name="l02001"></a><a class="code" href="classQCAD_1_1mathVector.html#a49d8cca98a3683258fdd55791e88eabf">02001</a> <a class="code" href="classQCAD_1_1mathVector.html#a49d8cca98a3683258fdd55791e88eabf">QCAD::mathVector::operator+=</a>(<span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; v2)
<a name="l02002"></a>02002 {
<a name="l02003"></a>02003   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i] += v2[i];
<a name="l02004"></a>02004   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02005"></a>02005 }
<a name="l02006"></a>02006 
<a name="l02007"></a>02007 <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; 
<a name="l02008"></a><a class="code" href="classQCAD_1_1mathVector.html#a5bcabe39f0c94916b75e0afcf4ad0102">02008</a> <a class="code" href="classQCAD_1_1mathVector.html#a5bcabe39f0c94916b75e0afcf4ad0102">QCAD::mathVector::operator-=</a>(<span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; v2) 
<a name="l02009"></a>02009 {
<a name="l02010"></a>02010   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i] -= v2[i];
<a name="l02011"></a>02011   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02012"></a>02012 }
<a name="l02013"></a>02013 
<a name="l02014"></a>02014 <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; 
<a name="l02015"></a><a class="code" href="classQCAD_1_1mathVector.html#a8e878a4cdb6a26694cf01fe5dd5b7db8">02015</a> <a class="code" href="classQCAD_1_1mathVector.html#a8e878a4cdb6a26694cf01fe5dd5b7db8">QCAD::mathVector::operator*=</a>(<span class="keywordtype">double</span> scale) 
<a name="l02016"></a>02016 {
<a name="l02017"></a>02017   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i] *= scale;
<a name="l02018"></a>02018   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02019"></a>02019 }
<a name="l02020"></a>02020 
<a name="l02021"></a>02021 <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp;
<a name="l02022"></a><a class="code" href="classQCAD_1_1mathVector.html#ac9950e56c56d07edb1b0395478b5548f">02022</a> <a class="code" href="classQCAD_1_1mathVector.html#ac9950e56c56d07edb1b0395478b5548f">QCAD::mathVector::operator/=</a>(<span class="keywordtype">double</span> scale) 
<a name="l02023"></a>02023 {
<a name="l02024"></a>02024   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i] /= scale;
<a name="l02025"></a>02025   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02026"></a>02026 }
<a name="l02027"></a>02027 
<a name="l02028"></a>02028 <span class="keywordtype">double</span>&amp;
<a name="l02029"></a><a class="code" href="classQCAD_1_1mathVector.html#a5ebcaea67f487b322fd4cf7d66f4ed54">02029</a> <a class="code" href="classQCAD_1_1mathVector.html#a5ebcaea67f487b322fd4cf7d66f4ed54">QCAD::mathVector::operator[]</a>(<span class="keywordtype">int</span> i) 
<a name="l02030"></a>02030 { 
<a name="l02031"></a>02031   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i];
<a name="l02032"></a>02032 }
<a name="l02033"></a>02033 
<a name="l02034"></a>02034 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; 
<a name="l02035"></a><a class="code" href="classQCAD_1_1mathVector.html#a33f90c1ff457b9f31fe4194f66feeb71">02035</a> <a class="code" href="classQCAD_1_1mathVector.html#a5ebcaea67f487b322fd4cf7d66f4ed54">QCAD::mathVector::operator[]</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>
<a name="l02036"></a>02036 <span class="keyword"></span>{ 
<a name="l02037"></a>02037   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i];
<a name="l02038"></a>02038 }
<a name="l02039"></a>02039 
<a name="l02040"></a>02040 <span class="keywordtype">double</span> 
<a name="l02041"></a><a class="code" href="classQCAD_1_1mathVector.html#a2a1cfe47ce9d7559688d87bc5e1c7660">02041</a> <a class="code" href="classQCAD_1_1mathVector.html#a2a1cfe47ce9d7559688d87bc5e1c7660">QCAD::mathVector::distanceTo</a>(<span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">mathVector</a>&amp; v2)<span class="keyword"> const</span>
<a name="l02042"></a>02042 <span class="keyword"></span>{
<a name="l02043"></a>02043   <span class="keywordtype">double</span> d = 0.0;
<a name="l02044"></a>02044   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) d += pow(<a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i]-v2[i],2);
<a name="l02045"></a>02045   <span class="keywordflow">return</span> sqrt(d);
<a name="l02046"></a>02046 }
<a name="l02047"></a>02047 
<a name="l02048"></a>02048 <span class="keywordtype">double</span> 
<a name="l02049"></a><a class="code" href="classQCAD_1_1mathVector.html#a324a9feb3bea3cec2db8212f7988830f">02049</a> <a class="code" href="classQCAD_1_1mathVector.html#a2a1cfe47ce9d7559688d87bc5e1c7660">QCAD::mathVector::distanceTo</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* p)<span class="keyword"> const</span>
<a name="l02050"></a>02050 <span class="keyword"></span>{
<a name="l02051"></a>02051   <span class="keywordtype">double</span> d = 0.0;
<a name="l02052"></a>02052   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; i++) d += pow(<a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>[i]-p[i],2);
<a name="l02053"></a>02053   <span class="keywordflow">return</span> sqrt(d);
<a name="l02054"></a>02054 }
<a name="l02055"></a>02055          
<a name="l02056"></a>02056 <span class="keywordtype">double</span> 
<a name="l02057"></a><a class="code" href="classQCAD_1_1mathVector.html#a2dc5bb04ad9b71819e888a2b9df5eada">02057</a> <a class="code" href="classQCAD_1_1mathVector.html#a2dc5bb04ad9b71819e888a2b9df5eada">QCAD::mathVector::norm</a>()<span class="keyword"> const</span>
<a name="l02058"></a>02058 <span class="keyword"></span>{ 
<a name="l02059"></a>02059   <span class="keywordflow">return</span> sqrt(<a class="code" href="classQCAD_1_1mathVector.html#af1c3abf72cc444e45a5c0ed6752d0921">dot</a>(*<span class="keyword">this</span>)); 
<a name="l02060"></a>02060 }
<a name="l02061"></a>02061 
<a name="l02062"></a>02062 <span class="keywordtype">double</span> 
<a name="l02063"></a><a class="code" href="classQCAD_1_1mathVector.html#ab3dd253abe76b6dfdd7972d395d70b69">02063</a> <a class="code" href="classQCAD_1_1mathVector.html#ab3dd253abe76b6dfdd7972d395d70b69">QCAD::mathVector::norm2</a>()<span class="keyword"> const</span>
<a name="l02064"></a>02064 <span class="keyword"></span>{ 
<a name="l02065"></a>02065   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1mathVector.html#af1c3abf72cc444e45a5c0ed6752d0921">dot</a>(*<span class="keyword">this</span>); 
<a name="l02066"></a>02066 }
<a name="l02067"></a>02067 
<a name="l02068"></a>02068 
<a name="l02069"></a>02069 <span class="keywordtype">void</span> 
<a name="l02070"></a><a class="code" href="classQCAD_1_1mathVector.html#a734bb85a062395679b874b9c69e39a9f">02070</a> <a class="code" href="AAdapt__STKUnifSizeField_8cpp.html#a68219ca6129e9dea9b3365d4fa9e719a">QCAD::mathVector::normalize</a>() 
<a name="l02071"></a>02071 {
<a name="l02072"></a>02072   (*this) /= <a class="code" href="classQCAD_1_1mathVector.html#a2dc5bb04ad9b71819e888a2b9df5eada">norm</a>(); 
<a name="l02073"></a>02073 }
<a name="l02074"></a>02074 
<a name="l02075"></a>02075 <span class="keyword">const</span> <span class="keywordtype">double</span>* 
<a name="l02076"></a><a class="code" href="classQCAD_1_1mathVector.html#ae568c4380faa9b3d789fc0683bc4b786">02076</a> <a class="code" href="classQCAD_1_1mathVector.html#a730d5d6b8e52f9f8ad628041e9efd74d">QCAD::mathVector::data</a>()<span class="keyword"> const</span>
<a name="l02077"></a>02077 <span class="keyword"></span>{ 
<a name="l02078"></a>02078   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>.data();
<a name="l02079"></a>02079 }
<a name="l02080"></a>02080 
<a name="l02081"></a>02081 <span class="keywordtype">double</span>* 
<a name="l02082"></a><a class="code" href="classQCAD_1_1mathVector.html#a730d5d6b8e52f9f8ad628041e9efd74d">02082</a> <a class="code" href="classQCAD_1_1mathVector.html#a730d5d6b8e52f9f8ad628041e9efd74d">QCAD::mathVector::data</a>()
<a name="l02083"></a>02083 { 
<a name="l02084"></a>02084   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1mathVector.html#aac935377b053c623ff278ffceac9cdfa">data_</a>.data();
<a name="l02085"></a>02085 }
<a name="l02086"></a>02086 
<a name="l02087"></a>02087 
<a name="l02088"></a>02088 std::size_t 
<a name="l02089"></a><a class="code" href="classQCAD_1_1mathVector.html#adc3e09d617642eb281a0980cca877ccb">02089</a> <a class="code" href="classQCAD_1_1mathVector.html#adc3e09d617642eb281a0980cca877ccb">QCAD::mathVector::size</a>()<span class="keyword"> const</span>
<a name="l02090"></a>02090 <span class="keyword"></span>{
<a name="l02091"></a>02091   <span class="keywordflow">return</span> <a class="code" href="classQCAD_1_1mathVector.html#a2240469524ac00ff2dc7056b92053194">dim_</a>; 
<a name="l02092"></a>02092 }
<a name="l02093"></a>02093 
<a name="l02094"></a><a class="code" href="namespaceQCAD.html#a9f60f37fd458154ebfec6bd2e47fdf5b">02094</a> std::ostream&amp; <a class="code" href="namespaceQCAD.html#a9f60f37fd458154ebfec6bd2e47fdf5b">QCAD::operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code" href="classQCAD_1_1mathVector.html">QCAD::mathVector</a>&amp; mv) 
<a name="l02095"></a>02095 {
<a name="l02096"></a>02096   std::size_t size = mv.<a class="code" href="classQCAD_1_1mathVector.html#adc3e09d617642eb281a0980cca877ccb">size</a>();
<a name="l02097"></a>02097   os &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;
<a name="l02098"></a>02098   <span class="keywordflow">for</span>(std::size_t i=0; i&lt;size-1; i++) os &lt;&lt; mv[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l02099"></a>02099   <span class="keywordflow">if</span>(size &gt; 0) os &lt;&lt; mv[size-1];
<a name="l02100"></a>02100   os &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
<a name="l02101"></a>02101   <span class="keywordflow">return</span> os;
<a name="l02102"></a>02102 }
<a name="l02103"></a>02103 
<a name="l02104"></a><a class="code" href="namespaceQCAD.html#ab88d744e97cea3826784788a96535872">02104</a> std::ostream&amp; <a class="code" href="namespaceQCAD.html#a9f60f37fd458154ebfec6bd2e47fdf5b">QCAD::operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code" href="structQCAD_1_1nebImagePt.html">QCAD::nebImagePt</a>&amp; np)
<a name="l02105"></a>02105 {
<a name="l02106"></a>02106   os &lt;&lt; std::endl;
<a name="l02107"></a>02107   os &lt;&lt; <span class="stringliteral">&quot;coords = &quot;</span> &lt;&lt; np.<a class="code" href="structQCAD_1_1nebImagePt.html#ab9eac774b25fb5a74a71096ead60c69f">coords</a> &lt;&lt; std::endl;
<a name="l02108"></a>02108   os &lt;&lt; <span class="stringliteral">&quot;veloc  = &quot;</span> &lt;&lt; np.<a class="code" href="structQCAD_1_1nebImagePt.html#a6aced77f2e55872e7e2a9df93a289adc">velocity</a> &lt;&lt; std::endl;
<a name="l02109"></a>02109   os &lt;&lt; <span class="stringliteral">&quot;grad   = &quot;</span> &lt;&lt; np.<a class="code" href="structQCAD_1_1nebImagePt.html#a0a121dd2994a197b454a473cc0af2a8c">grad</a> &lt;&lt; std::endl;
<a name="l02110"></a>02110   os &lt;&lt; <span class="stringliteral">&quot;value  = &quot;</span> &lt;&lt; np.<a class="code" href="structQCAD_1_1nebImagePt.html#a6b3644c991a32b029043076ec6496917">value</a> &lt;&lt; std::endl;
<a name="l02111"></a>02111   os &lt;&lt; <span class="stringliteral">&quot;weight = &quot;</span> &lt;&lt; np.<a class="code" href="structQCAD_1_1nebImagePt.html#a85958a6f75a54646366ee413e21b2a0b">weight</a> &lt;&lt; std::endl;
<a name="l02112"></a>02112   <span class="keywordflow">return</span> os;
<a name="l02113"></a>02113 }
<a name="l02114"></a>02114 
<a name="l02115"></a>02115 
<a name="l02116"></a>02116 
<a name="l02117"></a>02117 <span class="comment">/*************************************************************/</span>
<a name="l02119"></a>02119 <span class="comment">/*************************************************************/</span>
<a name="l02120"></a>02120 
<a name="l02121"></a><a class="code" href="namespaceQCAD.html#a985bf075550ffc548624607851d93d1e">02121</a> <span class="keywordtype">void</span> <a class="code" href="namespaceQCAD.html#a985bf075550ffc548624607851d93d1e" title="Helper functions.">QCAD::gatherVector</a>(std::vector&lt;double&gt;&amp; v, std::vector&lt;double&gt;&amp; gv, <span class="keyword">const</span> Epetra_Comm&amp; comm_)
<a name="l02122"></a>02122 {
<a name="l02123"></a>02123   <span class="keywordtype">double</span> *pvec, zeroSizeDummy = 0;
<a name="l02124"></a>02124   pvec = (v.size() &gt; 0) ? &amp;v[0] : &amp;zeroSizeDummy;
<a name="l02125"></a>02125 
<a name="l02126"></a>02126   Epetra_Map map(-1, v.size(), 0, comm_);
<a name="l02127"></a>02127   Epetra_Vector ev(View, map, pvec);
<a name="l02128"></a>02128   <span class="keywordtype">int</span>  N = map.NumGlobalElements();
<a name="l02129"></a>02129   Epetra_LocalMap lomap(N,0,comm_);
<a name="l02130"></a>02130 
<a name="l02131"></a>02131   gv.resize(N);
<a name="l02132"></a>02132   pvec = (gv.size() &gt; 0) ? &amp;gv[0] : &amp;zeroSizeDummy;
<a name="l02133"></a>02133   Epetra_Vector egv(View, lomap, pvec);
<a name="l02134"></a>02134   Epetra_Import <span class="keyword">import</span>(lomap,map);
<a name="l02135"></a>02135   egv.Import(ev, <span class="keyword">import</span>, Insert);
<a name="l02136"></a>02136 }
<a name="l02137"></a>02137 
<a name="l02138"></a><a class="code" href="namespaceQCAD.html#a75992f4f866ba0dceba1c2d89b756c67">02138</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceQCAD.html#a75992f4f866ba0dceba1c2d89b756c67">QCAD::lessOp</a>(std::pair&lt;std::size_t, double&gt; <span class="keyword">const</span>&amp; <a class="code" href="MOR__ExtendedEpetraLapack_8cpp.html#abaab71a1a7c21d8e915288b6945891f6">a</a>,
<a name="l02139"></a>02139       std::pair&lt;std::size_t, double&gt; <span class="keyword">const</span>&amp; b) {
<a name="l02140"></a>02140   <span class="keywordflow">return</span> a.second &lt; b.second;
<a name="l02141"></a>02141 }
<a name="l02142"></a>02142 
<a name="l02143"></a><a class="code" href="namespaceQCAD.html#a8146e2aea1832644a7a0dced84e9d80c">02143</a> <span class="keywordtype">void</span> <a class="code" href="namespaceQCAD.html#a8146e2aea1832644a7a0dced84e9d80c">QCAD::getOrdering</a>(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; v, std::vector&lt;int&gt;&amp; ordering)
<a name="l02144"></a>02144 {
<a name="l02145"></a>02145   <span class="keyword">typedef</span> std::vector&lt;double&gt;::const_iterator dbl_iter;
<a name="l02146"></a>02146   <span class="keyword">typedef</span> std::vector&lt;std::pair&lt;std::size_t, double&gt; &gt;::const_iterator pair_iter;
<a name="l02147"></a>02147   std::vector&lt;std::pair&lt;std::size_t, double&gt; &gt; vPairs(v.size());
<a name="l02148"></a>02148 
<a name="l02149"></a>02149   <span class="keywordtype">size_t</span> <a class="code" href="MOR__ExtendedEpetraLapack_8cpp.html#af5da5165aa5eeff113accece5748c995">n</a> = 0;
<a name="l02150"></a>02150   <span class="keywordflow">for</span> (dbl_iter it = v.begin(); it != v.end(); ++it, ++n)
<a name="l02151"></a>02151     vPairs[n] = std::make_pair(n, *it);
<a name="l02152"></a>02152 
<a name="l02153"></a>02153 
<a name="l02154"></a>02154   std::sort(vPairs.begin(), vPairs.end(), QCAD::lessOp);
<a name="l02155"></a>02155 
<a name="l02156"></a>02156   ordering.resize(v.size()); n = 0;
<a name="l02157"></a>02157   <span class="keywordflow">for</span> (pair_iter it = vPairs.begin(); it != vPairs.end(); ++it, ++n)
<a name="l02158"></a>02158     ordering[n] = it-&gt;first;
<a name="l02159"></a>02159 }
<a name="l02160"></a>02160 
<a name="l02161"></a>02161 
<a name="l02162"></a><a class="code" href="namespaceQCAD.html#a60ab2fe2fbbbd5d8e573d61cf5a09f41">02162</a> <span class="keywordtype">double</span> <a class="code" href="namespaceQCAD.html#a60ab2fe2fbbbd5d8e573d61cf5a09f41">QCAD::averageOfVector</a>(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; v)
<a name="l02163"></a>02163 {
<a name="l02164"></a>02164   <span class="keywordtype">double</span> avg = 0.0;
<a name="l02165"></a>02165   <span class="keywordflow">for</span>(std::size_t i=0; i &lt; v.size(); i++) {
<a name="l02166"></a>02166     avg += v[i];
<a name="l02167"></a>02167   }
<a name="l02168"></a>02168   avg /= v.size();
<a name="l02169"></a>02169   <span class="keywordflow">return</span> avg;
<a name="l02170"></a>02170 }
<a name="l02171"></a>02171 
<a name="l02172"></a><a class="code" href="namespaceQCAD.html#a42ea78e1e6778716622135e795f00909">02172</a> <span class="keywordtype">double</span> <a class="code" href="namespaceQCAD.html#a42ea78e1e6778716622135e795f00909">QCAD::distance</a>(<span class="keyword">const</span> std::vector&lt;double&gt;* vCoords, <span class="keywordtype">int</span> ind1, <span class="keywordtype">int</span> ind2, std::size_t nDims)
<a name="l02173"></a>02173 {
<a name="l02174"></a>02174   <span class="keywordtype">double</span> d2 = 0;
<a name="l02175"></a>02175   <span class="keywordflow">for</span>(std::size_t k=0; k&lt;nDims; k++)
<a name="l02176"></a>02176     d2 += pow( vCoords[k][ind1] - vCoords[k][ind2], 2 );
<a name="l02177"></a>02177   <span class="keywordflow">return</span> sqrt(d2);
<a name="l02178"></a>02178 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 26 2014 18:36:44 for Albany: a Trilinos-based PDE code by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
