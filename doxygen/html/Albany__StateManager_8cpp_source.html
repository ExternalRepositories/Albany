<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Albany: a Trilinos-based PDE code: Albany_StateManager.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>Albany_StateManager.cpp</h1>  </div>
</div>
<div class="contents">
<a href="Albany__StateManager_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//*****************************************************************//</span>
<a name="l00002"></a>00002 <span class="comment">//    Albany 2.0:  Copyright 2012 Sandia Corporation               //</span>
<a name="l00003"></a>00003 <span class="comment">//    This Software is released under the BSD license detailed     //</span>
<a name="l00004"></a>00004 <span class="comment">//    in the file &quot;license.txt&quot; in the top-level Albany directory  //</span>
<a name="l00005"></a>00005 <span class="comment">//*****************************************************************//</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#include &quot;<a class="code" href="Albany__StateManager_8hpp.html">Albany_StateManager.hpp</a>&quot;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;<a class="code" href="Albany__Utils_8hpp.html">Albany_Utils.hpp</a>&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;Teuchos_VerboseObject.hpp&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;Teuchos_TestForException.hpp&quot;</span>
<a name="l00011"></a>00011 
<a name="l00012"></a><a class="code" href="classAlbany_1_1StateManager.html#a694a3e537a19efdebd258d81b8d3f23f">00012</a> <a class="code" href="classAlbany_1_1StateManager.html#a694a3e537a19efdebd258d81b8d3f23f">Albany::StateManager::StateManager</a>() :
<a name="l00013"></a>00013   stateVarsAreAllocated(false),
<a name="l00014"></a>00014   stateInfo(Teuchos::rcp(new <a class="code" href="classAlbany_1_1StateInfoStruct.html">StateInfoStruct</a>)),
<a name="l00015"></a>00015   time(0.0),
<a name="l00016"></a>00016   timeOld(0.0)
<a name="l00017"></a>00017 {
<a name="l00018"></a>00018 }
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 Teuchos::RCP&lt;Teuchos::ParameterList&gt;
<a name="l00021"></a><a class="code" href="classAlbany_1_1StateManager.html#a095bff1386e8bac5de4a9e504b793781">00021</a> <a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903" title="Method to call multiple times (before allocate) to register which states will be saved.">Albany::StateManager::registerStateVariable</a>(<span class="keyword">const</span> std::string &amp;name, <span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &amp;dl,
<a name="l00022"></a>00022                                             <span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &amp;dummy,
<a name="l00023"></a>00023                                             <span class="keyword">const</span> std::string&amp; ebName,
<a name="l00024"></a>00024                                             <span class="keyword">const</span> std::string &amp;init_type,
<a name="l00025"></a>00025                                             <span class="keyword">const</span> <span class="keywordtype">double</span> init_val,
<a name="l00026"></a>00026                                             <span class="keyword">const</span> <span class="keywordtype">bool</span> registerOldState)
<a name="l00027"></a>00027 {
<a name="l00028"></a>00028   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903" title="Method to call multiple times (before allocate) to register which states will be saved.">registerStateVariable</a>(name, dl, dummy, ebName, init_type, init_val, registerOldState, name);
<a name="l00029"></a>00029 }
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 Teuchos::RCP&lt;Teuchos::ParameterList&gt;
<a name="l00032"></a><a class="code" href="classAlbany_1_1StateManager.html#aa616c8087f99b109b9154676a6d26b89">00032</a> <a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903" title="Method to call multiple times (before allocate) to register which states will be saved.">Albany::StateManager::registerStateVariable</a>(<span class="keyword">const</span> std::string &amp;stateName, <span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &amp;dl,
<a name="l00033"></a>00033                                             <span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &amp;dummy,
<a name="l00034"></a>00034                                             <span class="keyword">const</span> std::string&amp; ebName,
<a name="l00035"></a>00035                                             <span class="keyword">const</span> std::string &amp;init_type,
<a name="l00036"></a>00036                                             <span class="keyword">const</span> <span class="keywordtype">double</span> init_val,
<a name="l00037"></a>00037                                             <span class="keyword">const</span> <span class="keywordtype">bool</span> registerOldState,
<a name="l00038"></a>00038                                             <span class="keyword">const</span> std::string&amp; fieldName)
<a name="l00039"></a>00039 {
<a name="l00040"></a>00040   <span class="keyword">const</span> <span class="keywordtype">bool</span> bOutputToExodus = <span class="keyword">true</span>;
<a name="l00041"></a>00041   <a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903" title="Method to call multiple times (before allocate) to register which states will be saved.">registerStateVariable</a>(stateName, dl, ebName, init_type, init_val, registerOldState, bOutputToExodus, fieldName);
<a name="l00042"></a>00042 
<a name="l00043"></a>00043   <span class="comment">// Create param list for SaveStateField evaluator </span>
<a name="l00044"></a>00044   Teuchos::RCP&lt;Teuchos::ParameterList&gt; p = Teuchos::rcp(<span class="keyword">new</span> Teuchos::ParameterList(<span class="stringliteral">&quot;Save or Load State &quot;</span> 
<a name="l00045"></a>00045                 + stateName + <span class="stringliteral">&quot; to/from field &quot;</span> + fieldName));
<a name="l00046"></a>00046   p-&gt;set&lt;<span class="keyword">const</span> std::string&gt;(<span class="stringliteral">&quot;State Name&quot;</span>, stateName);
<a name="l00047"></a>00047   p-&gt;set&lt;<span class="keyword">const</span> std::string&gt;(<span class="stringliteral">&quot;Field Name&quot;</span>, fieldName);
<a name="l00048"></a>00048   p-&gt;set&lt;<span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &gt;(<span class="stringliteral">&quot;State Field Layout&quot;</span>, dl);
<a name="l00049"></a>00049   p-&gt;set&lt;<span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &gt;(<span class="stringliteral">&quot;Dummy Data Layout&quot;</span>, dummy);
<a name="l00050"></a>00050   <span class="keywordflow">return</span> p;
<a name="l00051"></a>00051 }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 Teuchos::RCP&lt;Teuchos::ParameterList&gt;
<a name="l00054"></a><a class="code" href="classAlbany_1_1StateManager.html#adc4aed677a0d5523056baf6393181484">00054</a> <a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903" title="Method to call multiple times (before allocate) to register which states will be saved.">Albany::StateManager::registerStateVariable</a>(<span class="keyword">const</span> std::string &amp;stateName, <span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &amp;dl,
<a name="l00055"></a>00055                                             <span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &amp;dummy,
<a name="l00056"></a>00056                                             <span class="keyword">const</span> std::string&amp; ebName,
<a name="l00057"></a>00057                                             <span class="keyword">const</span> std::string &amp;init_type,
<a name="l00058"></a>00058                                             <span class="keyword">const</span> <span class="keywordtype">double</span> init_val,
<a name="l00059"></a>00059                                             <span class="keyword">const</span> <span class="keywordtype">bool</span> registerOldState,
<a name="l00060"></a>00060                                             <span class="keyword">const</span> <span class="keywordtype">bool</span> outputToExodus)
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062   <a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903" title="Method to call multiple times (before allocate) to register which states will be saved.">registerStateVariable</a>(stateName, dl, ebName, init_type, init_val, registerOldState, outputToExodus, stateName);
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   <span class="comment">// Create param list for SaveStateField evaluator </span>
<a name="l00065"></a>00065   Teuchos::RCP&lt;Teuchos::ParameterList&gt; p = Teuchos::rcp(<span class="keyword">new</span> Teuchos::ParameterList(<span class="stringliteral">&quot;Save or Load State &quot;</span> 
<a name="l00066"></a>00066                 + stateName + <span class="stringliteral">&quot; to/from field &quot;</span> + stateName));
<a name="l00067"></a>00067   p-&gt;set&lt;<span class="keyword">const</span> std::string&gt;(<span class="stringliteral">&quot;State Name&quot;</span>, stateName);
<a name="l00068"></a>00068   p-&gt;set&lt;<span class="keyword">const</span> std::string&gt;(<span class="stringliteral">&quot;Field Name&quot;</span>, stateName);
<a name="l00069"></a>00069   p-&gt;set&lt;<span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &gt;(<span class="stringliteral">&quot;State Field Layout&quot;</span>, dl);
<a name="l00070"></a>00070   p-&gt;set&lt;<span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &gt;(<span class="stringliteral">&quot;Dummy Data Layout&quot;</span>, dummy);
<a name="l00071"></a>00071   <span class="keywordflow">return</span> p;
<a name="l00072"></a>00072 }
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="keywordtype">void</span>
<a name="l00075"></a><a class="code" href="classAlbany_1_1StateManager.html#a4ea721e33da8dba3b6ea9cf2cc43fdfb">00075</a> <a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903" title="Method to call multiple times (before allocate) to register which states will be saved.">Albany::StateManager::registerStateVariable</a>(<span class="keyword">const</span> std::string &amp;stateName, 
<a name="l00076"></a>00076               <span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &amp;dl,
<a name="l00077"></a>00077                                             <span class="keyword">const</span> std::string &amp;init_type){
<a name="l00078"></a>00078 
<a name="l00079"></a>00079   <span class="comment">// Grab the ebName</span>
<a name="l00080"></a>00080   std::string ebName;
<a name="l00081"></a>00081   <a class="code" href="classAlbany_1_1StateInfoStruct.html#aed7c016c2064abc7f3feacfebd987530">Albany::StateInfoStruct::const_iterator</a> st = <a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>-&gt;begin(); 
<a name="l00082"></a>00082   ebName = (*st)-&gt;nameMap[stateName];
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="comment">// Call the below function</span>
<a name="l00085"></a>00085   <a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903" title="Method to call multiple times (before allocate) to register which states will be saved.">registerStateVariable</a>(stateName, dl, ebName, init_type, 0.0, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 }
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="keywordtype">void</span>
<a name="l00091"></a><a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903">00091</a> <a class="code" href="classAlbany_1_1StateManager.html#a57d24c91ac67549772ebb19d5f5e8903" title="Method to call multiple times (before allocate) to register which states will be saved.">Albany::StateManager::registerStateVariable</a>(<span class="keyword">const</span> std::string &amp;stateName, 
<a name="l00092"></a>00092               <span class="keyword">const</span> Teuchos::RCP&lt;PHX::DataLayout&gt; &amp;dl,
<a name="l00093"></a>00093                                             <span class="keyword">const</span> std::string&amp; ebName,
<a name="l00094"></a>00094                                             <span class="keyword">const</span> std::string &amp;init_type,                                            
<a name="l00095"></a>00095                                             <span class="keyword">const</span> <span class="keywordtype">double</span> init_val,
<a name="l00096"></a>00096                                             <span class="keyword">const</span> <span class="keywordtype">bool</span> registerOldState,
<a name="l00097"></a>00097               <span class="keyword">const</span> <span class="keywordtype">bool</span> outputToExodus,
<a name="l00098"></a>00098               <span class="keyword">const</span> std::string &amp;responseIDtoRequire)
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 {
<a name="l00101"></a>00101   TEUCHOS_TEST_FOR_EXCEPT(<a class="code" href="classAlbany_1_1StateManager.html#aade1d726c1d61e5c0d395d6c4cf2c881" title="boolean to enforce that allocate gets called once, and after registration and befor gets...">stateVarsAreAllocated</a>);
<a name="l00102"></a>00102   <span class="keyword">using</span> <a class="code" href="structAlbany_1_1StateStruct.html" title="Container to get state info from StateManager to STK. Made into a struct so.">Albany::StateStruct</a>;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="keywordflow">if</span>( <a class="code" href="classAlbany_1_1StateManager.html#a0669da6e1007b5774c4c46c3f5bec06b" title="Container to hold the states that have been registered, by element block, to be allocated later...">statesToStore</a>[ebName].find(stateName) != <a class="code" href="classAlbany_1_1StateManager.html#a0669da6e1007b5774c4c46c3f5bec06b" title="Container to hold the states that have been registered, by element block, to be allocated later...">statesToStore</a>[ebName].end() ) {
<a name="l00105"></a>00105     <span class="comment">//Duplicate registration.  This will occur when a problem&#39;s </span>
<a name="l00106"></a>00106     <span class="comment">// constructEvaluators function (templated) registers state variables.</span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108     <span class="comment">//Perform a check here that dl and statesToStore[stateName] are the same:</span>
<a name="l00109"></a>00109     <span class="comment">//TEUCHOS_TEST_FOR_EXCEPT(dl != statesToStore[stateName]);  //I don&#39;t know how to do this correctly (erik)</span>
<a name="l00110"></a>00110 <span class="comment">//    TEUCHOS_TEST_FOR_EXCEPT(!(*dl == *statesToStore[stateName]));  </span>
<a name="l00111"></a>00111     <span class="keywordflow">return</span>;  <span class="comment">// Don&#39;t re-register the same state name</span>
<a name="l00112"></a>00112   }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <a class="code" href="classAlbany_1_1StateManager.html#a0669da6e1007b5774c4c46c3f5bec06b" title="Container to hold the states that have been registered, by element block, to be allocated later...">statesToStore</a>[ebName][stateName] = dl;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   <span class="comment">// Load into StateInfo</span>
<a name="l00117"></a>00117   <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702f">StateStruct::MeshFieldEntity</a> mfe_type;
<a name="l00118"></a>00118   <span class="keywordflow">if</span>(dl-&gt;rank() == 1 &amp;&amp; dl-&gt;size() == 1)
<a name="l00119"></a>00119      mfe_type = <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702facaa3d98772a7a547b37a47bd675a634e">StateStruct::WorksetValue</a>; <span class="comment">// One value for the whole workset (i.e., time)</span>
<a name="l00120"></a>00120   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(dl-&gt;rank() &gt;= 1 &amp;&amp; dl-&gt;name(0) == <span class="stringliteral">&quot;Node&quot;</span>) <span class="comment">// Nodal data</span>
<a name="l00121"></a>00121      mfe_type = <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa22a22a6a3084cb487d49745d467f09c9">StateStruct::NodalData</a>; 
<a name="l00122"></a>00122   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(dl-&gt;rank() &gt;= 1 &amp;&amp; dl-&gt;name(0) == <span class="stringliteral">&quot;Cell&quot;</span>){ <span class="comment">// Element QP or node data</span>
<a name="l00123"></a>00123      <span class="keywordflow">if</span>(dl-&gt;rank() &gt; 1 &amp;&amp; dl-&gt;name(1) == <span class="stringliteral">&quot;Node&quot;</span>) <span class="comment">// Element node data</span>
<a name="l00124"></a>00124         mfe_type = <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa87bc53c684e7d8bde1599cb53030b468">StateStruct::ElemNode</a>; <span class="comment">// One value for the whole workset (i.e., time)</span>
<a name="l00125"></a>00125      <span class="keywordflow">else</span> <span class="keywordflow">if</span>(dl-&gt;rank() &gt; 1 &amp;&amp; dl-&gt;name(1) == <span class="stringliteral">&quot;QuadPoint&quot;</span>) <span class="comment">// Element node data</span>
<a name="l00126"></a>00126         mfe_type = <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa1d93caa4061e9c5dd77d1863d33447a2">StateStruct::QuadPoint</a>; <span class="comment">// One value for the whole workset (i.e., time)</span>
<a name="l00127"></a>00127      <span class="keywordflow">else</span> TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l00128"></a>00128        <span class="stringliteral">&quot;StateManager: Element Entity type - &quot;</span> &lt;&lt; dl-&gt;name(1) &lt;&lt; <span class="stringliteral">&quot; - not supported&quot;</span> &lt;&lt; std::endl); 
<a name="l00129"></a>00129   }
<a name="l00130"></a>00130   <span class="keywordflow">else</span> TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l00131"></a>00131      <span class="stringliteral">&quot;StateManager: Unknown Entity type - &quot;</span> &lt;&lt; dl-&gt;name(0) &lt;&lt; <span class="stringliteral">&quot; - not supported&quot;</span> &lt;&lt; std::endl); 
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   (*stateInfo).push_back(Teuchos::rcp(<span class="keyword">new</span> <a class="code" href="structAlbany_1_1StateStruct.html" title="Container to get state info from StateManager to STK. Made into a struct so.">StateStruct</a>(stateName, mfe_type)));
<a name="l00134"></a>00134   <a class="code" href="structAlbany_1_1StateStruct.html" title="Container to get state info from StateManager to STK. Made into a struct so.">StateStruct</a>&amp; stateRef = *<a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>-&gt;back();
<a name="l00135"></a>00135   stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a6bd62f9a98be7cf0895c07390fb289dd">setInitType</a>(init_type); 
<a name="l00136"></a>00136   stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a4d845e0e2fd155e016813fcaba1286ce">setInitValue</a>(init_val); 
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   dl-&gt;dimensions(stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#aea26837b56776ee4889d9a00e5022294">dim</a>); 
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <span class="keywordflow">if</span>(stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a30a1277092150048913e197d5abf720b">entity</a> == <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa22a22a6a3084cb487d49745d467f09c9">StateStruct::NodalData</a>){ <span class="comment">// nodal data</span>
<a name="l00141"></a>00141 
<a name="l00142"></a>00142     Teuchos::RCP&lt;Adapt::NodalDataBlock&gt; nodalDataBlock = <a class="code" href="classAlbany_1_1StateManager.html#a319b8dd5531320fb320e19fc52119d91">getNodalDataBlock</a>();
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <span class="keywordflow">if</span> ( dl-&gt;rank() == 2 ){ <span class="comment">// node vector</span>
<a name="l00145"></a>00145       <span class="comment">// register the state with the nodalDataBlock also</span>
<a name="l00146"></a>00146       nodalDataBlock-&gt;registerState(stateName, stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#aea26837b56776ee4889d9a00e5022294">dim</a>[1]);
<a name="l00147"></a>00147     }
<a name="l00148"></a>00148     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( dl-&gt;rank() == 3 ){ <span class="comment">// node tensor</span>
<a name="l00149"></a>00149       <span class="comment">// register the state with the nodalDataBlock also</span>
<a name="l00150"></a>00150       nodalDataBlock-&gt;registerState(stateName, stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#aea26837b56776ee4889d9a00e5022294">dim</a>[1]*stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#aea26837b56776ee4889d9a00e5022294">dim</a>[2]);
<a name="l00151"></a>00151     }
<a name="l00152"></a>00152     <span class="keywordflow">else</span> { <span class="comment">// node scalar</span>
<a name="l00153"></a>00153       <span class="comment">// register the state with the nodalDataBlock also</span>
<a name="l00154"></a>00154       nodalDataBlock-&gt;registerState(stateName, 1);
<a name="l00155"></a>00155     }
<a name="l00156"></a>00156   }
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a5d91ba35bcea0d974652f08ffef1fef3">output</a> = outputToExodus;
<a name="l00159"></a>00159   stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a29fb1be0bf71ad02df4e949c570a93aa">responseIDtoRequire</a> = responseIDtoRequire;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="comment">// If space is needed for old state</span>
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (registerOldState) {
<a name="l00163"></a>00163     stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a1ffcef07479773d739643590cff7da7e">saveOldState</a> = <span class="keyword">true</span>; 
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     std::string stateName_old = stateName + <span class="stringliteral">&quot;_old&quot;</span>;
<a name="l00166"></a>00166     (*stateInfo).push_back(Teuchos::rcp(<span class="keyword">new</span> <a class="code" href="structAlbany_1_1StateStruct.html" title="Container to get state info from StateManager to STK. Made into a struct so.">Albany::StateStruct</a>(stateName_old, mfe_type)));
<a name="l00167"></a>00167     <a class="code" href="structAlbany_1_1StateStruct.html" title="Container to get state info from StateManager to STK. Made into a struct so.">Albany::StateStruct</a>&amp; pstateRef = *<a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>-&gt;back();
<a name="l00168"></a>00168     pstateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a984f4a1b2d28e3c94dc9c44ced14631b">initType</a>  = init_type; 
<a name="l00169"></a>00169     pstateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a9144744d64f8dc2b5eaa3092b1c2579d">initValue</a> = init_val; 
<a name="l00170"></a>00170     pstateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a79a978a5545a027f1e56d633289d5de7">pParentStateStruct</a> = &amp;stateRef;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172     pstateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a5d91ba35bcea0d974652f08ffef1fef3">output</a> = <span class="keyword">false</span>; 
<a name="l00173"></a>00173     dl-&gt;dimensions(pstateRef.<a class="code" href="structAlbany_1_1StateStruct.html#aea26837b56776ee4889d9a00e5022294">dim</a>); 
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     <span class="keywordflow">if</span>(pstateRef.<a class="code" href="structAlbany_1_1StateStruct.html#a30a1277092150048913e197d5abf720b">entity</a> == <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa22a22a6a3084cb487d49745d467f09c9">StateStruct::NodalData</a>){ <span class="comment">// nodal data</span>
<a name="l00176"></a>00176 
<a name="l00177"></a>00177       Teuchos::RCP&lt;Adapt::NodalDataBlock&gt; nodalDataBlock = <a class="code" href="classAlbany_1_1StateManager.html#a319b8dd5531320fb320e19fc52119d91">getNodalDataBlock</a>();
<a name="l00178"></a>00178 
<a name="l00179"></a>00179       <span class="keywordflow">if</span> ( dl-&gt;rank() == 2 ){ <span class="comment">// node vector</span>
<a name="l00180"></a>00180         <span class="comment">// register the state with the nodalDataBlock also</span>
<a name="l00181"></a>00181         nodalDataBlock-&gt;registerState(stateName_old, pstateRef.<a class="code" href="structAlbany_1_1StateStruct.html#aea26837b56776ee4889d9a00e5022294">dim</a>[1]);
<a name="l00182"></a>00182       }
<a name="l00183"></a>00183       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( dl-&gt;rank() == 3 ){ <span class="comment">// node tensor</span>
<a name="l00184"></a>00184         <span class="comment">// register the state with the nodalDataBlock also</span>
<a name="l00185"></a>00185         nodalDataBlock-&gt;registerState(stateName_old, pstateRef.<a class="code" href="structAlbany_1_1StateStruct.html#aea26837b56776ee4889d9a00e5022294">dim</a>[1]*pstateRef.<a class="code" href="structAlbany_1_1StateStruct.html#aea26837b56776ee4889d9a00e5022294">dim</a>[2]);
<a name="l00186"></a>00186       }
<a name="l00187"></a>00187       <span class="keywordflow">else</span> { <span class="comment">// node scalar</span>
<a name="l00188"></a>00188         <span class="comment">// register the state with the nodalDataBlock also</span>
<a name="l00189"></a>00189         nodalDataBlock-&gt;registerState(stateName_old, 1);
<a name="l00190"></a>00190       }
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   <span class="comment">// insert</span>
<a name="l00196"></a>00196   stateRef.<a class="code" href="structAlbany_1_1StateStruct.html#abf8aa10978521f74f4fc9f1412bd30af">nameMap</a>[stateName] = ebName;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 Teuchos::RCP&lt;Albany::StateInfoStruct&gt;
<a name="l00201"></a><a class="code" href="classAlbany_1_1StateManager.html#a7059e18bb229390ebc6345393301a8ba">00201</a> <a class="code" href="classAlbany_1_1StateManager.html#a7059e18bb229390ebc6345393301a8ba" title="Method to get a StateInfoStruct of info needed by STK to output States as Fields.">Albany::StateManager::getStateInfoStruct</a>()
<a name="l00202"></a>00202 {
<a name="l00203"></a>00203   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>;
<a name="l00204"></a>00204 }
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="keywordtype">void</span>
<a name="l00207"></a><a class="code" href="classAlbany_1_1StateManager.html#a8491155438e8cbb6a62289d2e3ab45d0">00207</a> <a class="code" href="classAlbany_1_1StateManager.html#a8491155438e8cbb6a62289d2e3ab45d0" title="Method to set discretization object.">Albany::StateManager::setStateArrays</a>(<span class="keyword">const</span> Teuchos::RCP&lt;Albany::AbstractDiscretization&gt;&amp; disc_)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209   TEUCHOS_TEST_FOR_EXCEPT(<a class="code" href="classAlbany_1_1StateManager.html#aade1d726c1d61e5c0d395d6c4cf2c881" title="boolean to enforce that allocate gets called once, and after registration and befor gets...">stateVarsAreAllocated</a>);
<a name="l00210"></a>00210   <a class="code" href="classAlbany_1_1StateManager.html#aade1d726c1d61e5c0d395d6c4cf2c881" title="boolean to enforce that allocate gets called once, and after registration and befor gets...">stateVarsAreAllocated</a> = <span class="keyword">true</span>;
<a name="l00211"></a>00211   Teuchos::RCP&lt;Teuchos::FancyOStream&gt; out(Teuchos::VerboseObjectBase::getDefaultOStream());
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   <a class="code" href="classAlbany_1_1StateManager.html#a284d2a5617d3ef99570a623dcb6da498" title="Discretization object which allows StateManager to perform input/output with exodus and Epetra vector...">disc</a> = disc_;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   <span class="comment">// Get states from STK mesh </span>
<a name="l00217"></a>00217   <a class="code" href="structAlbany_1_1StateArrays.html">Albany::StateArrays</a>&amp; sa = <a class="code" href="classAlbany_1_1StateManager.html#a284d2a5617d3ef99570a623dcb6da498" title="Discretization object which allows StateManager to perform input/output with exodus and Epetra vector...">disc</a>-&gt;getStateArrays();
<a name="l00218"></a>00218   <a class="code" href="namespaceAlbany.html#a3e8c8ca3caa4ab17ad3ce87deeee3db3">Albany::StateArrayVec</a>&amp; esa = sa.<a class="code" href="structAlbany_1_1StateArrays.html#a5fa0a75997a1a3135dbd2559ad4e0e8f">elemStateArrays</a>;
<a name="l00219"></a>00219   <a class="code" href="namespaceAlbany.html#a3e8c8ca3caa4ab17ad3ce87deeee3db3">Albany::StateArrayVec</a>&amp; nsa = sa.<a class="code" href="structAlbany_1_1StateArrays.html#a93330d27ac0e1f884c7d0fae751e2741">nodeStateArrays</a>;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="keywordtype">int</span> numElemWorksets = esa.size();
<a name="l00222"></a>00222   <span class="keywordtype">int</span> numNodeWorksets = nsa.size();
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="comment">// For each workset, loop over registered states</span>
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>-&gt;size(); i++) {
<a name="l00227"></a>00227     <span class="keyword">const</span> std::string stateName = (*stateInfo)[i]-&gt;name;
<a name="l00228"></a>00228     <span class="keyword">const</span> std::string init_type = (*stateInfo)[i]-&gt;initType;
<a name="l00229"></a>00229     <span class="keyword">const</span> <span class="keywordtype">double</span> init_val       = (*stateInfo)[i]-&gt;initValue;
<a name="l00230"></a>00230     <span class="keywordtype">bool</span> have_restart           = (*stateInfo)[i]-&gt;restartDataAvailable;
<a name="l00231"></a>00231     <a class="code" href="structAlbany_1_1StateStruct.html" title="Container to get state info from StateManager to STK. Made into a struct so.">Albany::StateStruct</a> *pParentStruct = (*stateInfo)[i]-&gt;pParentStateStruct;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="comment">// JTO: specifying zero recovers previous behavior</span>
<a name="l00234"></a>00234     <span class="comment">// if (stateName == &quot;zero&quot;)</span>
<a name="l00235"></a>00235     <span class="comment">// { </span>
<a name="l00236"></a>00236     <span class="comment">//   init_val = 0.0;</span>
<a name="l00237"></a>00237     <span class="comment">//   init_type = &quot;scalar&quot;;</span>
<a name="l00238"></a>00238     <span class="comment">// }</span>
<a name="l00239"></a>00239 
<a name="l00240"></a>00240     *out &lt;&lt; <span class="stringliteral">&quot;StateManager: initializing state:  &quot;</span> &lt;&lt; stateName;
<a name="l00241"></a>00241     <span class="keywordflow">switch</span>((*<a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>)[i]-&gt;entity){
<a name="l00242"></a>00242 
<a name="l00243"></a>00243      <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702facaa3d98772a7a547b37a47bd675a634e">Albany::StateStruct::WorksetValue</a> :
<a name="l00244"></a>00244      <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa1d93caa4061e9c5dd77d1863d33447a2">Albany::StateStruct::QuadPoint</a> :
<a name="l00245"></a>00245      <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa87bc53c684e7d8bde1599cb53030b468">Albany::StateStruct::ElemNode</a> :
<a name="l00246"></a>00246 
<a name="l00247"></a>00247       <span class="keywordflow">if</span>(have_restart){
<a name="l00248"></a>00248           *out &lt;&lt; <span class="stringliteral">&quot; from restart file.&quot;</span> &lt;&lt; std::endl;
<a name="l00249"></a>00249           <span class="comment">// If we are restarting, arrays should already be initialized from exodus file</span>
<a name="l00250"></a>00250           <span class="keywordflow">continue</span>;
<a name="l00251"></a>00251       }
<a name="l00252"></a>00252       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pParentStruct &amp;&amp; pParentStruct-&gt;<a class="code" href="structAlbany_1_1StateStruct.html#abf8953296e6df6e003f474bf7512f56a">restartDataAvailable</a>){
<a name="l00253"></a>00253           *out &lt;&lt; <span class="stringliteral">&quot; from restarted parent state.&quot;</span> &lt;&lt; std::endl;
<a name="l00254"></a>00254           <span class="comment">// If we are restarting, my parent is initialized from exodus file</span>
<a name="l00255"></a>00255           <span class="comment">// Copy over parent&#39;s state</span>
<a name="l00256"></a>00256   
<a name="l00257"></a>00257           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ws = 0; ws &lt; numElemWorksets; ws++)
<a name="l00258"></a>00258   
<a name="l00259"></a>00259             esa[ws][stateName] = esa[ws][pParentStruct-&gt;<a class="code" href="structAlbany_1_1StateStruct.html#a0ef8799c3c43a73a0374ddc5a442e16d">name</a>];
<a name="l00260"></a>00260   
<a name="l00261"></a>00261           <span class="keywordflow">continue</span>;
<a name="l00262"></a>00262       }
<a name="l00263"></a>00263       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (init_type == <span class="stringliteral">&quot;scalar&quot;</span>)
<a name="l00264"></a>00264         *out &lt;&lt; <span class="stringliteral">&quot; with initialization type &#39;scalar&#39; and value: &quot;</span> &lt;&lt; init_val &lt;&lt; std::endl;
<a name="l00265"></a>00265       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (init_type == <span class="stringliteral">&quot;identity&quot;</span>)
<a name="l00266"></a>00266         *out &lt;&lt; <span class="stringliteral">&quot; with initialization type &#39;identity&#39;&quot;</span> &lt;&lt; std::endl;
<a name="l00267"></a>00267   
<a name="l00268"></a>00268       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ws = 0; ws &lt; numElemWorksets; ws++){
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         <a class="code" href="structAlbany_1_1StateStruct.html#a822ba90a6f8529f640db1f9fac6a07bd">Albany::StateStruct::FieldDims</a> dims;
<a name="l00271"></a>00271         esa[ws][stateName].dimensions(dims);
<a name="l00272"></a>00272         <span class="keywordtype">int</span> size = dims.size();
<a name="l00273"></a>00273   
<a name="l00274"></a>00274         <span class="keywordflow">if</span> (init_type == <span class="stringliteral">&quot;scalar&quot;</span>){
<a name="l00275"></a>00275   
<a name="l00276"></a>00276           <span class="keywordflow">switch</span> (size) {
<a name="l00277"></a>00277   
<a name="l00278"></a>00278             <span class="keywordflow">case</span> 1:
<a name="l00279"></a>00279               esa[ws][stateName](0) = init_val;
<a name="l00280"></a>00280               <span class="keywordflow">break</span>;
<a name="l00281"></a>00281   
<a name="l00282"></a>00282             <span class="keywordflow">case</span> 2:
<a name="l00283"></a>00283               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cell = 0; cell &lt; dims[0]; ++cell)
<a name="l00284"></a>00284                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qp = 0; qp &lt; dims[1]; ++qp)
<a name="l00285"></a>00285                   esa[ws][stateName](cell, qp) = init_val;
<a name="l00286"></a>00286               <span class="keywordflow">break</span>;
<a name="l00287"></a>00287   
<a name="l00288"></a>00288             <span class="keywordflow">case</span> 3:
<a name="l00289"></a>00289               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cell = 0; cell &lt; dims[0]; ++cell)
<a name="l00290"></a>00290                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qp = 0; qp &lt; dims[1]; ++qp)
<a name="l00291"></a>00291                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dims[2]; ++i)
<a name="l00292"></a>00292                     esa[ws][stateName](cell, qp, i) = init_val;
<a name="l00293"></a>00293               <span class="keywordflow">break</span>;
<a name="l00294"></a>00294   
<a name="l00295"></a>00295             <span class="keywordflow">case</span> 4:
<a name="l00296"></a>00296               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cell = 0; cell &lt; dims[0]; ++cell)
<a name="l00297"></a>00297                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qp = 0; qp &lt; dims[1]; ++qp)
<a name="l00298"></a>00298                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dims[2]; ++i)
<a name="l00299"></a>00299                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; dims[3]; ++j)
<a name="l00300"></a>00300                      esa[ws][stateName](cell, qp, i, j) = init_val;
<a name="l00301"></a>00301               <span class="keywordflow">break</span>;
<a name="l00302"></a>00302   
<a name="l00303"></a>00303             <span class="keywordflow">default</span>:
<a name="l00304"></a>00304               TEUCHOS_TEST_FOR_EXCEPTION(size&lt;2||size&gt;4, std::logic_error,
<a name="l00305"></a>00305                        <span class="stringliteral">&quot;Something is wrong during scalar state variable initialization: &quot;</span> &lt;&lt; size);
<a name="l00306"></a>00306           }
<a name="l00307"></a>00307   
<a name="l00308"></a>00308         }
<a name="l00309"></a>00309         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (init_type == <span class="stringliteral">&quot;identity&quot;</span>){
<a name="l00310"></a>00310 
<a name="l00311"></a>00311           <span class="comment">// we assume operating on the last two indices is correct</span>
<a name="l00312"></a>00312           TEUCHOS_TEST_FOR_EXCEPTION(size != 4, std::logic_error,
<a name="l00313"></a>00313              <span class="stringliteral">&quot;Something is wrong during tensor state variable initialization: &quot;</span> &lt;&lt; size);
<a name="l00314"></a>00314           TEUCHOS_TEST_FOR_EXCEPT( ! (dims[2] == dims[3]) );
<a name="l00315"></a>00315   
<a name="l00316"></a>00316           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cell = 0; cell &lt; dims[0]; ++cell)
<a name="l00317"></a>00317             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qp = 0; qp &lt; dims[1]; ++qp)
<a name="l00318"></a>00318               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dims[2]; ++i)
<a name="l00319"></a>00319                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; dims[3]; ++j)
<a name="l00320"></a>00320                   <span class="keywordflow">if</span> (i==j) esa[ws][stateName](cell, qp, i, i) = 1.0;
<a name="l00321"></a>00321                   <span class="keywordflow">else</span>      esa[ws][stateName](cell, qp, i, j) = 0.0;
<a name="l00322"></a>00322         }
<a name="l00323"></a>00323       }
<a name="l00324"></a>00324      <span class="keywordflow">break</span>;
<a name="l00325"></a>00325     
<a name="l00326"></a>00326      <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa22a22a6a3084cb487d49745d467f09c9">Albany::StateStruct::NodalData</a> :
<a name="l00327"></a>00327 
<a name="l00328"></a>00328       <span class="keywordflow">if</span>(have_restart){
<a name="l00329"></a>00329           *out &lt;&lt; <span class="stringliteral">&quot; from restart file.&quot;</span> &lt;&lt; std::endl;
<a name="l00330"></a>00330           <span class="comment">// If we are restarting, arrays should already be initialized from exodus file</span>
<a name="l00331"></a>00331           <span class="keywordflow">continue</span>;
<a name="l00332"></a>00332       }
<a name="l00333"></a>00333       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pParentStruct &amp;&amp; pParentStruct-&gt;<a class="code" href="structAlbany_1_1StateStruct.html#abf8953296e6df6e003f474bf7512f56a">restartDataAvailable</a>){
<a name="l00334"></a>00334           *out &lt;&lt; <span class="stringliteral">&quot; from restarted parent state.&quot;</span> &lt;&lt; std::endl;
<a name="l00335"></a>00335           <span class="comment">// If we are restarting, my parent is initialized from exodus file</span>
<a name="l00336"></a>00336           <span class="comment">// Copy over parent&#39;s state</span>
<a name="l00337"></a>00337   
<a name="l00338"></a>00338           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ws = 0; ws &lt; numNodeWorksets; ws++)
<a name="l00339"></a>00339   
<a name="l00340"></a>00340             nsa[ws][stateName] = nsa[ws][pParentStruct-&gt;<a class="code" href="structAlbany_1_1StateStruct.html#a0ef8799c3c43a73a0374ddc5a442e16d">name</a>];
<a name="l00341"></a>00341   
<a name="l00342"></a>00342           <span class="keywordflow">continue</span>;
<a name="l00343"></a>00343       }
<a name="l00344"></a>00344       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (init_type == <span class="stringliteral">&quot;scalar&quot;</span>)
<a name="l00345"></a>00345         *out &lt;&lt; <span class="stringliteral">&quot; with initialization type &#39;scalar&#39; and value: &quot;</span> &lt;&lt; init_val &lt;&lt; std::endl;
<a name="l00346"></a>00346       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (init_type == <span class="stringliteral">&quot;identity&quot;</span>)
<a name="l00347"></a>00347         *out &lt;&lt; <span class="stringliteral">&quot; with initialization type &#39;identity&#39;&quot;</span> &lt;&lt; std::endl;
<a name="l00348"></a>00348   
<a name="l00349"></a>00349       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ws = 0; ws &lt; numNodeWorksets; ws++){
<a name="l00350"></a>00350 
<a name="l00351"></a>00351         <a class="code" href="structAlbany_1_1StateStruct.html#a822ba90a6f8529f640db1f9fac6a07bd">Albany::StateStruct::FieldDims</a> dims;
<a name="l00352"></a>00352         nsa[ws][stateName].dimensions(dims);
<a name="l00353"></a>00353         <span class="keywordtype">int</span> size = dims.size();
<a name="l00354"></a>00354   
<a name="l00355"></a>00355         <span class="keywordflow">if</span> (init_type == <span class="stringliteral">&quot;scalar&quot;</span>)
<a name="l00356"></a>00356   
<a name="l00357"></a>00357           <span class="keywordflow">switch</span> (size) {
<a name="l00358"></a>00358   
<a name="l00359"></a>00359             <span class="keywordflow">case</span> 1: <span class="comment">// node scalar</span>
<a name="l00360"></a>00360               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node = 0; node &lt; dims[0]; ++node)
<a name="l00361"></a>00361                 nsa[ws][stateName](node) = init_val;
<a name="l00362"></a>00362               <span class="keywordflow">break</span>;
<a name="l00363"></a>00363   
<a name="l00364"></a>00364             <span class="keywordflow">case</span> 2: <span class="comment">// node vector</span>
<a name="l00365"></a>00365               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node = 0; node &lt; dims[0]; ++node)
<a name="l00366"></a>00366                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim = 0; dim &lt; dims[1]; ++dim)
<a name="l00367"></a>00367                   nsa[ws][stateName](node, dim) = init_val;
<a name="l00368"></a>00368               <span class="keywordflow">break</span>;
<a name="l00369"></a>00369   
<a name="l00370"></a>00370             <span class="keywordflow">case</span> 3: <span class="comment">// node tensor</span>
<a name="l00371"></a>00371               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node = 0; node &lt; dims[0]; ++node)
<a name="l00372"></a>00372                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim = 0; dim &lt; dims[1]; ++dim)
<a name="l00373"></a>00373                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dims[2]; ++i)
<a name="l00374"></a>00374                     nsa[ws][stateName](node, dim, i) = init_val;
<a name="l00375"></a>00375               <span class="keywordflow">break</span>;
<a name="l00376"></a>00376   
<a name="l00377"></a>00377             <span class="keywordflow">default</span>:
<a name="l00378"></a>00378               TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l00379"></a>00379                        <span class="stringliteral">&quot;Something is wrong during node scalar state variable initialization: &quot;</span> &lt;&lt; size);
<a name="l00380"></a>00380         }
<a name="l00381"></a>00381         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (init_type == <span class="stringliteral">&quot;identity&quot;</span>){
<a name="l00382"></a>00382 
<a name="l00383"></a>00383           <span class="comment">// we assume operating on the last two indices is correct</span>
<a name="l00384"></a>00384           TEUCHOS_TEST_FOR_EXCEPTION(size != 3, std::logic_error,
<a name="l00385"></a>00385              <span class="stringliteral">&quot;Something is wrong during node tensor state variable initialization: &quot;</span> &lt;&lt; size);
<a name="l00386"></a>00386           TEUCHOS_TEST_FOR_EXCEPT( ! (dims[1] == dims[2]) );
<a name="l00387"></a>00387   
<a name="l00388"></a>00388           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node = 0; node &lt; dims[0]; ++node)
<a name="l00389"></a>00389             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dims[1]; ++i)
<a name="l00390"></a>00390               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; dims[2]; ++j)
<a name="l00391"></a>00391                 <span class="keywordflow">if</span> (i==j) nsa[ws][stateName](node, i, i) = 1.0;
<a name="l00392"></a>00392                 <span class="keywordflow">else</span>      nsa[ws][stateName](node, i, j) = 0.0;
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394       }
<a name="l00395"></a>00395      <span class="keywordflow">break</span>;
<a name="l00396"></a>00396     }
<a name="l00397"></a>00397   }
<a name="l00398"></a>00398   *out &lt;&lt; std::endl;
<a name="l00399"></a>00399 }
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 Teuchos::RCP&lt;Albany::AbstractDiscretization&gt; 
<a name="l00403"></a>00403 <a class="code" href="classAlbany_1_1StateManager.html#ad52f3f167fe251a6098f7e9959c356e8" title="Method to get discretization object.">Albany::StateManager::</a>
<a name="l00404"></a><a class="code" href="classAlbany_1_1StateManager.html#ad52f3f167fe251a6098f7e9959c356e8">00404</a> <a class="code" href="classAlbany_1_1StateManager.html#ad52f3f167fe251a6098f7e9959c356e8" title="Method to get discretization object.">getDiscretization</a>()
<a name="l00405"></a>00405 { 
<a name="l00406"></a>00406   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1StateManager.html#a284d2a5617d3ef99570a623dcb6da498" title="Discretization object which allows StateManager to perform input/output with exodus and Epetra vector...">disc</a>;
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 <span class="keywordtype">void</span>
<a name="l00411"></a>00411 <a class="code" href="classAlbany_1_1StateManager.html#afee875ee3390910bc1685b32721b1bcd" title="Method to re-initialize state variables, which can be called multiple times after allocating...">Albany::StateManager::</a>
<a name="l00412"></a><a class="code" href="classAlbany_1_1StateManager.html#afee875ee3390910bc1685b32721b1bcd">00412</a> <a class="code" href="classAlbany_1_1StateManager.html#afee875ee3390910bc1685b32721b1bcd" title="Method to re-initialize state variables, which can be called multiple times after allocating...">importStateData</a>(<a class="code" href="structAlbany_1_1StateArrays.html">Albany::StateArrays</a>&amp; states_from)
<a name="l00413"></a>00413 {
<a name="l00414"></a>00414   TEUCHOS_TEST_FOR_EXCEPT(!<a class="code" href="classAlbany_1_1StateManager.html#aade1d726c1d61e5c0d395d6c4cf2c881" title="boolean to enforce that allocate gets called once, and after registration and befor gets...">stateVarsAreAllocated</a>);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <span class="comment">// Get states from STK mesh </span>
<a name="l00417"></a>00417   <a class="code" href="structAlbany_1_1StateArrays.html">Albany::StateArrays</a>&amp; sa = <a class="code" href="classAlbany_1_1StateManager.html#a267e5c760ffd3ecbb8ee440ab546b04f" title="Method to get state information for all worksets.">getStateArrays</a>();
<a name="l00418"></a>00418   <a class="code" href="namespaceAlbany.html#a3e8c8ca3caa4ab17ad3ce87deeee3db3">Albany::StateArrayVec</a>&amp; esa = sa.<a class="code" href="structAlbany_1_1StateArrays.html#a5fa0a75997a1a3135dbd2559ad4e0e8f">elemStateArrays</a>;
<a name="l00419"></a>00419   <a class="code" href="namespaceAlbany.html#a3e8c8ca3caa4ab17ad3ce87deeee3db3">Albany::StateArrayVec</a>&amp; nsa = sa.<a class="code" href="structAlbany_1_1StateArrays.html#a93330d27ac0e1f884c7d0fae751e2741">nodeStateArrays</a>;
<a name="l00420"></a>00420   <a class="code" href="namespaceAlbany.html#a3e8c8ca3caa4ab17ad3ce87deeee3db3">Albany::StateArrayVec</a>&amp; elemStatesToCopyFrom = states_from.<a class="code" href="structAlbany_1_1StateArrays.html#a5fa0a75997a1a3135dbd2559ad4e0e8f">elemStateArrays</a>;
<a name="l00421"></a>00421   <a class="code" href="namespaceAlbany.html#a3e8c8ca3caa4ab17ad3ce87deeee3db3">Albany::StateArrayVec</a>&amp; nodeStatesToCopyFrom = states_from.<a class="code" href="structAlbany_1_1StateArrays.html#a93330d27ac0e1f884c7d0fae751e2741">nodeStateArrays</a>;
<a name="l00422"></a>00422   <span class="keywordtype">int</span> numElemWorksets = esa.size();
<a name="l00423"></a>00423   <span class="keywordtype">int</span> numNodeWorksets = nsa.size();
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   TEUCHOS_TEST_FOR_EXCEPT((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numElemWorksets != elemStatesToCopyFrom.size());
<a name="l00426"></a>00426   TEUCHOS_TEST_FOR_EXCEPT((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)numNodeWorksets != nodeStatesToCopyFrom.size());
<a name="l00427"></a>00427 
<a name="l00428"></a>00428   Teuchos::RCP&lt;Teuchos::FancyOStream&gt; out(Teuchos::VerboseObjectBase::getDefaultOStream());
<a name="l00429"></a>00429   *out &lt;&lt; std::endl;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>-&gt;size(); i++) {
<a name="l00432"></a>00432     <span class="keyword">const</span> std::string stateName = (*stateInfo)[i]-&gt;name;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434     <span class="keywordflow">switch</span>((*<a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>)[i]-&gt;entity){
<a name="l00435"></a>00435 
<a name="l00436"></a>00436      <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702facaa3d98772a7a547b37a47bd675a634e">Albany::StateStruct::WorksetValue</a> :
<a name="l00437"></a>00437      <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa1d93caa4061e9c5dd77d1863d33447a2">Albany::StateStruct::QuadPoint</a> :
<a name="l00438"></a>00438      <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa87bc53c684e7d8bde1599cb53030b468">Albany::StateStruct::ElemNode</a> :
<a name="l00439"></a>00439 
<a name="l00440"></a>00440       <span class="comment">//check if state exists in statesToCopyFrom (check first workset only)</span>
<a name="l00441"></a>00441       <span class="keywordflow">if</span>( elemStatesToCopyFrom[0].find(stateName) == elemStatesToCopyFrom[0].end() ) {
<a name="l00442"></a>00442         <span class="comment">//*out &lt;&lt; &quot;StateManager: state &quot; &lt;&lt; stateName &lt;&lt; &quot; not present, so not filled&quot; &lt;&lt; std::endl;</span>
<a name="l00443"></a>00443         <span class="keywordflow">continue</span>;
<a name="l00444"></a>00444       }
<a name="l00445"></a>00445   
<a name="l00446"></a>00446       *out &lt;&lt; <span class="stringliteral">&quot;StateManager: filling state:  &quot;</span> &lt;&lt; stateName &lt;&lt; std::endl;
<a name="l00447"></a>00447       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ws = 0; ws &lt; numElemWorksets; ws++)
<a name="l00448"></a>00448       {
<a name="l00449"></a>00449         <a class="code" href="structAlbany_1_1StateStruct.html#a822ba90a6f8529f640db1f9fac6a07bd">Albany::StateStruct::FieldDims</a> dims;
<a name="l00450"></a>00450         esa[ws][stateName].dimensions(dims);
<a name="l00451"></a>00451         <span class="keywordtype">int</span> size = dims.size();
<a name="l00452"></a>00452   
<a name="l00453"></a>00453         <span class="keywordflow">switch</span> (size) {
<a name="l00454"></a>00454         <span class="keywordflow">case</span> 1:
<a name="l00455"></a>00455     esa[ws][stateName](0) = elemStatesToCopyFrom[ws][stateName](0);
<a name="l00456"></a>00456     <span class="keywordflow">break</span>;
<a name="l00457"></a>00457         <span class="keywordflow">case</span> 2:
<a name="l00458"></a>00458     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cell = 0; cell &lt; dims[0]; ++cell)
<a name="l00459"></a>00459       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qp = 0; qp &lt; dims[1]; ++qp)
<a name="l00460"></a>00460         esa[ws][stateName](cell, qp) = elemStatesToCopyFrom[ws][stateName](cell, qp);
<a name="l00461"></a>00461     <span class="keywordflow">break</span>;
<a name="l00462"></a>00462         <span class="keywordflow">case</span> 3:
<a name="l00463"></a>00463     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cell = 0; cell &lt; dims[0]; ++cell)
<a name="l00464"></a>00464       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qp = 0; qp &lt; dims[1]; ++qp)
<a name="l00465"></a>00465         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dims[2]; ++i)
<a name="l00466"></a>00466           esa[ws][stateName](cell, qp, i) = elemStatesToCopyFrom[ws][stateName](cell, qp, i);
<a name="l00467"></a>00467     <span class="keywordflow">break</span>;
<a name="l00468"></a>00468         <span class="keywordflow">case</span> 4:
<a name="l00469"></a>00469     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cell = 0; cell &lt; dims[0]; ++cell)
<a name="l00470"></a>00470       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qp = 0; qp &lt; dims[1]; ++qp)
<a name="l00471"></a>00471         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dims[2]; ++i)
<a name="l00472"></a>00472           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; dims[3]; ++j)
<a name="l00473"></a>00473       esa[ws][stateName](cell, qp, i, j) = elemStatesToCopyFrom[ws][stateName](cell, qp, i, j);
<a name="l00474"></a>00474     <span class="keywordflow">break</span>;
<a name="l00475"></a>00475         <span class="keywordflow">default</span>:
<a name="l00476"></a>00476     TEUCHOS_TEST_FOR_EXCEPTION(size&lt;2||size&gt;4, std::logic_error,
<a name="l00477"></a>00477              <span class="stringliteral">&quot;Something is wrong during zero state variable fill: &quot;</span> &lt;&lt; size);
<a name="l00478"></a>00478         }
<a name="l00479"></a>00479      }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481      <span class="keywordflow">break</span>;
<a name="l00482"></a>00482     
<a name="l00483"></a>00483      <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa22a22a6a3084cb487d49745d467f09c9">Albany::StateStruct::NodalData</a> :
<a name="l00484"></a>00484 
<a name="l00485"></a>00485       <span class="comment">//check if state exists in statesToCopyFrom (check first workset only)</span>
<a name="l00486"></a>00486       <span class="keywordflow">if</span>( nodeStatesToCopyFrom[0].find(stateName) == nodeStatesToCopyFrom[0].end() ) {
<a name="l00487"></a>00487         <span class="comment">//*out &lt;&lt; &quot;StateManager: state &quot; &lt;&lt; stateName &lt;&lt; &quot; not present, so not filled&quot; &lt;&lt; std::endl;</span>
<a name="l00488"></a>00488         <span class="keywordflow">continue</span>;
<a name="l00489"></a>00489       }
<a name="l00490"></a>00490   
<a name="l00491"></a>00491       *out &lt;&lt; <span class="stringliteral">&quot;StateManager: filling state:  &quot;</span> &lt;&lt; stateName &lt;&lt; std::endl;
<a name="l00492"></a>00492       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ws = 0; ws &lt; numNodeWorksets; ws++){
<a name="l00493"></a>00493 
<a name="l00494"></a>00494         <a class="code" href="structAlbany_1_1StateStruct.html#a822ba90a6f8529f640db1f9fac6a07bd">Albany::StateStruct::FieldDims</a> dims;
<a name="l00495"></a>00495         nsa[ws][stateName].dimensions(dims);
<a name="l00496"></a>00496         <span class="keywordtype">int</span> size = dims.size();
<a name="l00497"></a>00497   
<a name="l00498"></a>00498         <span class="keywordflow">switch</span> (size) {
<a name="l00499"></a>00499         <span class="keywordflow">case</span> 1: <span class="comment">// node scalar</span>
<a name="l00500"></a>00500     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node = 0; node &lt; dims[0]; ++node)
<a name="l00501"></a>00501       nsa[ws][stateName](node) = nodeStatesToCopyFrom[ws][stateName](node);
<a name="l00502"></a>00502     <span class="keywordflow">break</span>;
<a name="l00503"></a>00503         <span class="keywordflow">case</span> 2: <span class="comment">// node vector</span>
<a name="l00504"></a>00504     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node = 0; node &lt; dims[0]; ++node)
<a name="l00505"></a>00505       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim = 0; dim &lt; dims[1]; ++dim)
<a name="l00506"></a>00506         nsa[ws][stateName](node, dim) = nodeStatesToCopyFrom[ws][stateName](node, dim);
<a name="l00507"></a>00507     <span class="keywordflow">break</span>;
<a name="l00508"></a>00508         <span class="keywordflow">case</span> 3: <span class="comment">// node tensor</span>
<a name="l00509"></a>00509     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node = 0; node &lt; dims[0]; ++node)
<a name="l00510"></a>00510       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim = 0; dim &lt; dims[1]; ++dim)
<a name="l00511"></a>00511         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dims[2]; ++i)
<a name="l00512"></a>00512           nsa[ws][stateName](node, dim, i) = nodeStatesToCopyFrom[ws][stateName](node, dim, i);
<a name="l00513"></a>00513     <span class="keywordflow">break</span>;
<a name="l00514"></a>00514         <span class="keywordflow">default</span>:
<a name="l00515"></a>00515     TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l00516"></a>00516              <span class="stringliteral">&quot;Something is wrong during node zero state variable fill: &quot;</span> &lt;&lt; size);
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518       }
<a name="l00519"></a>00519      <span class="keywordflow">break</span>;
<a name="l00520"></a>00520     }
<a name="l00521"></a>00521   }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   *out &lt;&lt; std::endl;
<a name="l00524"></a>00524 }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 <a class="code" href="namespaceAlbany.html#a3c1e5055e336bc01cb0e15ccf13a66ae">Albany::StateArray</a>&amp;
<a name="l00527"></a><a class="code" href="classAlbany_1_1StateManager.html#a381fbf2107547d671d58cd5d486dcb6b">00527</a> <a class="code" href="classAlbany_1_1StateManager.html#a381fbf2107547d671d58cd5d486dcb6b" title="Method to get state information for a specific workset.">Albany::StateManager::getStateArray</a>(<a class="code" href="classAlbany_1_1StateManager.html#a82d01422e30a655180ddf904aabbbfc5">SAType</a> type, <span class="keyword">const</span> <span class="keywordtype">int</span> ws)<span class="keyword"> const</span>
<a name="l00528"></a>00528 <span class="keyword"></span>{
<a name="l00529"></a>00529   TEUCHOS_TEST_FOR_EXCEPT(!<a class="code" href="classAlbany_1_1StateManager.html#aade1d726c1d61e5c0d395d6c4cf2c881" title="boolean to enforce that allocate gets called once, and after registration and befor gets...">stateVarsAreAllocated</a>);
<a name="l00530"></a>00530 
<a name="l00531"></a>00531   <span class="keywordflow">switch</span>(type){
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   <span class="keywordflow">case</span> <a class="code" href="classAlbany_1_1StateManager.html#a82d01422e30a655180ddf904aabbbfc5ad4b064528e4af87da45dac2c6a1d861c">ELEM</a>:
<a name="l00534"></a>00534     <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1StateManager.html#a284d2a5617d3ef99570a623dcb6da498" title="Discretization object which allows StateManager to perform input/output with exodus and Epetra vector...">disc</a>-&gt;getStateArrays().elemStateArrays[ws];
<a name="l00535"></a>00535     <span class="keywordflow">break</span>;
<a name="l00536"></a>00536   <span class="keywordflow">case</span> <a class="code" href="classAlbany_1_1StateManager.html#a82d01422e30a655180ddf904aabbbfc5a4fec68cd9fa2c110638c09f05a1d3ea7">NODE</a>:
<a name="l00537"></a>00537     <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1StateManager.html#a284d2a5617d3ef99570a623dcb6da498" title="Discretization object which allows StateManager to perform input/output with exodus and Epetra vector...">disc</a>-&gt;getStateArrays().nodeStateArrays[ws];
<a name="l00538"></a>00538     <span class="keywordflow">break</span>;
<a name="l00539"></a>00539   <span class="keywordflow">default</span>:
<a name="l00540"></a>00540     TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error, <span class="stringliteral">&quot;Error: Cannot match state array type in getStateArray()&quot;</span> &lt;&lt; std::endl);
<a name="l00541"></a>00541   }
<a name="l00542"></a>00542 }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 <a class="code" href="structAlbany_1_1StateArrays.html">Albany::StateArrays</a>&amp;
<a name="l00545"></a><a class="code" href="classAlbany_1_1StateManager.html#a267e5c760ffd3ecbb8ee440ab546b04f">00545</a> <a class="code" href="classAlbany_1_1StateManager.html#a267e5c760ffd3ecbb8ee440ab546b04f" title="Method to get state information for all worksets.">Albany::StateManager::getStateArrays</a>()<span class="keyword"> const</span>
<a name="l00546"></a>00546 <span class="keyword"></span>{
<a name="l00547"></a>00547   TEUCHOS_TEST_FOR_EXCEPT(!<a class="code" href="classAlbany_1_1StateManager.html#aade1d726c1d61e5c0d395d6c4cf2c881" title="boolean to enforce that allocate gets called once, and after registration and befor gets...">stateVarsAreAllocated</a>);
<a name="l00548"></a>00548   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1StateManager.html#a284d2a5617d3ef99570a623dcb6da498" title="Discretization object which allows StateManager to perform input/output with exodus and Epetra vector...">disc</a>-&gt;getStateArrays();
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="keywordtype">void</span>
<a name="l00552"></a><a class="code" href="classAlbany_1_1StateManager.html#a7810eed44117d5f23c7fbcf0e01a4346">00552</a> <a class="code" href="classAlbany_1_1StateManager.html#a7810eed44117d5f23c7fbcf0e01a4346" title="Method to make the current newState the oldState, and vice versa.">Albany::StateManager::updateStates</a>()
<a name="l00553"></a>00553 {
<a name="l00554"></a>00554   <span class="comment">// Swap boolean that defines old and new (in terms of state1 and 2) in accessors</span>
<a name="l00555"></a>00555   TEUCHOS_TEST_FOR_EXCEPT(!<a class="code" href="classAlbany_1_1StateManager.html#aade1d726c1d61e5c0d395d6c4cf2c881" title="boolean to enforce that allocate gets called once, and after registration and befor gets...">stateVarsAreAllocated</a>);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557   <span class="comment">// Get states from STK mesh </span>
<a name="l00558"></a>00558   <a class="code" href="structAlbany_1_1StateArrays.html">Albany::StateArrays</a>&amp; sa = <a class="code" href="classAlbany_1_1StateManager.html#a284d2a5617d3ef99570a623dcb6da498" title="Discretization object which allows StateManager to perform input/output with exodus and Epetra vector...">disc</a>-&gt;getStateArrays();
<a name="l00559"></a>00559   <a class="code" href="namespaceAlbany.html#a3e8c8ca3caa4ab17ad3ce87deeee3db3">Albany::StateArrayVec</a>&amp; esa = sa.<a class="code" href="structAlbany_1_1StateArrays.html#a5fa0a75997a1a3135dbd2559ad4e0e8f">elemStateArrays</a>;
<a name="l00560"></a>00560   <a class="code" href="namespaceAlbany.html#a3e8c8ca3caa4ab17ad3ce87deeee3db3">Albany::StateArrayVec</a>&amp; nsa = sa.<a class="code" href="structAlbany_1_1StateArrays.html#a93330d27ac0e1f884c7d0fae751e2741">nodeStateArrays</a>;
<a name="l00561"></a>00561   <span class="keywordtype">int</span> numElemWorksets = esa.size();
<a name="l00562"></a>00562   <span class="keywordtype">int</span> numNodeWorksets = nsa.size();
<a name="l00563"></a>00563 
<a name="l00564"></a>00564   <span class="comment">// For each workset, loop over registered states</span>
<a name="l00565"></a>00565 
<a name="l00566"></a>00566   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>-&gt;size(); i++) {
<a name="l00567"></a>00567     <span class="keywordflow">if</span> ((*<a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>)[i]-&gt;saveOldState) {
<a name="l00568"></a>00568       <span class="keyword">const</span> std::string stateName = (*stateInfo)[i]-&gt;name;
<a name="l00569"></a>00569       <span class="keyword">const</span> std::string stateName_old = stateName + <span class="stringliteral">&quot;_old&quot;</span>;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571       <span class="keywordflow">switch</span>((*<a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>)[i]-&gt;entity){
<a name="l00572"></a>00572 
<a name="l00573"></a>00573       <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702facaa3d98772a7a547b37a47bd675a634e">Albany::StateStruct::WorksetValue</a> :
<a name="l00574"></a>00574       <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa1d93caa4061e9c5dd77d1863d33447a2">Albany::StateStruct::QuadPoint</a> :
<a name="l00575"></a>00575       <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa87bc53c684e7d8bde1599cb53030b468">Albany::StateStruct::ElemNode</a> :
<a name="l00576"></a>00576   
<a name="l00577"></a>00577         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ws = 0; ws &lt; numElemWorksets; ws++)
<a name="l00578"></a>00578           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; esa[ws][stateName].size(); j++)
<a name="l00579"></a>00579             esa[ws][stateName_old][j] = esa[ws][stateName][j];
<a name="l00580"></a>00580 
<a name="l00581"></a>00581         <span class="keywordflow">break</span>;
<a name="l00582"></a>00582 
<a name="l00583"></a>00583       <span class="keywordflow">case</span> <a class="code" href="structAlbany_1_1StateStruct.html#aafb089fc73a1e846b9e4cf1ce811702fa22a22a6a3084cb487d49745d467f09c9">Albany::StateStruct::NodalData</a> :
<a name="l00584"></a>00584 
<a name="l00585"></a>00585         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ws = 0; ws &lt; numNodeWorksets; ws++)
<a name="l00586"></a>00586           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nsa[ws][stateName].size(); j++)
<a name="l00587"></a>00587             nsa[ws][stateName_old][j] = nsa[ws][stateName][j];
<a name="l00588"></a>00588 
<a name="l00589"></a>00589         <span class="keywordflow">break</span>;
<a name="l00590"></a>00590       }
<a name="l00591"></a>00591     }
<a name="l00592"></a>00592   }
<a name="l00593"></a>00593 }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 Teuchos::RCP&lt;Albany::EigendataStruct&gt; 
<a name="l00596"></a><a class="code" href="classAlbany_1_1StateManager.html#a98602efa65ed8ce7307eb6a6a88ecdb5">00596</a> <a class="code" href="classAlbany_1_1StateManager.html#a98602efa65ed8ce7307eb6a6a88ecdb5" title="Methods to get/set the EigendataStruct which holds eigenvalue / eigenvector data.">Albany::StateManager::getEigenData</a>()
<a name="l00597"></a>00597 {
<a name="l00598"></a>00598   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1StateManager.html#ab9c16cbc7378a690d623c6603536154c">eigenData</a>;
<a name="l00599"></a>00599 }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="keywordtype">void</span> 
<a name="l00602"></a><a class="code" href="classAlbany_1_1StateManager.html#aa18f5ae5d840eacc925850bb6280c232">00602</a> <a class="code" href="classAlbany_1_1StateManager.html#aa18f5ae5d840eacc925850bb6280c232">Albany::StateManager::setEigenData</a>(<span class="keyword">const</span> Teuchos::RCP&lt;Albany::EigendataStruct&gt;&amp; eigdata)
<a name="l00603"></a>00603 {
<a name="l00604"></a>00604   <a class="code" href="classAlbany_1_1StateManager.html#ab9c16cbc7378a690d623c6603536154c">eigenData</a> = eigdata;
<a name="l00605"></a>00605 }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 Teuchos::RCP&lt;Epetra_MultiVector&gt;
<a name="l00609"></a><a class="code" href="classAlbany_1_1StateManager.html#abe1113a9a4ac76d681424f64d5b1fba0">00609</a> <a class="code" href="classAlbany_1_1StateManager.html#abe1113a9a4ac76d681424f64d5b1fba0" title="Methods to get/set Auxilliary data vectors.">Albany::StateManager::getAuxData</a>()
<a name="l00610"></a>00610 {
<a name="l00611"></a>00611   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1StateManager.html#aebf1e00ae83b48ad7db19bf33d287ab1">auxData</a>;
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 <span class="keywordtype">void</span> 
<a name="l00615"></a><a class="code" href="classAlbany_1_1StateManager.html#ac89bc445ef0c703fe445295eb066b601">00615</a> <a class="code" href="classAlbany_1_1StateManager.html#ac89bc445ef0c703fe445295eb066b601">Albany::StateManager::setAuxData</a>(<span class="keyword">const</span> Teuchos::RCP&lt;Epetra_MultiVector&gt;&amp; aux_data)
<a name="l00616"></a>00616 {
<a name="l00617"></a>00617   <a class="code" href="classAlbany_1_1StateManager.html#aebf1e00ae83b48ad7db19bf33d287ab1">auxData</a> = aux_data;
<a name="l00618"></a>00618 }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 std::vector&lt;std::string&gt;
<a name="l00622"></a><a class="code" href="classAlbany_1_1StateManager.html#af6c519de968e992c75b72f1d67f9ad07">00622</a> <a class="code" href="classAlbany_1_1StateManager.html#af6c519de968e992c75b72f1d67f9ad07" title="Method to get the ResponseIDs for states which have been registered and (should) have a SaveStateFiel...">Albany::StateManager::getResidResponseIDsToRequire</a>(std::string &amp; elementBlockName)
<a name="l00623"></a>00623 {
<a name="l00624"></a>00624   std::string id, name, ebName;
<a name="l00625"></a>00625   std::vector&lt;std::string&gt; idsToRequire; 
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   <span class="keywordtype">int</span> i = 0;
<a name="l00628"></a>00628   <span class="keywordflow">for</span> (<a class="code" href="classAlbany_1_1StateInfoStruct.html#aed7c016c2064abc7f3feacfebd987530">Albany::StateInfoStruct::const_iterator</a> st = <a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>-&gt;begin(); st!= <a class="code" href="classAlbany_1_1StateManager.html#a5a09d7ad1ca4b6687870a0b8403b09c9" title="NEW WAY.">stateInfo</a>-&gt;end(); st++) {
<a name="l00629"></a>00629     name = (*st)-&gt;name;
<a name="l00630"></a>00630     <span class="keywordtype">id</span> = (*st)-&gt;responseIDtoRequire;
<a name="l00631"></a>00631     ebName = (*st)-&gt;nameMap[name];
<a name="l00632"></a>00632     <span class="keywordflow">if</span> ( <span class="keywordtype">id</span>.length() &gt; 0 &amp;&amp; ebName == elementBlockName ) {
<a name="l00633"></a>00633       idsToRequire.push_back(<span class="keywordtype">id</span>);
<a name="l00634"></a>00634 <span class="preprocessor">#ifdef ALBANY_VERBOSE      </span>
<a name="l00635"></a>00635 <span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">&quot;RRR1  &quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; requiring &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;
<a name="l00636"></a>00636 <span class="preprocessor">#endif      </span>
<a name="l00637"></a>00637 <span class="preprocessor"></span>    }
<a name="l00638"></a>00638     <span class="keywordflow">else</span> {
<a name="l00639"></a>00639 <span class="preprocessor">#ifdef ALBANY_VERBOSE      </span>
<a name="l00640"></a>00640 <span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">&quot;RRR1  &quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; empty (&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;
<a name="l00641"></a>00641 <span class="preprocessor">#endif</span>
<a name="l00642"></a>00642 <span class="preprocessor"></span>    }
<a name="l00643"></a>00643     i++;
<a name="l00644"></a>00644   }
<a name="l00645"></a>00645   <span class="keywordflow">return</span> idsToRequire;
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 26 2014 18:36:36 for Albany: a Trilinos-based PDE code by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
