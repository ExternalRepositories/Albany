<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Albany: a Trilinos-based PDE code: Albany_STKDiscretization.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>Albany_STKDiscretization.cpp</h1>  </div>
</div>
<div class="contents">
<a href="Albany__STKDiscretization_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//*****************************************************************//</span>
<a name="l00002"></a>00002 <span class="comment">//    Albany 2.0:  Copyright 2012 Sandia Corporation               //</span>
<a name="l00003"></a>00003 <span class="comment">//    This Software is released under the BSD license detailed     //</span>
<a name="l00004"></a>00004 <span class="comment">//    in the file &quot;license.txt&quot; in the top-level Albany directory  //</span>
<a name="l00005"></a>00005 <span class="comment">//*****************************************************************//</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;Epetra_Export.h&quot;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="Albany__Utils_8hpp.html">Albany_Utils.hpp</a>&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="Albany__STKDiscretization_8hpp.html">Albany_STKDiscretization.hpp</a>&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;<a class="code" href="Albany__NodalGraphUtils_8hpp.html">Albany_NodalGraphUtils.hpp</a>&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;<a class="code" href="Albany__STKNodeFieldContainer_8hpp.html">Albany_STKNodeFieldContainer.hpp</a>&quot;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;Shards_BasicTopologies.hpp&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;Shards_CellTopology.hpp&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;Shards_CellTopologyData.h&quot;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;stk_util/parallel/Parallel.hpp&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;stk_mesh/base/Entity.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;stk_mesh/base/GetEntities.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;stk_mesh/base/GetBuckets.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;stk_mesh/base/FieldData.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;stk_mesh/base/Selector.hpp&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="PHAL__Dimension_8hpp.html">PHAL_Dimension.hpp</a>&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;stk_mesh/fem/FEMHelpers.hpp&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#ifdef ALBANY_SEACAS</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#include &lt;Ionit_Initializer.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;netcdf.h&gt;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="preprocessor">#ifdef ALBANY_PAR_NETCDF</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;netcdf_par.h&gt;</span>
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 <span class="preprocessor">#endif</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;EpetraExt_MultiVectorOut.h&quot;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="Albany__STKDiscretization_8cpp.html#a43016d873124d39034edb8cd164794db">00050</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a> = 3.1415926535897932385;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">//uncomment the following line if you want debug output to be printed to screen</span>
<a name="l00053"></a>00053 <span class="comment">//#define OUTPUT_TO_SCREEN</span>
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ad7e9f3300f9f4b9fabe4d4c681bfef98">00055</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ad7e9f3300f9f4b9fabe4d4c681bfef98" title="Constructor.">Albany::STKDiscretization::STKDiscretization</a>(Teuchos::RCP&lt;Albany::AbstractSTKMeshStruct&gt; stkMeshStruct_,
<a name="l00056"></a>00056                <span class="keyword">const</span> Teuchos::RCP&lt;const Epetra_Comm&gt;&amp; comm_,
<a name="l00057"></a>00057                          <span class="keyword">const</span> Teuchos::RCP&lt;Piro::MLRigidBodyModes&gt;&amp; rigidBodyModes_) :
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   out(Teuchos::VerboseObjectBase::getDefaultOStream()),
<a name="l00060"></a>00060   previous_time_label(-1.0e32),
<a name="l00061"></a>00061   metaData(*stkMeshStruct_-&gt;metaData),
<a name="l00062"></a>00062   bulkData(*stkMeshStruct_-&gt;bulkData),
<a name="l00063"></a>00063   <a class="code" href="felix__driver_8cpp.html#ab048c6f9fcbcfaa57ce68b00263dbebe">comm</a>(comm_),
<a name="l00064"></a>00064   rigidBodyModes(rigidBodyModes_),
<a name="l00065"></a>00065   neq(stkMeshStruct_-&gt;neq),
<a name="l00066"></a>00066   <a class="code" href="InterfaceTry_8cpp.html#ab9ed82a85952e00ff0e9affddaf97c8a">stkMeshStruct</a>(stkMeshStruct_),
<a name="l00067"></a>00067   <a class="code" href="felix__driver_8cpp.html#af1beb0c410a8a48552ab0fdb5e8c49ed">interleavedOrdering</a>(stkMeshStruct_-&gt;<a class="code" href="felix__driver_8cpp.html#af1beb0c410a8a48552ab0fdb5e8c49ed">interleavedOrdering</a>)
<a name="l00068"></a>00068 {
<a name="l00069"></a>00069   <a class="code" href="classAlbany_1_1STKDiscretization.html#ad5dac2bbc4d548d84c1f0db9f7275f78" title="After mesh modification, need to update the element connectivity and nodal coordinates.">Albany::STKDiscretization::updateMesh</a>();
<a name="l00070"></a>00070 }
<a name="l00071"></a>00071 
<a name="l00072"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a0d9695651aab8cf4dd8609a3ecc13fe1">00072</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a0d9695651aab8cf4dd8609a3ecc13fe1" title="Destructor.">Albany::STKDiscretization::~STKDiscretization</a>()
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074 <span class="preprocessor">#ifdef ALBANY_SEACAS</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutput || <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutput) <span class="keyword">delete</span> mesh_data;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutput)
<a name="l00078"></a>00078     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_close (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>))
<a name="l00079"></a>00079       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l00080"></a>00080         <span class="stringliteral">&quot;close returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="preprocessor">#endif</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00084"></a>00084   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a69615d0e242ce45938412e0f0a9a3f5f">toDelete</a>.size(); i++) <span class="keyword">delete</span> [] <a class="code" href="classAlbany_1_1STKDiscretization.html#a69615d0e242ce45938412e0f0a9a3f5f">toDelete</a>[i];
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 Teuchos::RCP&lt;const Epetra_Map&gt;
<a name="l00089"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a558e6f2799d76dc0987a1021b0cc7003">00089</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a558e6f2799d76dc0987a1021b0cc7003" title="Get DOF map.">Albany::STKDiscretization::getMap</a>()<span class="keyword"> const</span>
<a name="l00090"></a>00090 <span class="keyword"></span>{
<a name="l00091"></a>00091   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a>;
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 Teuchos::RCP&lt;const Epetra_Map&gt;
<a name="l00095"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ada9947d066e36de861396c569b53e515">00095</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ada9947d066e36de861396c569b53e515" title="Get overlapped DOF map.">Albany::STKDiscretization::getOverlapMap</a>()<span class="keyword"> const</span>
<a name="l00096"></a>00096 <span class="keyword"></span>{
<a name="l00097"></a>00097   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a04c2c91bfbe73c9f62ef2b89c50a1b7d" title="Overlapped unknown map, and node map.">overlap_map</a>;
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 Teuchos::RCP&lt;const Epetra_CrsGraph&gt;
<a name="l00101"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ae10eed3bad59b167352f9a765a6decef">00101</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ae10eed3bad59b167352f9a765a6decef" title="Get Jacobian graph.">Albany::STKDiscretization::getJacobianGraph</a>()<span class="keyword"> const</span>
<a name="l00102"></a>00102 <span class="keyword"></span>{
<a name="l00103"></a>00103   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a00cd1359d5347480cb66316a158bf308" title="Jacobian matrix graph.">graph</a>;
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 Teuchos::RCP&lt;const Epetra_CrsGraph&gt;
<a name="l00107"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#afbb3a8c0b781f95d6d2a3285dabc10eb">00107</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#afbb3a8c0b781f95d6d2a3285dabc10eb" title="Get overlap Jacobian graph.">Albany::STKDiscretization::getOverlapJacobianGraph</a>()<span class="keyword"> const</span>
<a name="l00108"></a>00108 <span class="keyword"></span>{
<a name="l00109"></a>00109   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a01efaed38046489a546ec7b01c5ca12e" title="Overlapped Jacobian matrix graph.">overlap_graph</a>;
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 Teuchos::RCP&lt;const Epetra_Map&gt;
<a name="l00113"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#af3cbcd9c71deea48be8b225be9fb762b">00113</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#af3cbcd9c71deea48be8b225be9fb762b" title="Get Node map.">Albany::STKDiscretization::getNodeMap</a>()<span class="keyword"> const</span>
<a name="l00114"></a>00114 <span class="keyword"></span>{
<a name="l00115"></a>00115   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>;
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;int&gt;</a> &gt; &gt; &gt;::type&amp;
<a name="l00119"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a812e07c1175ff5445c58e9f4c58a09d7">00119</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a812e07c1175ff5445c58e9f4c58a09d7" title="Get map from (Ws, El, Local Node) -&amp;gt; NodeLID.">Albany::STKDiscretization::getWsElNodeEqID</a>()<span class="keyword"> const</span>
<a name="l00120"></a>00120 <span class="keyword"></span>{
<a name="l00121"></a>00121   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#aed47a34b5f0e43f2c840a4f0f136edc4" title="Connectivity array [workset, element, local-node, Eq] =&amp;gt; LID.">wsElNodeEqID</a>;
<a name="l00122"></a>00122 }
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;int&gt;</a> &gt; &gt;::type&amp;
<a name="l00125"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a01e66714e88f2e8619ef64e9efd470d4">00125</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a01e66714e88f2e8619ef64e9efd470d4">Albany::STKDiscretization::getWsElNodeID</a>()<span class="keyword"> const</span>
<a name="l00126"></a>00126 <span class="keyword"></span>{
<a name="l00127"></a>00127   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a34ca0bdc19e731b8185f7698e35a2aaa">wsElNodeID</a>;
<a name="l00128"></a>00128 }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double*&gt;</a> &gt; &gt;::type&amp;
<a name="l00131"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a43aa5d8a56f323265f2246767177d6d7">00131</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a43aa5d8a56f323265f2246767177d6d7">Albany::STKDiscretization::getCoords</a>()<span class="keyword"> const</span>
<a name="l00132"></a>00132 <span class="keyword"></span>{
<a name="l00133"></a>00133   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>;
<a name="l00134"></a>00134 }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double&gt;</a> &gt; &gt;::type&amp;
<a name="l00137"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ae9bf47656d4c81bea750ef17bc3f818e">00137</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ae9bf47656d4c81bea750ef17bc3f818e">Albany::STKDiscretization::getSurfaceHeight</a>()<span class="keyword"> const</span>
<a name="l00138"></a>00138 <span class="keyword"></span>{
<a name="l00139"></a>00139   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#ab394b8385f218812ded5d94d501ed4c8">sHeight</a>;
<a name="l00140"></a>00140 }
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;double&gt;</a> &gt;::type&amp;
<a name="l00143"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a9221093e4cfef2de9b6784530f89e668">00143</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a9221093e4cfef2de9b6784530f89e668">Albany::STKDiscretization::getTemperature</a>()<span class="keyword"> const</span>
<a name="l00144"></a>00144 <span class="keyword"></span>{
<a name="l00145"></a>00145   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a3c1810d25e1c0d89910df612d34876c3">temperature</a>;
<a name="l00146"></a>00146 }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double&gt;</a> &gt; &gt;::type&amp;
<a name="l00149"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#afacc771e6986ee820575f7ce7656723a">00149</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#afacc771e6986ee820575f7ce7656723a">Albany::STKDiscretization::getBasalFriction</a>()<span class="keyword"> const</span>
<a name="l00150"></a>00150 <span class="keyword"></span>{
<a name="l00151"></a>00151   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a61ab3e3a5ea6705ef21e9280c5e6c927">basalFriction</a>;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double&gt;</a> &gt; &gt;::type&amp;
<a name="l00155"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a9000ad13be917e6e334e424db6f4c21a">00155</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a9000ad13be917e6e334e424db6f4c21a">Albany::STKDiscretization::getThickness</a>()<span class="keyword"> const</span>
<a name="l00156"></a>00156 <span class="keyword"></span>{
<a name="l00157"></a>00157   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a2a64f47b4267ac116d9070727c00405a">thickness</a>;
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;double&gt;</a> &gt;::type&amp;
<a name="l00161"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#af8df8f5e2e5ff5bd027e00e92870add4">00161</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#af8df8f5e2e5ff5bd027e00e92870add4">Albany::STKDiscretization::getFlowFactor</a>()<span class="keyword"> const</span>
<a name="l00162"></a>00162 <span class="keyword"></span>{
<a name="l00163"></a>00163   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#acbd316fe62b70bb69848d4b114488bf1">flowFactor</a>;
<a name="l00164"></a>00164 }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double*&gt;</a> &gt; &gt;::type&amp;
<a name="l00167"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a434ecaa0e2ccda48590fe38942e44c43">00167</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a434ecaa0e2ccda48590fe38942e44c43">Albany::STKDiscretization::getSurfaceVelocity</a>()<span class="keyword"> const</span>
<a name="l00168"></a>00168 <span class="keyword"></span>{
<a name="l00169"></a>00169   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#af5df96321f53188bf7f61624c118bdde">surfaceVelocity</a>;
<a name="l00170"></a>00170 }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double*&gt;</a> &gt; &gt;::type&amp;
<a name="l00173"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a086e7d462918f80126ca6e244d5c0ffa">00173</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a086e7d462918f80126ca6e244d5c0ffa">Albany::STKDiscretization::getVelocityRMS</a>()<span class="keyword"> const</span>
<a name="l00174"></a>00174 <span class="keyword"></span>{
<a name="l00175"></a>00175   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#aa48c1e55a54a0101921765cec1a15da1">velocityRMS</a>;
<a name="l00176"></a>00176 }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="keywordtype">void</span>
<a name="l00179"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a6951508d76a05ebbf1715796b3e19324">00179</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a6951508d76a05ebbf1715796b3e19324" title="Print the coordinates for debugging.">Albany::STKDiscretization::printCoords</a>()<span class="keyword"> const</span>
<a name="l00180"></a>00180 <span class="keyword"></span>{
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 std::cout &lt;&lt; <span class="stringliteral">&quot;Processor &quot;</span> &lt;&lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>.parallel_rank() &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>.size() &lt;&lt; <span class="stringliteral">&quot; worksets.&quot;</span> &lt;&lt; std::endl;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ws=0; ws&lt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>.size(); ws++) {  <span class="comment">//workset</span>
<a name="l00185"></a>00185          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e=0; e&lt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[ws].size(); e++) { <span class="comment">//cell</span>
<a name="l00186"></a>00186            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[ws][e].size(); j++) { <span class="comment">//node</span>
<a name="l00187"></a>00187              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d=0; d&lt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;numDim; d++){  <span class="comment">//node</span>
<a name="l00188"></a>00188 std::cout &lt;&lt; <span class="stringliteral">&quot;Coord for workset: &quot;</span> &lt;&lt; ws &lt;&lt; <span class="stringliteral">&quot; element: &quot;</span> &lt;&lt; e &lt;&lt; <span class="stringliteral">&quot; node: &quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot; DOF: &quot;</span> &lt;&lt; d &lt;&lt; <span class="stringliteral">&quot; is: &quot;</span> &lt;&lt;
<a name="l00189"></a>00189                 <a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[ws][e][j][d] &lt;&lt; std::endl;
<a name="l00190"></a>00190        } } } }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 Teuchos::ArrayRCP&lt;double&gt;&amp;
<a name="l00196"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a1c19dcfea2dad79a0880d611159cb68a">00196</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a1c19dcfea2dad79a0880d611159cb68a" title="Retrieve coodinate vector (num_used_nodes * 3).">Albany::STKDiscretization::getCoordinates</a>()<span class="keyword"> const</span>
<a name="l00197"></a>00197 <span class="keyword"></span>{
<a name="l00198"></a>00198   <span class="comment">// Coordinates are computed here, and not precomputed,</span>
<a name="l00199"></a>00199   <span class="comment">// since the mesh can move in shape opt problems</span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#ab29b7b67367d394e0364838c6e3fcf73">AbstractSTKFieldContainer::VectorFieldType</a>* coordinates_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getCoordinatesField();
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++)  {
<a name="l00204"></a>00204     <span class="keywordtype">int</span> node_gid = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00205"></a>00205     <span class="keywordtype">int</span> node_lid = <a class="code" href="classAlbany_1_1STKDiscretization.html#add1e11b4e7887764bd677538c33a5ec1">overlap_node_map</a>-&gt;LID(node_gid);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     <span class="keywordtype">double</span>* x = stk::mesh::field_data(*coordinates_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00208"></a>00208     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dim=0; dim&lt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;numDim; dim++)
<a name="l00209"></a>00209       <a class="code" href="classAlbany_1_1STKDiscretization.html#a4975195024597f2431dc528be2dc012a">coordinates</a>[3*node_lid + dim] = x[dim];
<a name="l00210"></a>00210 
<a name="l00211"></a>00211   }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a4975195024597f2431dc528be2dc012a">coordinates</a>;
<a name="l00214"></a>00214 }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="comment">//The function transformMesh() maps a unit cube domain by applying the transformation</span>
<a name="l00217"></a>00217 <span class="comment">//x = L*x</span>
<a name="l00218"></a>00218 <span class="comment">//y = L*y</span>
<a name="l00219"></a>00219 <span class="comment">//z = s(x,y)*z + b(x,y)*(1-z)</span>
<a name="l00220"></a>00220 <span class="comment">//where b(x,y) and s(x,y) are curves specifying the bedrock and top surface</span>
<a name="l00221"></a>00221 <span class="comment">//geometries respectively.</span>
<a name="l00222"></a>00222 <span class="comment">//Currently this function is only needed for some FELIX problems.</span>
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keywordtype">void</span>
<a name="l00226"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ac14ce93957277e452addc88c1a8d8905">00226</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ac14ce93957277e452addc88c1a8d8905" title="Function that transforms an STK mesh of a unit cube (for FELIX problems).">Albany::STKDiscretization::transformMesh</a>()
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228   <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;
<a name="l00229"></a>00229   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#ab29b7b67367d394e0364838c6e3fcf73">AbstractSTKFieldContainer::VectorFieldType</a>* coordinates_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getCoordinatesField();
<a name="l00230"></a>00230   std::string transformType = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;transformType;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="keywordflow">if</span> (transformType == <span class="stringliteral">&quot;None&quot;</span>) {}
<a name="l00233"></a>00233 <span class="preprocessor">#ifdef ALBANY_FELIX</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transformType == <span class="stringliteral">&quot;ISMIP-HOM Test A&quot;</span>) {
<a name="l00235"></a>00235 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;Test A!&quot;</span> &lt;&lt; endl;
<a name="l00237"></a>00237 <span class="preprocessor">#endif</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span>    <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a05eb5b80603453716f0077228d7fcf03">L</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;felixL;
<a name="l00239"></a>00239     <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a4d08741b97fea3938089670d2a84c598">alpha</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;felixAlpha;
<a name="l00240"></a>00240 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;L: &quot;</span> &lt;&lt; L &lt;&lt; endl;
<a name="l00242"></a>00242     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;alpha degrees: &quot;</span> &lt;&lt; alpha &lt;&lt; endl;
<a name="l00243"></a>00243 <span class="preprocessor">#endif</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span>    alpha = alpha*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/180; <span class="comment">//convert alpha, read in from ParameterList, to radians</span>
<a name="l00245"></a>00245 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;alpha radians: &quot;</span> &lt;&lt; alpha &lt;&lt; endl;
<a name="l00247"></a>00247 <span class="preprocessor">#endif</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span>    <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[0]*=L;
<a name="l00249"></a>00249     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[1]*=L;
<a name="l00250"></a>00250     <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* surfaceHeight_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getSurfaceHeightField();
<a name="l00251"></a>00251     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++)  {
<a name="l00252"></a>00252       <span class="keywordtype">double</span>* x = stk::mesh::field_data(*coordinates_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00253"></a>00253       x[0] = L*x[0];
<a name="l00254"></a>00254       x[1] = L*x[1];
<a name="l00255"></a>00255       <span class="keywordtype">double</span> s = -x[0]*tan(alpha);
<a name="l00256"></a>00256       <span class="keywordtype">double</span> b = s - 1.0 + 0.5*sin(2*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/L*x[0])*sin(2*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/L*x[1]);
<a name="l00257"></a>00257       x[2] = s*x[2] + b*(1-x[2]);
<a name="l00258"></a>00258       *stk::mesh::field_data(*surfaceHeight_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]) = s;
<a name="l00259"></a>00259      }
<a name="l00260"></a>00260    }
<a name="l00261"></a>00261   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transformType == <span class="stringliteral">&quot;ISMIP-HOM Test B&quot;</span>) {
<a name="l00262"></a>00262 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;Test B!&quot;</span> &lt;&lt; endl;
<a name="l00264"></a>00264 <span class="preprocessor">#endif</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span>    <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a05eb5b80603453716f0077228d7fcf03">L</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;felixL;
<a name="l00266"></a>00266     <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a4d08741b97fea3938089670d2a84c598">alpha</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;felixAlpha;
<a name="l00267"></a>00267 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00268"></a>00268 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;L: &quot;</span> &lt;&lt; L &lt;&lt; endl;
<a name="l00269"></a>00269     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;alpha degrees: &quot;</span> &lt;&lt; alpha &lt;&lt; endl;
<a name="l00270"></a>00270 <span class="preprocessor">#endif</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span>    alpha = alpha*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/180; <span class="comment">//convert alpha, read in from ParameterList, to radians</span>
<a name="l00272"></a>00272 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;alpha radians: &quot;</span> &lt;&lt; alpha &lt;&lt; endl;
<a name="l00274"></a>00274 <span class="preprocessor">#endif</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span>    <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[0]*=L;
<a name="l00276"></a>00276     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[1]*=L;
<a name="l00277"></a>00277     <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* surfaceHeight_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getSurfaceHeightField();
<a name="l00278"></a>00278     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++)  {
<a name="l00279"></a>00279       <span class="keywordtype">double</span>* x = stk::mesh::field_data(*coordinates_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00280"></a>00280       x[0] = L*x[0];
<a name="l00281"></a>00281       x[1] = L*x[1];
<a name="l00282"></a>00282       <span class="keywordtype">double</span> s = -x[0]*tan(alpha);
<a name="l00283"></a>00283       <span class="keywordtype">double</span> b = s - 1.0 + 0.5*sin(2*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/L*x[0]);
<a name="l00284"></a>00284       x[2] = s*x[2] + b*(1-x[2]);
<a name="l00285"></a>00285       *stk::mesh::field_data(*surfaceHeight_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]) = s;
<a name="l00286"></a>00286      }
<a name="l00287"></a>00287    }
<a name="l00288"></a>00288    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((transformType == <span class="stringliteral">&quot;ISMIP-HOM Test C&quot;</span>) || (transformType == <span class="stringliteral">&quot;ISMIP-HOM Test D&quot;</span>)) {
<a name="l00289"></a>00289 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;Test C and D!&quot;</span> &lt;&lt; endl;
<a name="l00291"></a>00291 <span class="preprocessor">#endif</span>
<a name="l00292"></a>00292 <span class="preprocessor"></span>    <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a05eb5b80603453716f0077228d7fcf03">L</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;felixL;
<a name="l00293"></a>00293     <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a4d08741b97fea3938089670d2a84c598">alpha</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;felixAlpha;
<a name="l00294"></a>00294 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00295"></a>00295 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;L: &quot;</span> &lt;&lt; L &lt;&lt; endl;
<a name="l00296"></a>00296     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;alpha degrees: &quot;</span> &lt;&lt; alpha &lt;&lt; endl;
<a name="l00297"></a>00297 <span class="preprocessor">#endif</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>    alpha = alpha*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/180; <span class="comment">//convert alpha, read in from ParameterList, to radians</span>
<a name="l00299"></a>00299 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;alpha radians: &quot;</span> &lt;&lt; alpha &lt;&lt; endl;
<a name="l00301"></a>00301 <span class="preprocessor">#endif</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span>    <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[0]*=L;
<a name="l00303"></a>00303     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[1]*=L;
<a name="l00304"></a>00304     <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* surfaceHeight_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getSurfaceHeightField();
<a name="l00305"></a>00305     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++)  {
<a name="l00306"></a>00306       <span class="keywordtype">double</span>* x = stk::mesh::field_data(*coordinates_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00307"></a>00307       x[0] = L*x[0];
<a name="l00308"></a>00308       x[1] = L*x[1];
<a name="l00309"></a>00309       <span class="keywordtype">double</span> s = -x[0]*tan(alpha);
<a name="l00310"></a>00310       <span class="keywordtype">double</span> b = s - 1.0;
<a name="l00311"></a>00311       x[2] = s*x[2] + b*(1-x[2]);
<a name="l00312"></a>00312       *stk::mesh::field_data(*surfaceHeight_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]) = s;
<a name="l00313"></a>00313      }
<a name="l00314"></a>00314    }
<a name="l00315"></a>00315    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transformType == <span class="stringliteral">&quot;Dome&quot;</span>) {
<a name="l00316"></a>00316 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;Dome transform!&quot;</span> &lt;&lt; endl;
<a name="l00318"></a>00318 <span class="preprocessor">#endif</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span>    <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a05eb5b80603453716f0077228d7fcf03">L</a> = 0.7071*30;
<a name="l00320"></a>00320     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[0]*=L;
<a name="l00321"></a>00321     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[1]*=L;
<a name="l00322"></a>00322     <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* surfaceHeight_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getSurfaceHeightField();
<a name="l00323"></a>00323     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++)  {
<a name="l00324"></a>00324       <span class="keywordtype">double</span>* x = stk::mesh::field_data(*coordinates_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00325"></a>00325       x[0] = L*x[0];
<a name="l00326"></a>00326       x[1] = L*x[1];
<a name="l00327"></a>00327       <span class="keywordtype">double</span> s = 0.7071*sqrt(450.0 - x[0]*x[0] - x[1]*x[1])/sqrt(450.0);
<a name="l00328"></a>00328       x[2] = s*x[2];
<a name="l00329"></a>00329       *stk::mesh::field_data(*surfaceHeight_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]) = s;
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331   }
<a name="l00332"></a>00332    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transformType == <span class="stringliteral">&quot;Confined Shelf&quot;</span>) {
<a name="l00333"></a>00333 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00334"></a>00334 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;Confined shelf transform!&quot;</span> &lt;&lt; endl;
<a name="l00335"></a>00335 <span class="preprocessor">#endif</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span>    <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a05eb5b80603453716f0077228d7fcf03">L</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;felixL;
<a name="l00337"></a>00337     cout &lt;&lt; <span class="stringliteral">&quot;L: &quot;</span> &lt;&lt; L &lt;&lt; endl;
<a name="l00338"></a>00338     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[0]*=L;
<a name="l00339"></a>00339     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[1]*=L;
<a name="l00340"></a>00340     <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* surfaceHeight_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getSurfaceHeightField();
<a name="l00341"></a>00341     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++)  {
<a name="l00342"></a>00342       <span class="keywordtype">double</span>* x = stk::mesh::field_data(*coordinates_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00343"></a>00343       x[0] = L*x[0];
<a name="l00344"></a>00344       x[1] = L*x[1];
<a name="l00345"></a>00345       <span class="keywordtype">double</span> s = 0.06; <span class="comment">//top surface is at z=0.06km=60m</span>
<a name="l00346"></a>00346       <span class="keywordtype">double</span> b = -0.440; <span class="comment">//basal surface is at z=-0.440km=-440m</span>
<a name="l00347"></a>00347       x[2] = s*x[2] + b*(1.0-x[2]);
<a name="l00348"></a>00348       *stk::mesh::field_data(*surfaceHeight_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]) = s;
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350   }
<a name="l00351"></a>00351   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transformType == <span class="stringliteral">&quot;Circular Shelf&quot;</span>) {
<a name="l00352"></a>00352 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00353"></a>00353 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;Circular shelf transform!&quot;</span> &lt;&lt; endl;
<a name="l00354"></a>00354 <span class="preprocessor">#endif</span>
<a name="l00355"></a>00355 <span class="preprocessor"></span>    <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a05eb5b80603453716f0077228d7fcf03">L</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;felixL;
<a name="l00356"></a>00356 <span class="preprocessor">#ifdef OUTPUT_TO_SCREEN</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span>    *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;L: &quot;</span> &lt;&lt; L &lt;&lt; endl;
<a name="l00358"></a>00358 <span class="preprocessor">#endif</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span>    <span class="keywordtype">double</span> rhoIce = 910.0; <span class="comment">//ice density, in kg/m^3</span>
<a name="l00360"></a>00360     <span class="keywordtype">double</span> rhoOcean = 1028.0; <span class="comment">//ocean density, in kg/m^3</span>
<a name="l00361"></a>00361     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[0]*=L;
<a name="l00362"></a>00362     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[1]*=L;
<a name="l00363"></a>00363     <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* surfaceHeight_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getSurfaceHeightField();
<a name="l00364"></a>00364     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++)  {
<a name="l00365"></a>00365       <span class="keywordtype">double</span>* x = stk::mesh::field_data(*coordinates_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00366"></a>00366       x[0] = L*x[0];
<a name="l00367"></a>00367       x[1] = L*x[1];
<a name="l00368"></a>00368       <span class="keywordtype">double</span> s = 1.0-rhoIce/rhoOcean; <span class="comment">//top surface is at z=(1-rhoIce/rhoOcean) km</span>
<a name="l00369"></a>00369       <span class="keywordtype">double</span> b = s - 1.0; <span class="comment">//basal surface is at z=s-1 km</span>
<a name="l00370"></a>00370       x[2] = s*x[2] + b*(1.0-x[2]);
<a name="l00371"></a>00371       *stk::mesh::field_data(*surfaceHeight_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]) = s;
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373   }
<a name="l00374"></a>00374 <span class="preprocessor">#endif</span>
<a name="l00375"></a>00375 <span class="preprocessor"></span><span class="preprocessor">#ifdef ALBANY_AERAS</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transformType == <span class="stringliteral">&quot;Aeras Schar Mountain&quot;</span>) {
<a name="l00377"></a>00377     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;Aeras Schar Mountain transformation!&quot;</span> &lt;&lt; endl;
<a name="l00378"></a>00378     <span class="keywordtype">double</span> rhoOcean = 1028.0; <span class="comment">//ocean density, in kg/m^3</span>
<a name="l00379"></a>00379     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++)  {
<a name="l00380"></a>00380       <span class="keywordtype">double</span>* x = stk::mesh::field_data(*coordinates_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00381"></a>00381       x[0] = x[0];
<a name="l00382"></a>00382       <span class="keywordtype">double</span> hstar = 0.0, h;
<a name="l00383"></a>00383       <span class="keywordflow">if</span> (std::abs(x[0]-150.0) &lt;= 25.0) hstar = 3.0* std::pow(cos(M_PI*(x[0]-150.0) / 50.0),2);
<a name="l00384"></a>00384       h = hstar * std::pow(cos(M_PI*(x[0]-150.0) / 8.0),2);
<a name="l00385"></a>00385       x[1] = x[1] + h*(25.0 - x[1])/25.0;
<a name="l00386"></a>00386     }
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388 <span class="preprocessor">#endif</span>
<a name="l00389"></a>00389 <span class="preprocessor"></span>  <span class="keywordflow">else</span> {
<a name="l00390"></a>00390     TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l00391"></a>00391       <span class="stringliteral">&quot;STKDiscretization::transformMesh() Unknown transform type :&quot;</span> &lt;&lt; transformType &lt;&lt; std::endl);
<a name="l00392"></a>00392   }
<a name="l00393"></a>00393 }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="keywordtype">void</span>
<a name="l00396"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ad2b5f24655684c1e1efed7e7356b01e9">00396</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ad2b5f24655684c1e1efed7e7356b01e9" title="Process coords for ML.">Albany::STKDiscretization::setupMLCoords</a>()
<a name="l00397"></a>00397 {
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <span class="comment">// if ML is not used, return</span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a8eb6e89874b31e503d171bede7f0f9ac">rigidBodyModes</a>.is_null()) <span class="keywordflow">return</span>;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="keywordflow">if</span>(!<a class="code" href="classAlbany_1_1STKDiscretization.html#a8eb6e89874b31e503d171bede7f0f9ac">rigidBodyModes</a>-&gt;isMLUsed()) <span class="keywordflow">return</span>;
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="comment">// Function to return x,y,z at owned nodes as double*, specifically for ML</span>
<a name="l00406"></a>00406   <span class="keywordtype">int</span> numDim = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;numDim;
<a name="l00407"></a>00407   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#ab29b7b67367d394e0364838c6e3fcf73">AbstractSTKFieldContainer::VectorFieldType</a>* coordinates_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getCoordinatesField();
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <a class="code" href="classAlbany_1_1STKDiscretization.html#a8eb6e89874b31e503d171bede7f0f9ac">rigidBodyModes</a>-&gt;resize(numDim, <a class="code" href="classAlbany_1_1STKDiscretization.html#a28b66b7ed8a76eca58c7085613fd0508" title="Number of elements on this processor.">numOwnedNodes</a>);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   <span class="keywordtype">double</span> *xx;
<a name="l00412"></a>00412   <span class="keywordtype">double</span> *yy;
<a name="l00413"></a>00413   <span class="keywordtype">double</span> *zz;
<a name="l00414"></a>00414 
<a name="l00415"></a>00415   <a class="code" href="classAlbany_1_1STKDiscretization.html#a8eb6e89874b31e503d171bede7f0f9ac">rigidBodyModes</a>-&gt;getCoordArrays(&amp;xx, &amp;yy, &amp;zz);
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a28b66b7ed8a76eca58c7085613fd0508" title="Number of elements on this processor.">numOwnedNodes</a>; i++)  {
<a name="l00418"></a>00418     <span class="keywordtype">int</span> node_gid = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a4406d3d599d75ca3a41a41d85358188c" title="list of all owned nodes, saved for setting solution">ownednodes</a>[i]);
<a name="l00419"></a>00419     <span class="keywordtype">int</span> node_lid = <a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>-&gt;LID(node_gid);
<a name="l00420"></a>00420 
<a name="l00421"></a>00421     <span class="keywordtype">double</span>* X = stk::mesh::field_data(*coordinates_field, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4406d3d599d75ca3a41a41d85358188c" title="list of all owned nodes, saved for setting solution">ownednodes</a>[i]);
<a name="l00422"></a>00422     <span class="keywordflow">if</span> (numDim &gt; 0) xx[node_lid] = X[0];
<a name="l00423"></a>00423     <span class="keywordflow">if</span> (numDim &gt; 1) yy[node_lid] = X[1];
<a name="l00424"></a>00424     <span class="keywordflow">if</span> (numDim &gt; 2) zz[node_lid] = X[2];
<a name="l00425"></a>00425   }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 
<a name="l00428"></a>00428   <span class="comment">//see if user wants to write the coordinates to matrix market file</span>
<a name="l00429"></a>00429   <span class="keywordtype">bool</span> writeCoordsToMMFile = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;writeCoordsToMMFile;
<a name="l00430"></a>00430   <span class="comment">//if user wants to write the coordinates to matrix market file, write them to matrix market file</span>
<a name="l00431"></a>00431   <span class="keywordflow">if</span> (writeCoordsToMMFile == <span class="keyword">true</span>) {
<a name="l00432"></a>00432     <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>-&gt;Comm().MyPID()==0) {std::cout &lt;&lt; <span class="stringliteral">&quot;Writing mesh coordinates to Matrix Market file.&quot;</span> &lt;&lt; std::endl;}
<a name="l00433"></a>00433     <span class="comment">//Writing of coordinates to MatrixMarket file for Ray</span>
<a name="l00434"></a>00434     Epetra_Vector xCoords(Copy, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>, xx);
<a name="l00435"></a>00435     EpetraExt::MultiVectorToMatrixMarketFile(<span class="stringliteral">&quot;xCoords.mm&quot;</span>, xCoords);
<a name="l00436"></a>00436     <span class="keywordflow">if</span> (yy != NULL) {
<a name="l00437"></a>00437       Epetra_Vector yCoords(Copy, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>, yy);
<a name="l00438"></a>00438       EpetraExt::MultiVectorToMatrixMarketFile(<span class="stringliteral">&quot;yCoords.mm&quot;</span>, yCoords);
<a name="l00439"></a>00439     }
<a name="l00440"></a>00440     <span class="keywordflow">if</span> (zz != NULL){
<a name="l00441"></a>00441       Epetra_Vector zCoords(Copy, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>, zz);
<a name="l00442"></a>00442       EpetraExt::MultiVectorToMatrixMarketFile(<span class="stringliteral">&quot;zCoords.mm&quot;</span>, zCoords);
<a name="l00443"></a>00443     }
<a name="l00444"></a>00444   }
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   <a class="code" href="classAlbany_1_1STKDiscretization.html#a8eb6e89874b31e503d171bede7f0f9ac">rigidBodyModes</a>-&gt;informML();
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html#a2251678748f133c70ad2b97345319967">Albany::WorksetArray&lt;std::string&gt;::type</a>&amp;
<a name="l00452"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a3f2583bc2b17c2a2fb62ca9a4a1a5298">00452</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a3f2583bc2b17c2a2fb62ca9a4a1a5298" title="Retrieve Vector (length num worksets) of element block names.">Albany::STKDiscretization::getWsEBNames</a>()<span class="keyword"> const</span>
<a name="l00453"></a>00453 <span class="keyword"></span>{
<a name="l00454"></a>00454   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a31fce9e12eb182345cc1d514c212bee7">wsEBNames</a>;
<a name="l00455"></a>00455 }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457 <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html#a2251678748f133c70ad2b97345319967">Albany::WorksetArray&lt;int&gt;::type</a>&amp;
<a name="l00458"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a7e1ed26317e9ad74dd8eb69853e15b8a">00458</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a7e1ed26317e9ad74dd8eb69853e15b8a" title="Retrieve Vector (length num worksets) of physics set index.">Albany::STKDiscretization::getWsPhysIndex</a>()<span class="keyword"> const</span>
<a name="l00459"></a>00459 <span class="keyword"></span>{
<a name="l00460"></a>00460   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a7d5f924a774a1336aeb4e89b3520e07e">wsPhysIndex</a>;
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 <span class="comment">//void Albany::STKDiscretization::outputToExodus(const Epetra_Vector&amp; soln, const double time, const bool overlapped)</span>
<a name="l00464"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a004b2f37eea0f9c93abecef09db3c52f">00464</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a004b2f37eea0f9c93abecef09db3c52f" title="Write the solution to the output file.">Albany::STKDiscretization::writeSolution</a>(<span class="keyword">const</span> Epetra_Vector&amp; soln, <span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">bool</span> overlapped){
<a name="l00465"></a>00465 
<a name="l00466"></a>00466   <span class="comment">// Put solution as Epetra_Vector into STK Mesh</span>
<a name="l00467"></a>00467   <span class="keywordflow">if</span>(!overlapped)
<a name="l00468"></a>00468 
<a name="l00469"></a>00469     <a class="code" href="classAlbany_1_1STKDiscretization.html#a8b4619518fac1976d61afcc558e98af7">setSolutionField</a>(soln);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   <span class="comment">// soln coming in is overlapped</span>
<a name="l00472"></a>00472   <span class="keywordflow">else</span>
<a name="l00473"></a>00473 
<a name="l00474"></a>00474     <a class="code" href="classAlbany_1_1STKDiscretization.html#ac6b821bad8dcb7f7c225df80b4b0430e">setOvlpSolutionField</a>(soln);
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="preprocessor">#ifdef ALBANY_SEACAS</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span>
<a name="l00479"></a>00479   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutput &amp;&amp; <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;transferSolutionToCoords) {
<a name="l00480"></a>00480 
<a name="l00481"></a>00481    Teuchos::RCP&lt;AbstractSTKFieldContainer&gt; container = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer();
<a name="l00482"></a>00482 
<a name="l00483"></a>00483    container-&gt;transferSolutionToCoords();
<a name="l00484"></a>00484 
<a name="l00485"></a>00485    <span class="keywordflow">if</span> (mesh_data != NULL) {
<a name="l00486"></a>00486 
<a name="l00487"></a>00487      <span class="comment">// Mesh coordinates have changed. Rewrite output file by deleting the mesh data object and recreate it</span>
<a name="l00488"></a>00488      <span class="keyword">delete</span> mesh_data;
<a name="l00489"></a>00489      <a class="code" href="classAlbany_1_1STKDiscretization.html#a5970626a8f7747d0ecf05ed16abfeffd" title="Call stk_io for creating exodus output file.">setupExodusOutput</a>();
<a name="l00490"></a>00490 
<a name="l00491"></a>00491    }
<a name="l00492"></a>00492   }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 
<a name="l00495"></a>00495    <span class="comment">// Skip this write unless the proper interval has been reached</span>
<a name="l00496"></a>00496   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutput &amp;&amp; !(outputInterval % <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutputInterval)) {
<a name="l00497"></a>00497 
<a name="l00498"></a>00498      <span class="keywordtype">double</span> time_label = <a class="code" href="classAlbany_1_1STKDiscretization.html#a28d3e10e6a048a2823ddffb281ebd9d9">monotonicTimeLabel</a>(time);
<a name="l00499"></a>00499 
<a name="l00500"></a>00500      <span class="keywordtype">int</span> out_step = stk::io::process_output_request(*mesh_data, <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>, time_label);
<a name="l00501"></a>00501 
<a name="l00502"></a>00502      <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a>-&gt;Comm().MyPID()==0) {
<a name="l00503"></a>00503        *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;Albany::STKDiscretization::writeSolution: writing time &quot;</span> &lt;&lt; time;
<a name="l00504"></a>00504        <span class="keywordflow">if</span> (time_label != time) *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot; with label &quot;</span> &lt;&lt; time_label;
<a name="l00505"></a>00505        *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot; to index &quot;</span> &lt;&lt;out_step&lt;&lt;<span class="stringliteral">&quot; in file &quot;</span>&lt;&lt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutFile&lt;&lt; std::endl;
<a name="l00506"></a>00506      }
<a name="l00507"></a>00507   }
<a name="l00508"></a>00508   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutput &amp;&amp; !(outputInterval % <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutputInterval)) {
<a name="l00509"></a>00509 
<a name="l00510"></a>00510      <span class="keywordtype">double</span> time_label = <a class="code" href="classAlbany_1_1STKDiscretization.html#a28d3e10e6a048a2823ddffb281ebd9d9">monotonicTimeLabel</a>(time);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512      <span class="keyword">const</span> <span class="keywordtype">int</span> out_step = <a class="code" href="classAlbany_1_1STKDiscretization.html#a1a37ea93a6d4fad70894143f5b9141be">processNetCDFOutputRequest</a>();
<a name="l00513"></a>00513 
<a name="l00514"></a>00514      <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a>-&gt;Comm().MyPID()==0) {
<a name="l00515"></a>00515        *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;Albany::STKDiscretization::writeSolution: writing time &quot;</span> &lt;&lt; time;
<a name="l00516"></a>00516        <span class="keywordflow">if</span> (time_label != time) *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot; with label &quot;</span> &lt;&lt; time_label;
<a name="l00517"></a>00517        *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot; to index &quot;</span> &lt;&lt;out_step&lt;&lt;<span class="stringliteral">&quot; in file &quot;</span>&lt;&lt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutFile&lt;&lt; std::endl;
<a name="l00518"></a>00518      }
<a name="l00519"></a>00519   }
<a name="l00520"></a>00520   outputInterval++;
<a name="l00521"></a>00521 <span class="preprocessor">#endif</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span>}
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 <span class="keywordtype">double</span>
<a name="l00525"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a28d3e10e6a048a2823ddffb281ebd9d9">00525</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a28d3e10e6a048a2823ddffb281ebd9d9">Albany::STKDiscretization::monotonicTimeLabel</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> time)
<a name="l00526"></a>00526 {
<a name="l00527"></a>00527   <span class="comment">// If increasing, then all is good</span>
<a name="l00528"></a>00528   <span class="keywordflow">if</span> (time &gt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a2134cc877988853876df2d5446568d94">previous_time_label</a>) {
<a name="l00529"></a>00529     <a class="code" href="classAlbany_1_1STKDiscretization.html#a2134cc877988853876df2d5446568d94">previous_time_label</a> = time;
<a name="l00530"></a>00530     <span class="keywordflow">return</span> time;
<a name="l00531"></a>00531   }
<a name="l00532"></a>00532 <span class="comment">// Try absolute value</span>
<a name="l00533"></a>00533   <span class="keywordtype">double</span> time_label = fabs(time);
<a name="l00534"></a>00534   <span class="keywordflow">if</span> (time_label &gt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a2134cc877988853876df2d5446568d94">previous_time_label</a>) {
<a name="l00535"></a>00535     <a class="code" href="classAlbany_1_1STKDiscretization.html#a2134cc877988853876df2d5446568d94">previous_time_label</a> = time_label;
<a name="l00536"></a>00536     <span class="keywordflow">return</span> time_label;
<a name="l00537"></a>00537   }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   <span class="comment">// Try adding 1.0 to time</span>
<a name="l00540"></a>00540   <span class="keywordflow">if</span> (time_label+1.0 &gt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a2134cc877988853876df2d5446568d94">previous_time_label</a>) {
<a name="l00541"></a>00541     <a class="code" href="classAlbany_1_1STKDiscretization.html#a2134cc877988853876df2d5446568d94">previous_time_label</a> = time_label+1.0;
<a name="l00542"></a>00542     <span class="keywordflow">return</span> time_label+1.0;
<a name="l00543"></a>00543   }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="comment">// Otherwise, just add 1.0 to previous</span>
<a name="l00546"></a>00546   <a class="code" href="classAlbany_1_1STKDiscretization.html#a2134cc877988853876df2d5446568d94">previous_time_label</a> += 1.0;
<a name="l00547"></a>00547   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a2134cc877988853876df2d5446568d94">previous_time_label</a>;
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="keywordtype">void</span>
<a name="l00551"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a3f26f7703afe921fe808d354d3f4cc53">00551</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a3f26f7703afe921fe808d354d3f4cc53" title="Set the residual field for output.">Albany::STKDiscretization::setResidualField</a>(<span class="keyword">const</span> Epetra_Vector&amp; residual)
<a name="l00552"></a>00552 {
<a name="l00553"></a>00553 <span class="preprocessor">#ifdef ALBANY_LCM</span>
<a name="l00554"></a>00554 <span class="preprocessor"></span>  Teuchos::RCP&lt;AbstractSTKFieldContainer&gt; container = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer();
<a name="l00555"></a>00555 
<a name="l00556"></a>00556   <span class="keywordflow">if</span>(container-&gt;hasResidualField()){
<a name="l00557"></a>00557 
<a name="l00558"></a>00558     <span class="comment">// Iterate over the on-processor nodes</span>
<a name="l00559"></a>00559     stk::mesh::Selector locally_owned = <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part();
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     container-&gt;saveResVector(residual, locally_owned, <a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>);
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     <span class="comment">// Write the overlapped data</span>
<a name="l00564"></a>00564 <span class="comment">//    stk::mesh::Selector select_owned_or_shared = metaData.locally_owned_part() | metaData.globally_shared_part();</span>
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 <span class="comment">//    container-&gt;saveResVector(residual, select_owned_or_shared, overlap_node_map);</span>
<a name="l00567"></a>00567   }
<a name="l00568"></a>00568 <span class="preprocessor">#endif</span>
<a name="l00569"></a>00569 <span class="preprocessor"></span>}
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 Teuchos::RCP&lt;Epetra_Vector&gt;
<a name="l00572"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ae813d58d74cedc64d0bfc59f2558d49d">00572</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ae813d58d74cedc64d0bfc59f2558d49d" title="Get solution vector from mesh database.">Albany::STKDiscretization::getSolutionField</a>()<span class="keyword"> const</span>
<a name="l00573"></a>00573 <span class="keyword"></span>{
<a name="l00574"></a>00574   <span class="comment">// Copy soln vector into solution field, one node at a time</span>
<a name="l00575"></a>00575   Teuchos::RCP&lt;Epetra_Vector&gt; soln = Teuchos::rcp(<span class="keyword">new</span> Epetra_Vector(*<a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a>));
<a name="l00576"></a>00576   this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#ae813d58d74cedc64d0bfc59f2558d49d" title="Get solution vector from mesh database.">getSolutionField</a>(*soln);
<a name="l00577"></a>00577   <span class="keywordflow">return</span> soln;
<a name="l00578"></a>00578 }
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 <span class="keywordtype">int</span>
<a name="l00581"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a682d2fd027084c82acf9c4beca64c847">00581</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a682d2fd027084c82acf9c4beca64c847">Albany::STKDiscretization::getSolutionFieldHistoryDepth</a>()<span class="keyword"> const</span>
<a name="l00582"></a>00582 <span class="keyword"></span>{
<a name="l00583"></a>00583   <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getSolutionFieldHistoryDepth();
<a name="l00584"></a>00584 }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586 Teuchos::RCP&lt;Epetra_MultiVector&gt;
<a name="l00587"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a9732f44435fc42b4546b5aa3b61d2b04">00587</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a9732f44435fc42b4546b5aa3b61d2b04">Albany::STKDiscretization::getSolutionFieldHistory</a>()<span class="keyword"> const</span>
<a name="l00588"></a>00588 <span class="keyword"></span>{
<a name="l00589"></a>00589   <span class="keyword">const</span> <span class="keywordtype">int</span> stepCount = this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a682d2fd027084c82acf9c4beca64c847">getSolutionFieldHistoryDepth</a>();
<a name="l00590"></a>00590   <span class="keywordflow">return</span> this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a61cc50e341c9fb32ec1282d813a192ea">getSolutionFieldHistoryImpl</a>(stepCount);
<a name="l00591"></a>00591 }
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 Teuchos::RCP&lt;Epetra_MultiVector&gt;
<a name="l00594"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ab4cf9f563165f8dd09e1643ef503232c">00594</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a9732f44435fc42b4546b5aa3b61d2b04">Albany::STKDiscretization::getSolutionFieldHistory</a>(<span class="keywordtype">int</span> maxStepCount)<span class="keyword"> const</span>
<a name="l00595"></a>00595 <span class="keyword"></span>{
<a name="l00596"></a>00596   <span class="keyword">const</span> <span class="keywordtype">int</span> stepCount = std::min(this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a682d2fd027084c82acf9c4beca64c847">getSolutionFieldHistoryDepth</a>(), maxStepCount);
<a name="l00597"></a>00597   <span class="keywordflow">return</span> this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a61cc50e341c9fb32ec1282d813a192ea">getSolutionFieldHistoryImpl</a>(stepCount);
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="keywordtype">void</span>
<a name="l00601"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a16d6d23e073f5d878f8eaad94c1d2c16">00601</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a9732f44435fc42b4546b5aa3b61d2b04">Albany::STKDiscretization::getSolutionFieldHistory</a>(Epetra_MultiVector &amp;result)<span class="keyword"> const</span>
<a name="l00602"></a>00602 <span class="keyword"></span>{
<a name="l00603"></a>00603   TEUCHOS_TEST_FOR_EXCEPT(!this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a>-&gt;SameAs(result.Map()));
<a name="l00604"></a>00604   <span class="keyword">const</span> <span class="keywordtype">int</span> stepCount = std::min(this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a682d2fd027084c82acf9c4beca64c847">getSolutionFieldHistoryDepth</a>(), result.NumVectors());
<a name="l00605"></a>00605   Epetra_MultiVector head(View, result, 0, stepCount);
<a name="l00606"></a>00606   this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a61cc50e341c9fb32ec1282d813a192ea">getSolutionFieldHistoryImpl</a>(head);
<a name="l00607"></a>00607 }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 Teuchos::RCP&lt;Epetra_MultiVector&gt;
<a name="l00610"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a61cc50e341c9fb32ec1282d813a192ea">00610</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a61cc50e341c9fb32ec1282d813a192ea">Albany::STKDiscretization::getSolutionFieldHistoryImpl</a>(<span class="keywordtype">int</span> stepCount)<span class="keyword"> const</span>
<a name="l00611"></a>00611 <span class="keyword"></span>{
<a name="l00612"></a>00612   <span class="keyword">const</span> <span class="keywordtype">int</span> vectorCount = stepCount &gt; 0 ? stepCount : 1; <span class="comment">// A valid MultiVector has at least one vector</span>
<a name="l00613"></a>00613   <span class="keyword">const</span> Teuchos::RCP&lt;Epetra_MultiVector&gt; result = Teuchos::rcp(<span class="keyword">new</span> Epetra_MultiVector(*<a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a>, vectorCount));
<a name="l00614"></a>00614   <span class="keywordflow">if</span> (stepCount &gt; 0) {
<a name="l00615"></a>00615     this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a61cc50e341c9fb32ec1282d813a192ea">getSolutionFieldHistoryImpl</a>(*result);
<a name="l00616"></a>00616   }
<a name="l00617"></a>00617   <span class="keywordflow">return</span> result;
<a name="l00618"></a>00618 }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <span class="keywordtype">void</span>
<a name="l00621"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#abec262b446663e4e382d08b2fcf06cf2">00621</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a61cc50e341c9fb32ec1282d813a192ea">Albany::STKDiscretization::getSolutionFieldHistoryImpl</a>(Epetra_MultiVector &amp;result)<span class="keyword"> const</span>
<a name="l00622"></a>00622 <span class="keyword"></span>{
<a name="l00623"></a>00623   <span class="keyword">const</span> <span class="keywordtype">int</span> stepCount = result.NumVectors();
<a name="l00624"></a>00624   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; stepCount; ++i) {
<a name="l00625"></a>00625     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;loadSolutionFieldHistory(i);
<a name="l00626"></a>00626     Epetra_Vector v(View, result, i);
<a name="l00627"></a>00627     this-&gt;<a class="code" href="classAlbany_1_1STKDiscretization.html#ae813d58d74cedc64d0bfc59f2558d49d" title="Get solution vector from mesh database.">getSolutionField</a>(v);
<a name="l00628"></a>00628   }
<a name="l00629"></a>00629 }
<a name="l00630"></a>00630 
<a name="l00631"></a>00631 <span class="keywordtype">void</span>
<a name="l00632"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ae0ccd2ccfad52e97f80a9d67cbc0f8ac">00632</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ae813d58d74cedc64d0bfc59f2558d49d" title="Get solution vector from mesh database.">Albany::STKDiscretization::getSolutionField</a>(Epetra_Vector &amp;result)<span class="keyword"> const</span>
<a name="l00633"></a>00633 <span class="keyword"></span>{
<a name="l00634"></a>00634 
<a name="l00635"></a>00635   Teuchos::RCP&lt;AbstractSTKFieldContainer&gt; container = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer();
<a name="l00636"></a>00636 
<a name="l00637"></a>00637   <span class="comment">// Iterate over the on-processor nodes by getting node buckets and iterating over each bucket.</span>
<a name="l00638"></a>00638   stk::mesh::Selector locally_owned = <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part();
<a name="l00639"></a>00639 
<a name="l00640"></a>00640   container-&gt;fillSolnVector(result, locally_owned, <a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>);
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 <span class="comment">/*****************************************************************/</span>
<a name="l00645"></a>00645 <span class="comment">/*** Private functions follow. These are just used in above code */</span>
<a name="l00646"></a>00646 <span class="comment">/*****************************************************************/</span>
<a name="l00647"></a>00647 
<a name="l00648"></a>00648 <span class="keywordtype">void</span>
<a name="l00649"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a8b4619518fac1976d61afcc558e98af7">00649</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a8b4619518fac1976d61afcc558e98af7">Albany::STKDiscretization::setSolutionField</a>(<span class="keyword">const</span> Epetra_Vector&amp; soln)
<a name="l00650"></a>00650 {
<a name="l00651"></a>00651   <span class="comment">// Copy soln vector into solution field, one node at a time</span>
<a name="l00652"></a>00652   <span class="comment">// Note that soln coming in is the local (non overlapped) soln</span>
<a name="l00653"></a>00653 
<a name="l00654"></a>00654   Teuchos::RCP&lt;AbstractSTKFieldContainer&gt; container = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer();
<a name="l00655"></a>00655 
<a name="l00656"></a>00656   <span class="comment">// Iterate over the on-processor nodes</span>
<a name="l00657"></a>00657   stk::mesh::Selector locally_owned = <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part();
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   container-&gt;saveSolnVector(soln, locally_owned, <a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>);
<a name="l00660"></a>00660 
<a name="l00661"></a>00661 }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 <span class="keywordtype">void</span>
<a name="l00664"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ac6b821bad8dcb7f7c225df80b4b0430e">00664</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ac6b821bad8dcb7f7c225df80b4b0430e">Albany::STKDiscretization::setOvlpSolutionField</a>(<span class="keyword">const</span> Epetra_Vector&amp; soln)
<a name="l00665"></a>00665 {
<a name="l00666"></a>00666   <span class="comment">// Copy soln vector into solution field, one node at a time</span>
<a name="l00667"></a>00667   <span class="comment">// Note that soln coming in is the local+ghost (overlapped) soln</span>
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   Teuchos::RCP&lt;AbstractSTKFieldContainer&gt; container = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer();
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <span class="comment">// Iterate over the processor-visible nodes</span>
<a name="l00672"></a>00672   stk::mesh::Selector select_owned_or_shared = <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part() | <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.globally_shared_part();
<a name="l00673"></a>00673 
<a name="l00674"></a>00674   container-&gt;saveSolnVector(soln, select_owned_or_shared, <a class="code" href="classAlbany_1_1STKDiscretization.html#add1e11b4e7887764bd677538c33a5ec1">overlap_node_map</a>);
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 }
<a name="l00677"></a>00677 
<a name="l00678"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">00678</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">Albany::STKDiscretization::gid</a>(<span class="keyword">const</span> <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>&amp; node)<span class="keyword"> const</span>
<a name="l00679"></a>00679 <span class="keyword"></span>{ <span class="keywordflow">return</span> node.identifier()-1; }
<a name="l00680"></a>00680 
<a name="l00681"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a15a2b5a0fbb4105df168474400915906">00681</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">Albany::STKDiscretization::gid</a>(<span class="keyword">const</span> <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>* node)<span class="keyword"> const</span>
<a name="l00682"></a>00682 <span class="keyword"></span>{ <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(*node); }
<a name="l00683"></a>00683 
<a name="l00684"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#aaee464f8a7390571d4d9b2090d30c588">00684</a> <span class="keywordtype">int</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#aaee464f8a7390571d4d9b2090d30c588" title="Locate nodal dofs in non-overlapping vectors using local indexing.">Albany::STKDiscretization::getOwnedDOF</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> inode, <span class="keyword">const</span> <span class="keywordtype">int</span> eq)<span class="keyword"> const</span>
<a name="l00685"></a>00685 <span class="keyword"></span>{
<a name="l00686"></a>00686   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a89f42ebdf9f2854dc08c284298c09c3e">interleavedOrdering</a>) <span class="keywordflow">return</span> inode*<a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a> + eq;
<a name="l00687"></a>00687   <span class="keywordflow">else</span>  <span class="keywordflow">return</span> inode + <a class="code" href="classAlbany_1_1STKDiscretization.html#a28b66b7ed8a76eca58c7085613fd0508" title="Number of elements on this processor.">numOwnedNodes</a>*eq;
<a name="l00688"></a>00688 }
<a name="l00689"></a>00689 
<a name="l00690"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a04d345896b258962f4975aa0f36e173a">00690</a> <span class="keywordtype">int</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a04d345896b258962f4975aa0f36e173a" title="Locate nodal dofs in overlapping vectors using local indexing.">Albany::STKDiscretization::getOverlapDOF</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> inode, <span class="keyword">const</span> <span class="keywordtype">int</span> eq)<span class="keyword"> const</span>
<a name="l00691"></a>00691 <span class="keyword"></span>{
<a name="l00692"></a>00692   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a89f42ebdf9f2854dc08c284298c09c3e">interleavedOrdering</a>) <span class="keywordflow">return</span> inode*<a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a> + eq;
<a name="l00693"></a>00693   <span class="keywordflow">else</span>  <span class="keywordflow">return</span> inode + <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>*eq;
<a name="l00694"></a>00694 }
<a name="l00695"></a>00695 
<a name="l00696"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a4aa3b5f66486b51fb025f4157e2f76e5">00696</a> <span class="keywordtype">int</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a4aa3b5f66486b51fb025f4157e2f76e5" title="Locate nodal dofs using global indexing.">Albany::STKDiscretization::getGlobalDOF</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> inode, <span class="keyword">const</span> <span class="keywordtype">int</span> eq)<span class="keyword"> const</span>
<a name="l00697"></a>00697 <span class="keyword"></span>{
<a name="l00698"></a>00698   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a89f42ebdf9f2854dc08c284298c09c3e">interleavedOrdering</a>) <span class="keywordflow">return</span> inode*<a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a> + eq;
<a name="l00699"></a>00699   <span class="keywordflow">else</span>  <span class="keywordflow">return</span> inode + <a class="code" href="classAlbany_1_1STKDiscretization.html#a7cc9e8b38ec674a93482ff2193b9bd79">numGlobalNodes</a>*eq;
<a name="l00700"></a>00700 }
<a name="l00701"></a>00701 
<a name="l00702"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a53b7ecd8e2c8f56ba98632a2e106042b">00702</a> <span class="keywordtype">int</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a53b7ecd8e2c8f56ba98632a2e106042b">Albany::STKDiscretization::nonzeroesPerRow</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> neq)<span class="keyword"> const</span>
<a name="l00703"></a>00703 <span class="keyword"></span>{
<a name="l00704"></a>00704   <span class="keywordtype">int</span> numDim = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;numDim;
<a name="l00705"></a>00705   <span class="keywordtype">int</span> estNonzeroesPerRow;
<a name="l00706"></a>00706   <span class="keywordflow">switch</span> (numDim) {
<a name="l00707"></a>00707   <span class="keywordflow">case</span> 0: estNonzeroesPerRow=1*neq; <span class="keywordflow">break</span>;
<a name="l00708"></a>00708   <span class="keywordflow">case</span> 1: estNonzeroesPerRow=3*neq; <span class="keywordflow">break</span>;
<a name="l00709"></a>00709   <span class="keywordflow">case</span> 2: estNonzeroesPerRow=9*neq; <span class="keywordflow">break</span>;
<a name="l00710"></a>00710   <span class="keywordflow">case</span> 3: estNonzeroesPerRow=27*neq; <span class="keywordflow">break</span>;
<a name="l00711"></a>00711   <span class="keywordflow">default</span>: TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l00712"></a>00712             <span class="stringliteral">&quot;STKDiscretization:  Bad numDim&quot;</span>&lt;&lt; numDim);
<a name="l00713"></a>00713   }
<a name="l00714"></a>00714   <span class="keywordflow">return</span> estNonzeroesPerRow;
<a name="l00715"></a>00715 }
<a name="l00716"></a>00716 
<a name="l00717"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#afbf76c212116f67eaedc9bfb2c3c1464">00717</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#afbf76c212116f67eaedc9bfb2c3c1464" title="Process STK mesh for Owned nodal quantitites.">Albany::STKDiscretization::computeOwnedNodesAndUnknowns</a>()
<a name="l00718"></a>00718 {
<a name="l00719"></a>00719   <span class="comment">// Loads member data:  ownednodes, numOwnedNodes, node_map, numGlobalNodes, map</span>
<a name="l00720"></a>00720   <span class="comment">// maps for owned nodes and unknowns</span>
<a name="l00721"></a>00721   stk::mesh::Selector select_owned_in_part =
<a name="l00722"></a>00722     stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.universal_part() ) &amp;
<a name="l00723"></a>00723     stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part() );
<a name="l00724"></a>00724 
<a name="l00725"></a>00725   stk::mesh::get_selected_entities( select_owned_in_part ,
<a name="l00726"></a>00726             <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>.buckets( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.node_rank() ) ,
<a name="l00727"></a>00727             <a class="code" href="classAlbany_1_1STKDiscretization.html#a4406d3d599d75ca3a41a41d85358188c" title="list of all owned nodes, saved for setting solution">ownednodes</a> );
<a name="l00728"></a>00728 
<a name="l00729"></a>00729   <a class="code" href="classAlbany_1_1STKDiscretization.html#a28b66b7ed8a76eca58c7085613fd0508" title="Number of elements on this processor.">numOwnedNodes</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a4406d3d599d75ca3a41a41d85358188c" title="list of all owned nodes, saved for setting solution">ownednodes</a>.size();
<a name="l00730"></a>00730   std::vector&lt;int&gt; indices(<a class="code" href="classAlbany_1_1STKDiscretization.html#a28b66b7ed8a76eca58c7085613fd0508" title="Number of elements on this processor.">numOwnedNodes</a>);
<a name="l00731"></a>00731   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a28b66b7ed8a76eca58c7085613fd0508" title="Number of elements on this processor.">numOwnedNodes</a>; i++) 
<a name="l00732"></a>00732 
<a name="l00733"></a>00733     indices[i] = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a4406d3d599d75ca3a41a41d85358188c" title="list of all owned nodes, saved for setting solution">ownednodes</a>[i]);
<a name="l00734"></a>00734 
<a name="l00735"></a>00735   <a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a> = Teuchos::null; <span class="comment">// delete existing map happens here on remesh</span>
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   <a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a> = Teuchos::rcp(<span class="keyword">new</span> Epetra_Map(-1, numOwnedNodes,
<a name="l00738"></a>00738            &amp;(indices[0]), 0, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a8f1060bd41ba7b2904cbabb0cac84455" title="Epetra communicator.">comm</a>));
<a name="l00739"></a>00739 
<a name="l00740"></a>00740   <a class="code" href="classAlbany_1_1STKDiscretization.html#a7cc9e8b38ec674a93482ff2193b9bd79">numGlobalNodes</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>-&gt;MaxAllGID() + 1;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742   <span class="keywordflow">if</span>(Teuchos::nonnull(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nodal_data_block))
<a name="l00743"></a>00743     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nodal_data_block-&gt;resizeLocalMap(indices, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a8f1060bd41ba7b2904cbabb0cac84455" title="Epetra communicator.">comm</a>);
<a name="l00744"></a>00744 
<a name="l00745"></a>00745   indices.resize(numOwnedNodes * <a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a>);
<a name="l00746"></a>00746   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; numOwnedNodes; i++)
<a name="l00747"></a>00747     <span class="keywordflow">for</span> (std::size_t j=0; j &lt; neq; j++)
<a name="l00748"></a>00748       indices[<a class="code" href="classAlbany_1_1STKDiscretization.html#aaee464f8a7390571d4d9b2090d30c588" title="Locate nodal dofs in non-overlapping vectors using local indexing.">getOwnedDOF</a>(i,j)] = <a class="code" href="classAlbany_1_1STKDiscretization.html#a4aa3b5f66486b51fb025f4157e2f76e5" title="Locate nodal dofs using global indexing.">getGlobalDOF</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a4406d3d599d75ca3a41a41d85358188c" title="list of all owned nodes, saved for setting solution">ownednodes</a>[i]),j);
<a name="l00749"></a>00749 
<a name="l00750"></a>00750   <a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a> = Teuchos::null; <span class="comment">// delete existing map happens here on remesh</span>
<a name="l00751"></a>00751 
<a name="l00752"></a>00752   <a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a> = Teuchos::rcp(<span class="keyword">new</span> Epetra_Map(-1, indices.size(), &amp;(indices[0]), 0, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a8f1060bd41ba7b2904cbabb0cac84455" title="Epetra communicator.">comm</a>));
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 }
<a name="l00756"></a>00756 
<a name="l00757"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a620565509dacf5c28d351172b9c51b8b">00757</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a620565509dacf5c28d351172b9c51b8b" title="Process STK mesh for Overlap nodal quantitites.">Albany::STKDiscretization::computeOverlapNodesAndUnknowns</a>()
<a name="l00758"></a>00758 {
<a name="l00759"></a>00759   <span class="comment">// Loads member data:  overlapodes, numOverlapodes, overlap_node_map, coordinates</span>
<a name="l00760"></a>00760   std::vector&lt;int&gt; indices;
<a name="l00761"></a>00761   <span class="comment">// maps for overlap unknowns</span>
<a name="l00762"></a>00762   stk::mesh::Selector select_overlap_in_part =
<a name="l00763"></a>00763     stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.universal_part() ) &amp;
<a name="l00764"></a>00764     ( stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part() )
<a name="l00765"></a>00765       | stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.globally_shared_part() ) );
<a name="l00766"></a>00766 
<a name="l00767"></a>00767   <span class="comment">//  overlapnodes used for overlap map -- stored for changing coords</span>
<a name="l00768"></a>00768   stk::mesh::get_selected_entities( select_overlap_in_part ,
<a name="l00769"></a>00769             <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>.buckets( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.node_rank() ) ,
<a name="l00770"></a>00770             <a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a> );
<a name="l00771"></a>00771 
<a name="l00772"></a>00772   <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>.size();
<a name="l00773"></a>00773   indices.resize(<a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a> * <a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a>);
<a name="l00774"></a>00774   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++)
<a name="l00775"></a>00775     <span class="keywordflow">for</span> (std::size_t j=0; j &lt; neq; j++)
<a name="l00776"></a>00776       indices[<a class="code" href="classAlbany_1_1STKDiscretization.html#a04d345896b258962f4975aa0f36e173a" title="Locate nodal dofs in overlapping vectors using local indexing.">getOverlapDOF</a>(i,j)] = <a class="code" href="classAlbany_1_1STKDiscretization.html#a4aa3b5f66486b51fb025f4157e2f76e5" title="Locate nodal dofs using global indexing.">getGlobalDOF</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]),j);
<a name="l00777"></a>00777 
<a name="l00778"></a>00778   <a class="code" href="classAlbany_1_1STKDiscretization.html#a04c2c91bfbe73c9f62ef2b89c50a1b7d" title="Overlapped unknown map, and node map.">overlap_map</a> = Teuchos::null; <span class="comment">// delete existing map happens here on remesh</span>
<a name="l00779"></a>00779 
<a name="l00780"></a>00780   <a class="code" href="classAlbany_1_1STKDiscretization.html#a04c2c91bfbe73c9f62ef2b89c50a1b7d" title="Overlapped unknown map, and node map.">overlap_map</a> = Teuchos::rcp(<span class="keyword">new</span> Epetra_Map(-1, indices.size(),
<a name="l00781"></a>00781               &amp;(indices[0]), 0, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a8f1060bd41ba7b2904cbabb0cac84455" title="Epetra communicator.">comm</a>));
<a name="l00782"></a>00782 
<a name="l00783"></a>00783   <span class="comment">// Set up epetra map of node IDs</span>
<a name="l00784"></a>00784   indices.resize(numOverlapNodes);
<a name="l00785"></a>00785   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; numOverlapNodes; i++)
<a name="l00786"></a>00786     indices[i] = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a4edb11abe521264a5257514e739c1694" title="list of all overlap nodes, saved for getting coordinates for mesh motion">overlapnodes</a>[i]);
<a name="l00787"></a>00787 
<a name="l00788"></a>00788   <a class="code" href="classAlbany_1_1STKDiscretization.html#add1e11b4e7887764bd677538c33a5ec1">overlap_node_map</a> = Teuchos::null; <span class="comment">// delete existing map happens here on remesh</span>
<a name="l00789"></a>00789 
<a name="l00790"></a>00790   <a class="code" href="classAlbany_1_1STKDiscretization.html#add1e11b4e7887764bd677538c33a5ec1">overlap_node_map</a> = Teuchos::rcp(<span class="keyword">new</span> Epetra_Map(-1, indices.size(),
<a name="l00791"></a>00791              &amp;(indices[0]), 0, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a8f1060bd41ba7b2904cbabb0cac84455" title="Epetra communicator.">comm</a>));
<a name="l00792"></a>00792 
<a name="l00793"></a>00793   <span class="keywordflow">if</span>(Teuchos::nonnull(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nodal_data_block))
<a name="l00794"></a>00794     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nodal_data_block-&gt;resizeOverlapMap(indices, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a8f1060bd41ba7b2904cbabb0cac84455" title="Epetra communicator.">comm</a>);
<a name="l00795"></a>00795 
<a name="l00796"></a>00796   <a class="code" href="classAlbany_1_1STKDiscretization.html#a4975195024597f2431dc528be2dc012a">coordinates</a>.resize(3*numOverlapNodes);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 }
<a name="l00799"></a>00799 
<a name="l00800"></a>00800 
<a name="l00801"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#aba4192b9c5b2a7e5ca77e1e7634318b7">00801</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#aba4192b9c5b2a7e5ca77e1e7634318b7" title="Process STK mesh for CRS Graphs.">Albany::STKDiscretization::computeGraphs</a>()
<a name="l00802"></a>00802 {
<a name="l00803"></a>00803 
<a name="l00804"></a>00804   std::map&lt;int, stk::mesh::Part*&gt;::iterator pv = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;partVec.begin();
<a name="l00805"></a>00805   <span class="keywordtype">int</span> nodes_per_element =  <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.get_cell_topology(*(pv-&gt;second)).getNodeCount();
<a name="l00806"></a>00806 <span class="comment">// int nodes_per_element_est =  metaData.get_cell_topology(*(stkMeshStruct-&gt;partVec[0])).getNodeCount();</span>
<a name="l00807"></a>00807 
<a name="l00808"></a>00808   <span class="comment">// Loads member data:  overlap_graph, numOverlapodes, overlap_node_map, coordinates, graphs</span>
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <a class="code" href="classAlbany_1_1STKDiscretization.html#a01efaed38046489a546ec7b01c5ca12e" title="Overlapped Jacobian matrix graph.">overlap_graph</a> = Teuchos::null; <span class="comment">// delete existing graph happens here on remesh</span>
<a name="l00811"></a>00811 
<a name="l00812"></a>00812   <a class="code" href="classAlbany_1_1STKDiscretization.html#a01efaed38046489a546ec7b01c5ca12e" title="Overlapped Jacobian matrix graph.">overlap_graph</a> =
<a name="l00813"></a>00813     Teuchos::rcp(<span class="keyword">new</span> Epetra_CrsGraph(Copy, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a04c2c91bfbe73c9f62ef2b89c50a1b7d" title="Overlapped unknown map, and node map.">overlap_map</a>,
<a name="l00814"></a>00814                                      <a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a>*nodes_per_element, <span class="keyword">false</span>));
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   stk::mesh::Selector select_owned_in_part =
<a name="l00817"></a>00817     stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.universal_part() ) &amp;
<a name="l00818"></a>00818     stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part() );
<a name="l00819"></a>00819 
<a name="l00820"></a>00820   stk::mesh::get_selected_entities( select_owned_in_part ,
<a name="l00821"></a>00821             <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>.buckets( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.element_rank() ) ,
<a name="l00822"></a>00822             <a class="code" href="classAlbany_1_1STKDiscretization.html#ab83300b2ee825168aa58104dbf77baa9">cells</a> );
<a name="l00823"></a>00823 
<a name="l00824"></a>00824 
<a name="l00825"></a>00825   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8f1060bd41ba7b2904cbabb0cac84455" title="Epetra communicator.">comm</a>-&gt;MyPID()==0)
<a name="l00826"></a>00826     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;STKDisc: &quot;</span> &lt;&lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#ab83300b2ee825168aa58104dbf77baa9">cells</a>.size() &lt;&lt; <span class="stringliteral">&quot; elements on Proc 0 &quot;</span> &lt;&lt; std::endl;
<a name="l00827"></a>00827 
<a name="l00828"></a>00828   <span class="keywordtype">int</span> row, col;
<a name="l00829"></a>00829 
<a name="l00830"></a>00830   <span class="keywordflow">for</span> (std::size_t i=0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#ab83300b2ee825168aa58104dbf77baa9">cells</a>.size(); i++) {
<a name="l00831"></a>00831     <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>&amp; e = *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab83300b2ee825168aa58104dbf77baa9">cells</a>[i];
<a name="l00832"></a>00832     stk::mesh::PairIterRelation rel = e.relations(<a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.NODE_RANK);
<a name="l00833"></a>00833 
<a name="l00834"></a>00834     <span class="comment">// loop over local nodes</span>
<a name="l00835"></a>00835     <span class="keywordflow">for</span> (std::size_t j=0; j &lt; rel.size(); j++) {
<a name="l00836"></a>00836       <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>&amp; rowNode = * rel[j].entity();
<a name="l00837"></a>00837 
<a name="l00838"></a>00838       <span class="comment">// loop over eqs</span>
<a name="l00839"></a>00839       <span class="keywordflow">for</span> (std::size_t k=0; k &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a>; k++) {
<a name="l00840"></a>00840         row = <a class="code" href="classAlbany_1_1STKDiscretization.html#a4aa3b5f66486b51fb025f4157e2f76e5" title="Locate nodal dofs using global indexing.">getGlobalDOF</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(rowNode), k);
<a name="l00841"></a>00841         <span class="keywordflow">for</span> (std::size_t l=0; l &lt; rel.size(); l++) {
<a name="l00842"></a>00842           <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>&amp; colNode = * rel[l].entity();
<a name="l00843"></a>00843           <span class="keywordflow">for</span> (std::size_t m=0; m &lt; neq; m++) {
<a name="l00844"></a>00844             col = <a class="code" href="classAlbany_1_1STKDiscretization.html#a4aa3b5f66486b51fb025f4157e2f76e5" title="Locate nodal dofs using global indexing.">getGlobalDOF</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(colNode), m);
<a name="l00845"></a>00845             <a class="code" href="classAlbany_1_1STKDiscretization.html#a01efaed38046489a546ec7b01c5ca12e" title="Overlapped Jacobian matrix graph.">overlap_graph</a>-&gt;InsertGlobalIndices(row, 1, &amp;col);
<a name="l00846"></a>00846           }
<a name="l00847"></a>00847         }
<a name="l00848"></a>00848       }
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850   }
<a name="l00851"></a>00851   <a class="code" href="classAlbany_1_1STKDiscretization.html#a01efaed38046489a546ec7b01c5ca12e" title="Overlapped Jacobian matrix graph.">overlap_graph</a>-&gt;FillComplete();
<a name="l00852"></a>00852 
<a name="l00853"></a>00853   <span class="comment">// Create Owned graph by exporting overlap with known row map</span>
<a name="l00854"></a>00854 
<a name="l00855"></a>00855   <a class="code" href="classAlbany_1_1STKDiscretization.html#a00cd1359d5347480cb66316a158bf308" title="Jacobian matrix graph.">graph</a> = Teuchos::null; <span class="comment">// delete existing graph happens here on remesh</span>
<a name="l00856"></a>00856 
<a name="l00857"></a>00857   <a class="code" href="classAlbany_1_1STKDiscretization.html#a00cd1359d5347480cb66316a158bf308" title="Jacobian matrix graph.">graph</a> = Teuchos::rcp(<span class="keyword">new</span> Epetra_CrsGraph(Copy, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a>, <a class="code" href="classAlbany_1_1STKDiscretization.html#a53b7ecd8e2c8f56ba98632a2e106042b">nonzeroesPerRow</a>(<a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a>), <span class="keyword">false</span>));
<a name="l00858"></a>00858 
<a name="l00859"></a>00859   <span class="comment">// Create non-overlapped matrix using two maps and export object</span>
<a name="l00860"></a>00860   Epetra_Export exporter(*<a class="code" href="classAlbany_1_1STKDiscretization.html#a04c2c91bfbe73c9f62ef2b89c50a1b7d" title="Overlapped unknown map, and node map.">overlap_map</a>, *<a class="code" href="classAlbany_1_1STKDiscretization.html#a4e2b36fe20a1fec390793efede0a8ac9" title="Unknown Map.">map</a>);
<a name="l00861"></a>00861   <a class="code" href="classAlbany_1_1STKDiscretization.html#a00cd1359d5347480cb66316a158bf308" title="Jacobian matrix graph.">graph</a>-&gt;Export(*<a class="code" href="classAlbany_1_1STKDiscretization.html#a01efaed38046489a546ec7b01c5ca12e" title="Overlapped Jacobian matrix graph.">overlap_graph</a>, exporter, Insert);
<a name="l00862"></a>00862   <a class="code" href="classAlbany_1_1STKDiscretization.html#a00cd1359d5347480cb66316a158bf308" title="Jacobian matrix graph.">graph</a>-&gt;FillComplete();
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 }
<a name="l00865"></a>00865 
<a name="l00866"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a8950d2962d151003edadd2658424f931">00866</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a8950d2962d151003edadd2658424f931" title="Process STK mesh for Workset/Bucket Info.">Albany::STKDiscretization::computeWorksetInfo</a>()
<a name="l00867"></a>00867 {
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   stk::mesh::Selector select_owned_in_part =
<a name="l00870"></a>00870     stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.universal_part() ) &amp;
<a name="l00871"></a>00871     stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part() );
<a name="l00872"></a>00872 
<a name="l00873"></a>00873   std::vector&lt; stk::mesh::Bucket * &gt; buckets ;
<a name="l00874"></a>00874   stk::mesh::get_buckets( select_owned_in_part ,
<a name="l00875"></a>00875                           <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>.buckets( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.element_rank() ) ,
<a name="l00876"></a>00876                           buckets);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878   <span class="keywordtype">int</span> numBuckets =  buckets.size();
<a name="l00879"></a>00879 
<a name="l00880"></a>00880   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#ab29b7b67367d394e0364838c6e3fcf73">AbstractSTKFieldContainer::VectorFieldType</a>* coordinates_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getCoordinatesField();
<a name="l00881"></a>00881   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* surfaceHeight_field;
<a name="l00882"></a>00882   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* temperature_field;
<a name="l00883"></a>00883   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* basalFriction_field;
<a name="l00884"></a>00884   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* thickness_field;
<a name="l00885"></a>00885   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a0c9ac743a450b8ba1f101e7d1c0507d3">AbstractSTKFieldContainer::ScalarFieldType</a>* flowFactor_field;
<a name="l00886"></a>00886   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#ab29b7b67367d394e0364838c6e3fcf73">AbstractSTKFieldContainer::VectorFieldType</a>* surfaceVelocity_field;
<a name="l00887"></a>00887   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#ab29b7b67367d394e0364838c6e3fcf73">AbstractSTKFieldContainer::VectorFieldType</a>* velocityRMS_field;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889   <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasSurfaceHeightField())
<a name="l00890"></a>00890     surfaceHeight_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getSurfaceHeightField();
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasTemperatureField())
<a name="l00893"></a>00893     temperature_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getTemperatureField();
<a name="l00894"></a>00894 
<a name="l00895"></a>00895   <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasBasalFrictionField())
<a name="l00896"></a>00896     basalFriction_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getBasalFrictionField();
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasThicknessField())
<a name="l00899"></a>00899     thickness_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getThicknessField();
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasFlowFactorField())
<a name="l00902"></a>00902     flowFactor_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getFlowFactorField();
<a name="l00903"></a>00903 
<a name="l00904"></a>00904   <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasSurfaceVelocityField())
<a name="l00905"></a>00905     surfaceVelocity_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getSurfaceVelocityField();
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasVelocityRMSField())
<a name="l00908"></a>00908     velocityRMS_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getVelocityRMSField();
<a name="l00909"></a>00909 
<a name="l00910"></a>00910   <a class="code" href="classAlbany_1_1STKDiscretization.html#a31fce9e12eb182345cc1d514c212bee7">wsEBNames</a>.resize(numBuckets);
<a name="l00911"></a>00911   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;numBuckets; i++) {
<a name="l00912"></a>00912     std::vector&lt; stk::mesh::Part * &gt;  bpv;
<a name="l00913"></a>00913     buckets[i]-&gt;supersets(bpv);
<a name="l00914"></a>00914     <span class="keywordflow">for</span> (std::size_t j=0; j&lt;bpv.size(); j++) {
<a name="l00915"></a>00915       <span class="keywordflow">if</span> (bpv[j]-&gt;primary_entity_rank() == <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.element_rank()) {
<a name="l00916"></a>00916         <span class="keywordflow">if</span> (bpv[j]-&gt;name()[0] != <span class="charliteral">&#39;{&#39;</span>) {
<a name="l00917"></a>00917     <span class="comment">// *out &lt;&lt; &quot;Bucket &quot; &lt;&lt; i &lt;&lt; &quot; is in Element Block:  &quot; &lt;&lt; bpv[j]-&gt;name()</span>
<a name="l00918"></a>00918     <span class="comment">//      &lt;&lt; &quot;  and has &quot; &lt;&lt; buckets[i]-&gt;size() &lt;&lt; &quot; elements.&quot; &lt;&lt; std::endl;</span>
<a name="l00919"></a>00919           <a class="code" href="classAlbany_1_1STKDiscretization.html#a31fce9e12eb182345cc1d514c212bee7">wsEBNames</a>[i]=bpv[j]-&gt;name();
<a name="l00920"></a>00920         }
<a name="l00921"></a>00921       }
<a name="l00922"></a>00922     }
<a name="l00923"></a>00923   }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   <a class="code" href="classAlbany_1_1STKDiscretization.html#a7d5f924a774a1336aeb4e89b3520e07e">wsPhysIndex</a>.resize(numBuckets);
<a name="l00926"></a>00926   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;allElementBlocksHaveSamePhysics)
<a name="l00927"></a>00927     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;numBuckets; i++) <a class="code" href="classAlbany_1_1STKDiscretization.html#a7d5f924a774a1336aeb4e89b3520e07e">wsPhysIndex</a>[i]=0;
<a name="l00928"></a>00928   <span class="keywordflow">else</span>
<a name="l00929"></a>00929     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;numBuckets; i++) <a class="code" href="classAlbany_1_1STKDiscretization.html#a7d5f924a774a1336aeb4e89b3520e07e">wsPhysIndex</a>[i]=<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;ebNameToIndex[<a class="code" href="classAlbany_1_1STKDiscretization.html#a31fce9e12eb182345cc1d514c212bee7">wsEBNames</a>[i]];
<a name="l00930"></a>00930 
<a name="l00931"></a>00931   <span class="comment">// Fill  wsElNodeEqID(workset, el_LID, local node, Eq) =&gt; unk_LID</span>
<a name="l00932"></a>00932 
<a name="l00933"></a>00933   <a class="code" href="classAlbany_1_1STKDiscretization.html#aed47a34b5f0e43f2c840a4f0f136edc4" title="Connectivity array [workset, element, local-node, Eq] =&amp;gt; LID.">wsElNodeEqID</a>.resize(numBuckets);
<a name="l00934"></a>00934   <a class="code" href="classAlbany_1_1STKDiscretization.html#a34ca0bdc19e731b8185f7698e35a2aaa">wsElNodeID</a>.resize(numBuckets);
<a name="l00935"></a>00935   <a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>.resize(numBuckets);
<a name="l00936"></a>00936   <a class="code" href="classAlbany_1_1STKDiscretization.html#ab394b8385f218812ded5d94d501ed4c8">sHeight</a>.resize(numBuckets);
<a name="l00937"></a>00937   <a class="code" href="classAlbany_1_1STKDiscretization.html#a3c1810d25e1c0d89910df612d34876c3">temperature</a>.resize(numBuckets);
<a name="l00938"></a>00938   <a class="code" href="classAlbany_1_1STKDiscretization.html#a61ab3e3a5ea6705ef21e9280c5e6c927">basalFriction</a>.resize(numBuckets);
<a name="l00939"></a>00939   <a class="code" href="classAlbany_1_1STKDiscretization.html#a2a64f47b4267ac116d9070727c00405a">thickness</a>.resize(numBuckets);
<a name="l00940"></a>00940   <a class="code" href="classAlbany_1_1STKDiscretization.html#acbd316fe62b70bb69848d4b114488bf1">flowFactor</a>.resize(numBuckets);
<a name="l00941"></a>00941   <a class="code" href="classAlbany_1_1STKDiscretization.html#af5df96321f53188bf7f61624c118bdde">surfaceVelocity</a>.resize(numBuckets);
<a name="l00942"></a>00942   <a class="code" href="classAlbany_1_1STKDiscretization.html#aa48c1e55a54a0101921765cec1a15da1">velocityRMS</a>.resize(numBuckets);
<a name="l00943"></a>00943 
<a name="l00944"></a>00944   <span class="comment">// Clear map if remeshing</span>
<a name="l00945"></a>00945   <span class="keywordflow">if</span>(!<a class="code" href="classAlbany_1_1STKDiscretization.html#a5d79536cef04ef59e0ebb80f43c37b85" title="Connectivity map from elementGID to workset and LID in workset.">elemGIDws</a>.empty()) <a class="code" href="classAlbany_1_1STKDiscretization.html#a5d79536cef04ef59e0ebb80f43c37b85" title="Connectivity map from elementGID to workset and LID in workset.">elemGIDws</a>.clear();
<a name="l00946"></a>00946 
<a name="l00947"></a>00947   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b=0; b &lt; numBuckets; b++) {
<a name="l00948"></a>00948 
<a name="l00949"></a>00949     stk::mesh::Bucket&amp; buck = *buckets[b];
<a name="l00950"></a>00950     <a class="code" href="classAlbany_1_1STKDiscretization.html#aed47a34b5f0e43f2c840a4f0f136edc4" title="Connectivity array [workset, element, local-node, Eq] =&amp;gt; LID.">wsElNodeEqID</a>[b].resize(buck.size());
<a name="l00951"></a>00951     <a class="code" href="classAlbany_1_1STKDiscretization.html#a34ca0bdc19e731b8185f7698e35a2aaa">wsElNodeID</a>[b].resize(buck.size());
<a name="l00952"></a>00952     <a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[b].resize(buck.size());
<a name="l00953"></a>00953 <span class="preprocessor">#ifdef ALBANY_FELIX</span>
<a name="l00954"></a>00954 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasSurfaceHeightField())
<a name="l00955"></a>00955       <a class="code" href="classAlbany_1_1STKDiscretization.html#ab394b8385f218812ded5d94d501ed4c8">sHeight</a>[b].resize(buck.size());
<a name="l00956"></a>00956     <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasTemperatureField())
<a name="l00957"></a>00957       <a class="code" href="classAlbany_1_1STKDiscretization.html#a3c1810d25e1c0d89910df612d34876c3">temperature</a>[b].resize(buck.size());
<a name="l00958"></a>00958     <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasBasalFrictionField())
<a name="l00959"></a>00959       <a class="code" href="classAlbany_1_1STKDiscretization.html#a61ab3e3a5ea6705ef21e9280c5e6c927">basalFriction</a>[b].resize(buck.size());
<a name="l00960"></a>00960     <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasThicknessField())
<a name="l00961"></a>00961       <a class="code" href="classAlbany_1_1STKDiscretization.html#a2a64f47b4267ac116d9070727c00405a">thickness</a>[b].resize(buck.size());
<a name="l00962"></a>00962     <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasFlowFactorField())
<a name="l00963"></a>00963       <a class="code" href="classAlbany_1_1STKDiscretization.html#acbd316fe62b70bb69848d4b114488bf1">flowFactor</a>[b].resize(buck.size());
<a name="l00964"></a>00964     <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasSurfaceVelocityField())
<a name="l00965"></a>00965       <a class="code" href="classAlbany_1_1STKDiscretization.html#af5df96321f53188bf7f61624c118bdde">surfaceVelocity</a>[b].resize(buck.size());
<a name="l00966"></a>00966     <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasVelocityRMSField())
<a name="l00967"></a>00967       <a class="code" href="classAlbany_1_1STKDiscretization.html#aa48c1e55a54a0101921765cec1a15da1">velocityRMS</a>[b].resize(buck.size());
<a name="l00968"></a>00968 <span class="preprocessor">#endif</span>
<a name="l00969"></a>00969 <span class="preprocessor"></span>
<a name="l00970"></a>00970     <span class="comment">// i is the element index within bucket b</span>
<a name="l00971"></a>00971 
<a name="l00972"></a>00972     <span class="keywordflow">for</span> (std::size_t i=0; i &lt; buck.size(); i++) {
<a name="l00973"></a>00973 
<a name="l00974"></a>00974       <span class="comment">// Traverse all the elements in this bucket</span>
<a name="l00975"></a>00975       <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>&amp; element = buck[i];
<a name="l00976"></a>00976 
<a name="l00977"></a>00977       <span class="comment">// Now, save a map from element GID to workset on this PE</span>
<a name="l00978"></a>00978       <a class="code" href="classAlbany_1_1STKDiscretization.html#a5d79536cef04ef59e0ebb80f43c37b85" title="Connectivity map from elementGID to workset and LID in workset.">elemGIDws</a>[<a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(element)].ws = b;
<a name="l00979"></a>00979 
<a name="l00980"></a>00980       <span class="comment">// Now, save a map from element GID to local id on this workset on this PE</span>
<a name="l00981"></a>00981       <a class="code" href="classAlbany_1_1STKDiscretization.html#a5d79536cef04ef59e0ebb80f43c37b85" title="Connectivity map from elementGID to workset and LID in workset.">elemGIDws</a>[<a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(element)].LID = i;
<a name="l00982"></a>00982 
<a name="l00983"></a>00983       stk::mesh::PairIterRelation rel = element.relations(<a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.NODE_RANK);
<a name="l00984"></a>00984 
<a name="l00985"></a>00985       <span class="keywordtype">int</span> nodes_per_element = rel.size();
<a name="l00986"></a>00986       <a class="code" href="classAlbany_1_1STKDiscretization.html#aed47a34b5f0e43f2c840a4f0f136edc4" title="Connectivity array [workset, element, local-node, Eq] =&amp;gt; LID.">wsElNodeEqID</a>[b][i].resize(nodes_per_element);
<a name="l00987"></a>00987       <a class="code" href="classAlbany_1_1STKDiscretization.html#a34ca0bdc19e731b8185f7698e35a2aaa">wsElNodeID</a>[b][i].resize(nodes_per_element);
<a name="l00988"></a>00988       <a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[b][i].resize(nodes_per_element);
<a name="l00989"></a>00989 <span class="preprocessor">#ifdef ALBANY_FELIX</span>
<a name="l00990"></a>00990 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasSurfaceHeightField())
<a name="l00991"></a>00991         <a class="code" href="classAlbany_1_1STKDiscretization.html#ab394b8385f218812ded5d94d501ed4c8">sHeight</a>[b][i].resize(nodes_per_element);
<a name="l00992"></a>00992       <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasTemperatureField())
<a name="l00993"></a>00993         <a class="code" href="classAlbany_1_1STKDiscretization.html#a3c1810d25e1c0d89910df612d34876c3">temperature</a>[b][i] = *stk::mesh::field_data(*temperature_field, element);
<a name="l00994"></a>00994       <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasBasalFrictionField())
<a name="l00995"></a>00995         <a class="code" href="classAlbany_1_1STKDiscretization.html#a61ab3e3a5ea6705ef21e9280c5e6c927">basalFriction</a>[b][i].resize(nodes_per_element);
<a name="l00996"></a>00996       <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasThicknessField())
<a name="l00997"></a>00997         <a class="code" href="classAlbany_1_1STKDiscretization.html#a2a64f47b4267ac116d9070727c00405a">thickness</a>[b][i].resize(nodes_per_element);
<a name="l00998"></a>00998       <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasFlowFactorField())
<a name="l00999"></a>00999          <a class="code" href="classAlbany_1_1STKDiscretization.html#acbd316fe62b70bb69848d4b114488bf1">flowFactor</a>[b][i] = *stk::mesh::field_data(*flowFactor_field, element);
<a name="l01000"></a>01000       <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasSurfaceVelocityField())
<a name="l01001"></a>01001         <a class="code" href="classAlbany_1_1STKDiscretization.html#af5df96321f53188bf7f61624c118bdde">surfaceVelocity</a>[b][i].resize(nodes_per_element);
<a name="l01002"></a>01002       <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasVelocityRMSField())
<a name="l01003"></a>01003         <a class="code" href="classAlbany_1_1STKDiscretization.html#aa48c1e55a54a0101921765cec1a15da1">velocityRMS</a>[b][i].resize(nodes_per_element);
<a name="l01004"></a>01004 <span class="preprocessor">#endif</span>
<a name="l01005"></a>01005 <span class="preprocessor"></span>      <span class="comment">// loop over local nodes</span>
<a name="l01006"></a>01006       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; nodes_per_element; j++) {
<a name="l01007"></a>01007         <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>&amp; rowNode = * rel[j].entity();
<a name="l01008"></a>01008         <span class="keywordtype">int</span> node_gid = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(rowNode);
<a name="l01009"></a>01009         <span class="keywordtype">int</span> node_lid = <a class="code" href="classAlbany_1_1STKDiscretization.html#add1e11b4e7887764bd677538c33a5ec1">overlap_node_map</a>-&gt;LID(node_gid);
<a name="l01010"></a>01010 
<a name="l01011"></a>01011         TEUCHOS_TEST_FOR_EXCEPTION(node_lid&lt;0, std::logic_error,
<a name="l01012"></a>01012          <span class="stringliteral">&quot;STK1D_Disc: node_lid out of range &quot;</span> &lt;&lt; node_lid &lt;&lt; std::endl);
<a name="l01013"></a>01013         <a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[b][i][j] = stk::mesh::field_data(*coordinates_field, rowNode);
<a name="l01014"></a>01014 <span class="preprocessor">#ifdef ALBANY_FELIX</span>
<a name="l01015"></a>01015 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasSurfaceHeightField())
<a name="l01016"></a>01016           <a class="code" href="classAlbany_1_1STKDiscretization.html#ab394b8385f218812ded5d94d501ed4c8">sHeight</a>[b][i][j] = *stk::mesh::field_data(*surfaceHeight_field, rowNode);
<a name="l01017"></a>01017         <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasBasalFrictionField())
<a name="l01018"></a>01018           <a class="code" href="classAlbany_1_1STKDiscretization.html#a61ab3e3a5ea6705ef21e9280c5e6c927">basalFriction</a>[b][i][j] = *stk::mesh::field_data(*basalFriction_field, rowNode);
<a name="l01019"></a>01019         <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasThicknessField())
<a name="l01020"></a>01020           <a class="code" href="classAlbany_1_1STKDiscretization.html#a2a64f47b4267ac116d9070727c00405a">thickness</a>[b][i][j] = *stk::mesh::field_data(*thickness_field, rowNode);
<a name="l01021"></a>01021         <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasSurfaceVelocityField())
<a name="l01022"></a>01022           <a class="code" href="classAlbany_1_1STKDiscretization.html#af5df96321f53188bf7f61624c118bdde">surfaceVelocity</a>[b][i][j] = stk::mesh::field_data(*surfaceVelocity_field, rowNode);
<a name="l01023"></a>01023         <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasVelocityRMSField())
<a name="l01024"></a>01024           <a class="code" href="classAlbany_1_1STKDiscretization.html#aa48c1e55a54a0101921765cec1a15da1">velocityRMS</a>[b][i][j] = stk::mesh::field_data(*velocityRMS_field, rowNode);
<a name="l01025"></a>01025 <span class="preprocessor">#endif</span>
<a name="l01026"></a>01026 <span class="preprocessor"></span>
<a name="l01027"></a>01027         <a class="code" href="classAlbany_1_1STKDiscretization.html#aed47a34b5f0e43f2c840a4f0f136edc4" title="Connectivity array [workset, element, local-node, Eq] =&amp;gt; LID.">wsElNodeEqID</a>[b][i][j].resize(<a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a>);
<a name="l01028"></a>01028         <a class="code" href="classAlbany_1_1STKDiscretization.html#a34ca0bdc19e731b8185f7698e35a2aaa">wsElNodeID</a>[b][i][j] = node_gid;
<a name="l01029"></a>01029 
<a name="l01030"></a>01030         <span class="keywordflow">for</span> (std::size_t eq=0; eq &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a>; eq++)
<a name="l01031"></a>01031           <a class="code" href="classAlbany_1_1STKDiscretization.html#aed47a34b5f0e43f2c840a4f0f136edc4" title="Connectivity array [workset, element, local-node, Eq] =&amp;gt; LID.">wsElNodeEqID</a>[b][i][j][eq] = <a class="code" href="classAlbany_1_1STKDiscretization.html#a04d345896b258962f4975aa0f36e173a" title="Locate nodal dofs in overlapping vectors using local indexing.">getOverlapDOF</a>(node_lid,eq);
<a name="l01032"></a>01032       }
<a name="l01033"></a>01033     }
<a name="l01034"></a>01034   }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d=0; d&lt;<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;numDim; d++) {
<a name="l01037"></a>01037   <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.periodic[d]) {
<a name="l01038"></a>01038     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b=0; b &lt; numBuckets; b++) {
<a name="l01039"></a>01039       <span class="keywordflow">for</span> (std::size_t i=0; i &lt; buckets[b]-&gt;size(); i++) {
<a name="l01040"></a>01040         <span class="keywordtype">int</span> nodes_per_element = (*buckets[b])[i].relations(<a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.NODE_RANK).size();
<a name="l01041"></a>01041         <span class="keywordtype">bool</span> anyXeqZero=<span class="keyword">false</span>;
<a name="l01042"></a>01042         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; nodes_per_element; j++)  <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[b][i][j][d]==0.0) anyXeqZero=<span class="keyword">true</span>;
<a name="l01043"></a>01043         <span class="keywordflow">if</span> (anyXeqZero)  {
<a name="l01044"></a>01044           <span class="keywordtype">bool</span> flipZeroToScale=<span class="keyword">false</span>;
<a name="l01045"></a>01045           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; nodes_per_element; j++)
<a name="l01046"></a>01046               <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[b][i][j][d] &gt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[d]/1.9) flipZeroToScale=<span class="keyword">true</span>;
<a name="l01047"></a>01047           <span class="keywordflow">if</span> (flipZeroToScale) {
<a name="l01048"></a>01048             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; nodes_per_element; j++)  {
<a name="l01049"></a>01049               <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[b][i][j][d] == 0.0) {
<a name="l01050"></a>01050                 <span class="keywordtype">double</span>* xleak = <span class="keyword">new</span> <span class="keywordtype">double</span> [<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;numDim];
<a name="l01051"></a>01051                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;numDim; k++)
<a name="l01052"></a>01052                   <span class="keywordflow">if</span> (k==d) xleak[d]=<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[d];
<a name="l01053"></a>01053                   <span class="keywordflow">else</span> xleak[k] = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[b][i][j][k];
<a name="l01054"></a>01054                 std::string transformType = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;transformType;
<a name="l01055"></a>01055                 <span class="keywordtype">double</span> <a class="code" href="namespaceFELIX.html#a4d08741b97fea3938089670d2a84c598">alpha</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;felixAlpha;
<a name="l01056"></a>01056                 alpha *= <a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/180.; <span class="comment">//convert alpha, read in from ParameterList, to radians</span>
<a name="l01057"></a>01057                 <span class="keywordflow">if</span> ((transformType==<span class="stringliteral">&quot;ISMIP-HOM Test A&quot;</span> || transformType == <span class="stringliteral">&quot;ISMIP-HOM Test B&quot;</span> ||
<a name="l01058"></a>01058                      transformType==<span class="stringliteral">&quot;ISMIP-HOM Test C&quot;</span> || transformType == <span class="stringliteral">&quot;ISMIP-HOM Test D&quot;</span>) &amp;&amp; d==0) {
<a name="l01059"></a>01059                     xleak[2] -= <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[d]*tan(alpha);
<a name="l01060"></a>01060 <span class="preprocessor">#ifdef ALBANY_FELIX</span>
<a name="l01061"></a>01061 <span class="preprocessor"></span>                    <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;hasSurfaceHeightField())
<a name="l01062"></a>01062                       <a class="code" href="classAlbany_1_1STKDiscretization.html#ab394b8385f218812ded5d94d501ed4c8">sHeight</a>[b][i][j] -= <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;PBCStruct.scale[d]*tan(alpha);
<a name="l01063"></a>01063 <span class="preprocessor">#endif</span>
<a name="l01064"></a>01064 <span class="preprocessor"></span>                }
<a name="l01065"></a>01065                 <a class="code" href="classAlbany_1_1STKDiscretization.html#a9e54104fc2e823c66ac6022d3482b594">coords</a>[b][i][j] = xleak; <span class="comment">// replace ptr to coords</span>
<a name="l01066"></a>01066                 <a class="code" href="classAlbany_1_1STKDiscretization.html#a69615d0e242ce45938412e0f0a9a3f5f">toDelete</a>.push_back(xleak);
<a name="l01067"></a>01067               }
<a name="l01068"></a>01068             }
<a name="l01069"></a>01069           }
<a name="l01070"></a>01070         }
<a name="l01071"></a>01071       }
<a name="l01072"></a>01072     }
<a name="l01073"></a>01073   }
<a name="l01074"></a>01074   }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076   <span class="keyword">typedef</span> <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a5202f96255de1cb7f470c3f03d4ea68c">Albany::AbstractSTKFieldContainer::ScalarValueState</a> ScalarValueState;
<a name="l01077"></a>01077   <span class="keyword">typedef</span> <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a007987b0beda36541dbd3e23272f5636">Albany::AbstractSTKFieldContainer::QPScalarState</a> QPScalarState ;
<a name="l01078"></a>01078   <span class="keyword">typedef</span> <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#a84a2cff19b6b8bdf2da0fd3251724538">Albany::AbstractSTKFieldContainer::QPVectorState</a> QPVectorState;
<a name="l01079"></a>01079   <span class="keyword">typedef</span> <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#ad9857a4f6f99ff30cb434e9a10d9ce70">Albany::AbstractSTKFieldContainer::QPTensorState</a> QPTensorState;
<a name="l01080"></a>01080 
<a name="l01081"></a>01081   <span class="keyword">typedef</span> <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#af951fb88cc5ac01e95b51ecd92ec4091">Albany::AbstractSTKFieldContainer::ScalarState</a> ScalarState ;
<a name="l01082"></a>01082   <span class="keyword">typedef</span> <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#affd83361cd27090a2f81dc6252ef7aba">Albany::AbstractSTKFieldContainer::VectorState</a> VectorState;
<a name="l01083"></a>01083   <span class="keyword">typedef</span> <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#acf5436272891caf2f8ebf111d5d6214c">Albany::AbstractSTKFieldContainer::TensorState</a> TensorState;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085   <span class="comment">// Pull out pointers to shards::Arrays for every bucket, for every state</span>
<a name="l01086"></a>01086   <span class="comment">// Code is data-type dependent</span>
<a name="l01087"></a>01087 
<a name="l01088"></a>01088   ScalarValueState scalarValue_states = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getScalarValueStates();
<a name="l01089"></a>01089   QPScalarState qpscalar_states = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getQPScalarStates();
<a name="l01090"></a>01090   QPVectorState qpvector_states = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getQPVectorStates();
<a name="l01091"></a>01091   QPTensorState qptensor_states = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getQPTensorStates();
<a name="l01092"></a>01092   <span class="keywordtype">double</span>&amp; time = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getFieldContainer()-&gt;getTime();
<a name="l01093"></a>01093 
<a name="l01094"></a>01094   <a class="code" href="classAlbany_1_1STKDiscretization.html#a3288951a08528ecf0cfe7ff9efdfe3ae">stateArrays</a>.<a class="code" href="structAlbany_1_1StateArrays.html#a5fa0a75997a1a3135dbd2559ad4e0e8f">elemStateArrays</a>.resize(numBuckets);
<a name="l01095"></a>01095   <span class="keywordflow">for</span> (std::size_t b=0; b &lt; buckets.size(); b++) {
<a name="l01096"></a>01096     stk::mesh::Bucket&amp; buck = *buckets[b];
<a name="l01097"></a>01097     <span class="keywordflow">for</span> (QPScalarState::iterator qpss = qpscalar_states.begin();
<a name="l01098"></a>01098               qpss != qpscalar_states.end(); ++qpss){
<a name="l01099"></a>01099       stk::mesh::BucketArray&lt;Albany::AbstractSTKFieldContainer::QPScalarFieldType&gt; array(**qpss, buck);
<a name="l01100"></a>01100 <span class="comment">//Debug</span>
<a name="l01101"></a>01101 <span class="comment">//std::cout &lt;&lt; &quot;Buck.size(): &quot; &lt;&lt; buck.size() &lt;&lt; &quot; QPSFT dim[1]: &quot; &lt;&lt; array.dimension(1) &lt;&lt; std::endl;</span>
<a name="l01102"></a>01102       <a class="code" href="namespaceAlbany.html#a76b8c026e962fe80abcca7402bdad39b">MDArray</a> ar = array;
<a name="l01103"></a>01103       <a class="code" href="classAlbany_1_1STKDiscretization.html#a3288951a08528ecf0cfe7ff9efdfe3ae">stateArrays</a>.<a class="code" href="structAlbany_1_1StateArrays.html#a5fa0a75997a1a3135dbd2559ad4e0e8f">elemStateArrays</a>[b][(*qpss)-&gt;name()] = ar;
<a name="l01104"></a>01104     }
<a name="l01105"></a>01105     <span class="keywordflow">for</span> (QPVectorState::iterator qpvs = qpvector_states.begin();
<a name="l01106"></a>01106               qpvs != qpvector_states.end(); ++qpvs){
<a name="l01107"></a>01107       stk::mesh::BucketArray&lt;Albany::AbstractSTKFieldContainer::QPVectorFieldType&gt; array(**qpvs, buck);
<a name="l01108"></a>01108 <span class="comment">//Debug</span>
<a name="l01109"></a>01109 <span class="comment">//std::cout &lt;&lt; &quot;Buck.size(): &quot; &lt;&lt; buck.size() &lt;&lt; &quot; QPVFT dim[2]: &quot; &lt;&lt; array.dimension(2) &lt;&lt; std::endl;</span>
<a name="l01110"></a>01110       <a class="code" href="namespaceAlbany.html#a76b8c026e962fe80abcca7402bdad39b">MDArray</a> ar = array;
<a name="l01111"></a>01111       <a class="code" href="classAlbany_1_1STKDiscretization.html#a3288951a08528ecf0cfe7ff9efdfe3ae">stateArrays</a>.<a class="code" href="structAlbany_1_1StateArrays.html#a5fa0a75997a1a3135dbd2559ad4e0e8f">elemStateArrays</a>[b][(*qpvs)-&gt;name()] = ar;
<a name="l01112"></a>01112     }
<a name="l01113"></a>01113     <span class="keywordflow">for</span> (QPTensorState::iterator qpts = qptensor_states.begin();
<a name="l01114"></a>01114               qpts != qptensor_states.end(); ++qpts){
<a name="l01115"></a>01115       stk::mesh::BucketArray&lt;Albany::AbstractSTKFieldContainer::QPTensorFieldType&gt; array(**qpts, buck);
<a name="l01116"></a>01116 <span class="comment">//Debug</span>
<a name="l01117"></a>01117 <span class="comment">//std::cout &lt;&lt; &quot;Buck.size(): &quot; &lt;&lt; buck.size() &lt;&lt; &quot; QPTFT dim[3]: &quot; &lt;&lt; array.dimension(3) &lt;&lt; std::endl;</span>
<a name="l01118"></a>01118       <a class="code" href="namespaceAlbany.html#a76b8c026e962fe80abcca7402bdad39b">MDArray</a> ar = array;
<a name="l01119"></a>01119       <a class="code" href="classAlbany_1_1STKDiscretization.html#a3288951a08528ecf0cfe7ff9efdfe3ae">stateArrays</a>.<a class="code" href="structAlbany_1_1StateArrays.html#a5fa0a75997a1a3135dbd2559ad4e0e8f">elemStateArrays</a>[b][(*qpts)-&gt;name()] = ar;
<a name="l01120"></a>01120     }
<a name="l01121"></a>01121     <span class="keywordflow">for</span> (ScalarValueState::iterator svs = scalarValue_states.begin();
<a name="l01122"></a>01122               svs != scalarValue_states.end(); ++svs){
<a name="l01123"></a>01123       <span class="keyword">const</span> <span class="keywordtype">int</span> size = 1;
<a name="l01124"></a>01124       shards::Array&lt;double, shards::NaturalOrder, Cell&gt; array(&amp;time, size);
<a name="l01125"></a>01125       <a class="code" href="namespaceAlbany.html#a76b8c026e962fe80abcca7402bdad39b">MDArray</a> ar = array;
<a name="l01126"></a>01126       <a class="code" href="classAlbany_1_1STKDiscretization.html#a3288951a08528ecf0cfe7ff9efdfe3ae">stateArrays</a>.<a class="code" href="structAlbany_1_1StateArrays.html#a5fa0a75997a1a3135dbd2559ad4e0e8f">elemStateArrays</a>[b][*svs] = ar;
<a name="l01127"></a>01127     }
<a name="l01128"></a>01128   }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130 <span class="comment">// Process node data sets if present</span>
<a name="l01131"></a>01131 
<a name="l01132"></a>01132   <span class="keywordflow">if</span>(Teuchos::nonnull(<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nodal_data_block)){
<a name="l01133"></a>01133 
<a name="l01134"></a>01134     Teuchos::RCP&lt;Albany::NodeFieldContainer&gt; node_states = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nodal_data_block-&gt;getNodeContainer();
<a name="l01135"></a>01135   
<a name="l01136"></a>01136     stk::mesh::get_buckets( select_owned_in_part ,
<a name="l01137"></a>01137                             <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>.buckets( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.node_rank() ) ,
<a name="l01138"></a>01138                             buckets);
<a name="l01139"></a>01139   
<a name="l01140"></a>01140     numBuckets =  buckets.size();
<a name="l01141"></a>01141   
<a name="l01142"></a>01142     <a class="code" href="classAlbany_1_1STKDiscretization.html#a3288951a08528ecf0cfe7ff9efdfe3ae">stateArrays</a>.<a class="code" href="structAlbany_1_1StateArrays.html#a93330d27ac0e1f884c7d0fae751e2741">nodeStateArrays</a>.resize(numBuckets);
<a name="l01143"></a>01143     <span class="keywordflow">for</span> (std::size_t b=0; b &lt; buckets.size(); b++) {
<a name="l01144"></a>01144       stk::mesh::Bucket&amp; buck = *buckets[b];
<a name="l01145"></a>01145       <span class="keywordflow">for</span> (Albany::NodeFieldContainer::iterator nfs = node_states-&gt;begin();
<a name="l01146"></a>01146                 nfs != node_states-&gt;end(); ++nfs){
<a name="l01147"></a>01147         <a class="code" href="classAlbany_1_1STKDiscretization.html#a3288951a08528ecf0cfe7ff9efdfe3ae">stateArrays</a>.<a class="code" href="structAlbany_1_1StateArrays.html#a93330d27ac0e1f884c7d0fae751e2741">nodeStateArrays</a>[b][(*nfs).first] = 
<a name="l01148"></a>01148              Teuchos::rcp_dynamic_cast&lt;<a class="code" href="classAlbany_1_1AbstractSTKNodeFieldContainer.html" title="Abstract interface for an STK NodeField container.">Albany::AbstractSTKNodeFieldContainer</a>&gt;((*nfs).second)-&gt;getMDA(buck);
<a name="l01149"></a>01149       }
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151   }
<a name="l01152"></a>01152 }
<a name="l01153"></a>01153 
<a name="l01154"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a0c571fc5f3153f4b0d3fe930d10fe885">01154</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a0c571fc5f3153f4b0d3fe930d10fe885" title="Process STK mesh for SideSets.">Albany::STKDiscretization::computeSideSets</a>(){
<a name="l01155"></a>01155 
<a name="l01156"></a>01156   <span class="comment">// Clean up existing sideset structure if remeshing</span>
<a name="l01157"></a>01157 
<a name="l01158"></a>01158   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a87dfe5a76419096fc505dd0b3b2fb6ea" title="side sets stored as std::map(string ID, SideArray classes) per workset (std::vector across worksets)...">sideSets</a>.size(); i++)
<a name="l01159"></a>01159     <a class="code" href="classAlbany_1_1STKDiscretization.html#a87dfe5a76419096fc505dd0b3b2fb6ea" title="side sets stored as std::map(string ID, SideArray classes) per workset (std::vector across worksets)...">sideSets</a>[i].clear(); <span class="comment">// empty the ith map</span>
<a name="l01160"></a>01160 
<a name="l01161"></a>01161   <span class="keyword">const</span> <a class="code" href="namespaceAAdapt.html#a3c520a41b4eeda67a27eaa620a369bc4">stk::mesh::EntityRank</a> element_rank = <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.element_rank();
<a name="l01162"></a>01162 
<a name="l01163"></a>01163   <span class="comment">// iterator over all side_rank parts found in the mesh</span>
<a name="l01164"></a>01164   std::map&lt;std::string, stk::mesh::Part*&gt;::iterator ss = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;ssPartVec.begin();
<a name="l01165"></a>01165 
<a name="l01166"></a>01166   <span class="keywordtype">int</span> numBuckets = <a class="code" href="classAlbany_1_1STKDiscretization.html#a31fce9e12eb182345cc1d514c212bee7">wsEBNames</a>.size();
<a name="l01167"></a>01167 
<a name="l01168"></a>01168   <a class="code" href="classAlbany_1_1STKDiscretization.html#a87dfe5a76419096fc505dd0b3b2fb6ea" title="side sets stored as std::map(string ID, SideArray classes) per workset (std::vector across worksets)...">sideSets</a>.resize(numBuckets); <span class="comment">// Need a sideset list per workset</span>
<a name="l01169"></a>01169 
<a name="l01170"></a>01170   <span class="keywordflow">while</span> ( ss != <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;ssPartVec.end() ) {
<a name="l01171"></a>01171 
<a name="l01172"></a>01172     <span class="comment">// Get all owned sides in this side set</span>
<a name="l01173"></a>01173     stk::mesh::Selector select_owned_in_sspart =
<a name="l01174"></a>01174 
<a name="l01175"></a>01175       <span class="comment">// get only entities in the ss part (ss-&gt;second is the current sideset part)</span>
<a name="l01176"></a>01176       stk::mesh::Selector( *(ss-&gt;second) ) &amp;
<a name="l01177"></a>01177       <span class="comment">// and only if the part is local</span>
<a name="l01178"></a>01178       stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part() );
<a name="l01179"></a>01179 
<a name="l01180"></a>01180     std::vector&lt; stk::mesh::Entity * &gt; sides ;
<a name="l01181"></a>01181     stk::mesh::get_selected_entities( select_owned_in_sspart , <span class="comment">// sides local to this processor</span>
<a name="l01182"></a>01182               <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>.buckets( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.side_rank() ) ,
<a name="l01183"></a>01183               sides ); <span class="comment">// store the result in &quot;sides&quot;</span>
<a name="l01184"></a>01184 
<a name="l01185"></a>01185     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;STKDisc: sideset &quot;</span>&lt;&lt; ss-&gt;first &lt;&lt;<span class="stringliteral">&quot; has size &quot;</span> &lt;&lt; sides.size() &lt;&lt; <span class="stringliteral">&quot;  on Proc 0.&quot;</span> &lt;&lt; std::endl;
<a name="l01186"></a>01186 
<a name="l01187"></a>01187     <span class="comment">// loop over the sides to see what they are, then fill in the data holder</span>
<a name="l01188"></a>01188     <span class="comment">// for side set options, look at $TRILINOS_DIR/packages/stk/stk_usecases/mesh/UseCase_13.cpp</span>
<a name="l01189"></a>01189 
<a name="l01190"></a>01190     <span class="keywordflow">for</span> (std::size_t localSideID=0; localSideID &lt; sides.size(); localSideID++) {
<a name="l01191"></a>01191 
<a name="l01192"></a>01192       <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a> &amp;sidee = *sides[localSideID];
<a name="l01193"></a>01193 
<a name="l01194"></a>01194       <span class="keyword">const</span> stk::mesh::PairIterRelation side_elems = sidee.relations(element_rank); <span class="comment">// get the elements</span>
<a name="l01195"></a>01195             <span class="comment">// containing the side. Note that if the side is internal, it will show up twice in the</span>
<a name="l01196"></a>01196             <span class="comment">// element list, once for each element that contains it.</span>
<a name="l01197"></a>01197 
<a name="l01198"></a>01198       TEUCHOS_TEST_FOR_EXCEPTION(side_elems.size() != 1, std::logic_error,
<a name="l01199"></a>01199          <span class="stringliteral">&quot;STKDisc: cannot figure out side set topology for side set &quot;</span> &lt;&lt; ss-&gt;first &lt;&lt; std::endl);
<a name="l01200"></a>01200 
<a name="l01201"></a>01201       <span class="keyword">const</span> <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a> &amp; elem = *side_elems[0].entity();
<a name="l01202"></a>01202 
<a name="l01203"></a>01203       <a class="code" href="classAlbany_1_1SideStruct.html">SideStruct</a> sStruct;
<a name="l01204"></a>01204 
<a name="l01205"></a>01205       <span class="comment">// Save elem id. This is the global element id</span>
<a name="l01206"></a>01206       sStruct.<a class="code" href="classAlbany_1_1SideStruct.html#a50506ee9fc0595d300b04254e53a4793">elem_GID</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(elem);
<a name="l01207"></a>01207 
<a name="l01208"></a>01208       <span class="keywordtype">int</span> workset = <a class="code" href="classAlbany_1_1STKDiscretization.html#a5d79536cef04ef59e0ebb80f43c37b85" title="Connectivity map from elementGID to workset and LID in workset.">elemGIDws</a>[sStruct.<a class="code" href="classAlbany_1_1SideStruct.html#a50506ee9fc0595d300b04254e53a4793">elem_GID</a>].ws; <span class="comment">// Get the ws that this element lives in</span>
<a name="l01209"></a>01209 
<a name="l01210"></a>01210       <span class="comment">// Save elem id. This is the local element id within the workset</span>
<a name="l01211"></a>01211       sStruct.<a class="code" href="classAlbany_1_1SideStruct.html#a92168f82ffe346dbbfb6f342c118bda6">elem_LID</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a5d79536cef04ef59e0ebb80f43c37b85" title="Connectivity map from elementGID to workset and LID in workset.">elemGIDws</a>[sStruct.<a class="code" href="classAlbany_1_1SideStruct.html#a50506ee9fc0595d300b04254e53a4793">elem_GID</a>].LID;
<a name="l01212"></a>01212 
<a name="l01213"></a>01213       <span class="comment">// Save the side identifier inside of the element. This starts at zero here.</span>
<a name="l01214"></a>01214       sStruct.<a class="code" href="classAlbany_1_1SideStruct.html#aef6d3d9d010972a218940d8c776fd178">side_local_id</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#ae07c6bd96dd7f435b309583aa43ebb87" title="Find the local side id number within parent element.">determine_local_side_id</a>(elem, sidee);
<a name="l01215"></a>01215 
<a name="l01216"></a>01216       <span class="comment">// Save the index of the element block that this elem lives in</span>
<a name="l01217"></a>01217       sStruct.<a class="code" href="classAlbany_1_1SideStruct.html#a393e973e78d18e4957af1d4c96d41024">elem_ebIndex</a> = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;ebNameToIndex[<a class="code" href="classAlbany_1_1STKDiscretization.html#a31fce9e12eb182345cc1d514c212bee7">wsEBNames</a>[workset]];
<a name="l01218"></a>01218 
<a name="l01219"></a>01219       <a class="code" href="namespaceAlbany.html#aa0bc1b08430527fdeb81b86e76b48e1e">SideSetList</a>&amp; ssList = <a class="code" href="classAlbany_1_1STKDiscretization.html#a87dfe5a76419096fc505dd0b3b2fb6ea" title="side sets stored as std::map(string ID, SideArray classes) per workset (std::vector across worksets)...">sideSets</a>[workset];   <span class="comment">// Get a ref to the side set map for this ws</span>
<a name="l01220"></a>01220       SideSetList::iterator it = ssList.find(ss-&gt;first); <span class="comment">// Get an iterator to the correct sideset (if</span>
<a name="l01221"></a>01221                                                                 <span class="comment">// it exists)</span>
<a name="l01222"></a>01222 
<a name="l01223"></a>01223       <span class="keywordflow">if</span>(it != ssList.end()) <span class="comment">// The sideset has already been created</span>
<a name="l01224"></a>01224 
<a name="l01225"></a>01225         it-&gt;second.push_back(sStruct); <span class="comment">// Save this side to the vector that belongs to the name ss-&gt;first</span>
<a name="l01226"></a>01226 
<a name="l01227"></a>01227       <span class="keywordflow">else</span> { <span class="comment">// Add the key ss-&gt;first to the map, and the side vector to that map</span>
<a name="l01228"></a>01228 
<a name="l01229"></a>01229         std::vector&lt;SideStruct&gt; tmpSSVec;
<a name="l01230"></a>01230         tmpSSVec.push_back(sStruct);
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         ssList.insert(SideSetList::value_type(ss-&gt;first, tmpSSVec));
<a name="l01233"></a>01233 
<a name="l01234"></a>01234       }
<a name="l01235"></a>01235 
<a name="l01236"></a>01236     }
<a name="l01237"></a>01237 
<a name="l01238"></a>01238     ss++;
<a name="l01239"></a>01239   }
<a name="l01240"></a>01240 }
<a name="l01241"></a>01241 
<a name="l01242"></a>01242 <span class="keywordtype">unsigned</span>
<a name="l01243"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ae07c6bd96dd7f435b309583aa43ebb87">01243</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ae07c6bd96dd7f435b309583aa43ebb87" title="Find the local side id number within parent element.">Albany::STKDiscretization::determine_local_side_id</a>( <span class="keyword">const</span> <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a> &amp; elem , <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a> &amp; side ) {
<a name="l01244"></a>01244 
<a name="l01245"></a>01245   <span class="keyword">using namespace </span>stk;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247   <span class="keyword">const</span> CellTopologyData * <span class="keyword">const</span> elem_top = mesh::fem::get_cell_topology( elem ).getCellTopologyData();
<a name="l01248"></a>01248 
<a name="l01249"></a>01249   <span class="keyword">const</span> mesh::PairIterRelation elem_nodes = elem.relations( <a class="code" href="namespaceLCM.html#aa02fb502678bc30e839b2493267c2fbc">mesh::fem::FEMMetaData::NODE_RANK</a> );
<a name="l01250"></a>01250   <span class="keyword">const</span> mesh::PairIterRelation side_nodes = side.relations( <a class="code" href="namespaceLCM.html#aa02fb502678bc30e839b2493267c2fbc">mesh::fem::FEMMetaData::NODE_RANK</a> );
<a name="l01251"></a>01251 
<a name="l01252"></a>01252   <span class="keywordtype">int</span> side_id = -1 ;
<a name="l01253"></a>01253 
<a name="l01254"></a>01254   <span class="keywordflow">if</span>(elem_nodes.size() == 0 || side_nodes.size() == 0){ <span class="comment">// Node relations are not present, look at elem-&gt;face</span>
<a name="l01255"></a>01255 
<a name="l01256"></a>01256     <span class="keywordtype">int</span> elem_rank = elem.entity_rank();
<a name="l01257"></a>01257     <span class="keyword">const</span> mesh::PairIterRelation elem_sides = elem.relations( elem_rank - 1);
<a name="l01258"></a>01258 
<a name="l01259"></a>01259     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0 ; i &lt; elem_sides.size() ; ++i ) {
<a name="l01260"></a>01260 
<a name="l01261"></a>01261       <span class="keyword">const</span> <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a> &amp; elem_side = *elem_sides[i].entity();
<a name="l01262"></a>01262 
<a name="l01263"></a>01263       <span class="keywordflow">if</span>(elem_side.identifier() == side.identifier()){ <span class="comment">// Found the local side in the element</span>
<a name="l01264"></a>01264 
<a name="l01265"></a>01265          side_id = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(i);
<a name="l01266"></a>01266 
<a name="l01267"></a>01267          <span class="keywordflow">return</span> side_id;
<a name="l01268"></a>01268 
<a name="l01269"></a>01269       }
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273     <span class="keywordflow">if</span> ( side_id &lt; 0 ) {
<a name="l01274"></a>01274       std::ostringstream msg ;
<a name="l01275"></a>01275       msg &lt;&lt; <span class="stringliteral">&quot;determine_local_side_id( &quot;</span> ;
<a name="l01276"></a>01276       msg &lt;&lt; elem_top-&gt;name ;
<a name="l01277"></a>01277       msg &lt;&lt; <span class="stringliteral">&quot; , Element[ &quot;</span> ;
<a name="l01278"></a>01278       msg &lt;&lt; elem.identifier();
<a name="l01279"></a>01279       msg &lt;&lt; <span class="stringliteral">&quot; ]{&quot;</span> ;
<a name="l01280"></a>01280       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0 ; i &lt; elem_sides.size() ; ++i ) {
<a name="l01281"></a>01281         msg &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; elem_sides[i].entity()-&gt;identifier();
<a name="l01282"></a>01282       }
<a name="l01283"></a>01283       msg &lt;&lt; <span class="stringliteral">&quot; } , Side[ &quot;</span> ;
<a name="l01284"></a>01284       msg &lt;&lt; side.identifier();
<a name="l01285"></a>01285       msg &lt;&lt; <span class="stringliteral">&quot; ] ) FAILED&quot;</span> ;
<a name="l01286"></a>01286       <span class="keywordflow">throw</span> std::runtime_error( msg.str() );
<a name="l01287"></a>01287     }
<a name="l01288"></a>01288 
<a name="l01289"></a>01289   }
<a name="l01290"></a>01290   <span class="keywordflow">else</span> { <span class="comment">// Conventional elem-&gt;node - side-&gt;node connectivity present</span>
<a name="l01291"></a>01291 
<a name="l01292"></a>01292     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0 ; side_id == -1 &amp;&amp; i &lt; elem_top-&gt;side_count ; ++i ) {
<a name="l01293"></a>01293       <span class="keyword">const</span> CellTopologyData &amp; side_top = * elem_top-&gt;side[i].topology ;
<a name="l01294"></a>01294       <span class="keyword">const</span> <span class="keywordtype">unsigned</span>     * side_map =   elem_top-&gt;side[i].node ;
<a name="l01295"></a>01295 
<a name="l01296"></a>01296       <span class="keywordflow">if</span> ( side_nodes.size() == side_top.node_count ) {
<a name="l01297"></a>01297 
<a name="l01298"></a>01298         side_id = i ;
<a name="l01299"></a>01299 
<a name="l01300"></a>01300         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> j = 0 ;
<a name="l01301"></a>01301               side_id == <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(i) &amp;&amp; j &lt; side_top.node_count ; ++j ) {
<a name="l01302"></a>01302 
<a name="l01303"></a>01303           <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">mesh::Entity</a> * <span class="keyword">const</span> elem_node = elem_nodes[ side_map[j] ].entity();
<a name="l01304"></a>01304 
<a name="l01305"></a>01305           <span class="keywordtype">bool</span> found = false ;
<a name="l01306"></a>01306 
<a name="l01307"></a>01307           <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> k = 0 ; ! found &amp;&amp; k &lt; side_top.node_count ; ++k ) {
<a name="l01308"></a>01308             found = elem_node == side_nodes[k].entity();
<a name="l01309"></a>01309           }
<a name="l01310"></a>01310 
<a name="l01311"></a>01311           <span class="keywordflow">if</span> ( ! found ) { side_id = -1 ; }
<a name="l01312"></a>01312         }
<a name="l01313"></a>01313       }
<a name="l01314"></a>01314     }
<a name="l01315"></a>01315 
<a name="l01316"></a>01316     <span class="keywordflow">if</span> ( side_id &lt; 0 ) {
<a name="l01317"></a>01317       std::ostringstream msg ;
<a name="l01318"></a>01318       msg &lt;&lt; <span class="stringliteral">&quot;determine_local_side_id( &quot;</span> ;
<a name="l01319"></a>01319       msg &lt;&lt; elem_top-&gt;name ;
<a name="l01320"></a>01320       msg &lt;&lt; <span class="stringliteral">&quot; , Element[ &quot;</span> ;
<a name="l01321"></a>01321       msg &lt;&lt; elem.identifier();
<a name="l01322"></a>01322       msg &lt;&lt; <span class="stringliteral">&quot; ]{&quot;</span> ;
<a name="l01323"></a>01323       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0 ; i &lt; elem_nodes.size() ; ++i ) {
<a name="l01324"></a>01324         msg &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; elem_nodes[i].entity()-&gt;identifier();
<a name="l01325"></a>01325       }
<a name="l01326"></a>01326       msg &lt;&lt; <span class="stringliteral">&quot; } , Side[ &quot;</span> ;
<a name="l01327"></a>01327       msg &lt;&lt; side.identifier();
<a name="l01328"></a>01328       msg &lt;&lt; <span class="stringliteral">&quot; ]{&quot;</span> ;
<a name="l01329"></a>01329       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0 ; i &lt; side_nodes.size() ; ++i ) {
<a name="l01330"></a>01330         msg &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; side_nodes[i].entity()-&gt;identifier();
<a name="l01331"></a>01331       }
<a name="l01332"></a>01332       msg &lt;&lt; <span class="stringliteral">&quot; } ) FAILED&quot;</span> ;
<a name="l01333"></a>01333       <span class="keywordflow">throw</span> std::runtime_error( msg.str() );
<a name="l01334"></a>01334     }
<a name="l01335"></a>01335   }
<a name="l01336"></a>01336 
<a name="l01337"></a>01337   <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(side_id) ;
<a name="l01338"></a>01338 }
<a name="l01339"></a>01339 
<a name="l01340"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a4cc7530b6ea21955ec42ab464ba58b56">01340</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a4cc7530b6ea21955ec42ab464ba58b56" title="Process STK mesh for NodeSets.">Albany::STKDiscretization::computeNodeSets</a>()
<a name="l01341"></a>01341 {
<a name="l01342"></a>01342 
<a name="l01343"></a>01343   std::map&lt;std::string, stk::mesh::Part*&gt;::iterator ns = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nsPartVec.begin();
<a name="l01344"></a>01344   <a class="code" href="classAlbany_1_1AbstractSTKFieldContainer.html#ab29b7b67367d394e0364838c6e3fcf73">AbstractSTKFieldContainer::VectorFieldType</a>* coordinates_field = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;getCoordinatesField();
<a name="l01345"></a>01345 
<a name="l01346"></a>01346   <span class="keywordflow">while</span> ( ns != <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nsPartVec.end() ) { <span class="comment">// Iterate over Node Sets</span>
<a name="l01347"></a>01347     <span class="comment">// Get all owned nodes in this node set</span>
<a name="l01348"></a>01348     stk::mesh::Selector select_owned_in_nspart =
<a name="l01349"></a>01349       stk::mesh::Selector( *(ns-&gt;second) ) &amp;
<a name="l01350"></a>01350       stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part() );
<a name="l01351"></a>01351 
<a name="l01352"></a>01352     std::vector&lt; stk::mesh::Entity * &gt; nodes ;
<a name="l01353"></a>01353     stk::mesh::get_selected_entities( select_owned_in_nspart ,
<a name="l01354"></a>01354               <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>.buckets( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.node_rank() ) ,
<a name="l01355"></a>01355               nodes );
<a name="l01356"></a>01356 
<a name="l01357"></a>01357     <a class="code" href="classAlbany_1_1STKDiscretization.html#ad40d96e53095960c5fa58bfa0dcc6f8e" title="node sets stored as std::map(string ID, int vector of GIDs)">nodeSets</a>[ns-&gt;first].resize(nodes.size());
<a name="l01358"></a>01358     <a class="code" href="classAlbany_1_1STKDiscretization.html#addc4e2e4c57b2041b84f09a08a46e6cb">nodeSetCoords</a>[ns-&gt;first].resize(nodes.size());
<a name="l01359"></a>01359 <span class="comment">//    nodeSetIDs.push_back(ns-&gt;first); // Grab string ID</span>
<a name="l01360"></a>01360     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;STKDisc: nodeset &quot;</span>&lt;&lt; ns-&gt;first &lt;&lt;<span class="stringliteral">&quot; has size &quot;</span> &lt;&lt; nodes.size() &lt;&lt; <span class="stringliteral">&quot;  on Proc 0.&quot;</span> &lt;&lt; std::endl;
<a name="l01361"></a>01361     <span class="keywordflow">for</span> (std::size_t i=0; i &lt; nodes.size(); i++) {
<a name="l01362"></a>01362       <span class="keywordtype">int</span> node_gid = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(nodes[i]);
<a name="l01363"></a>01363       <span class="keywordtype">int</span> node_lid = <a class="code" href="classAlbany_1_1STKDiscretization.html#a3817a81f64d947f48ce61daa21de9e06" title="Node map.">node_map</a>-&gt;LID(node_gid);
<a name="l01364"></a>01364       <a class="code" href="classAlbany_1_1STKDiscretization.html#ad40d96e53095960c5fa58bfa0dcc6f8e" title="node sets stored as std::map(string ID, int vector of GIDs)">nodeSets</a>[ns-&gt;first][i].resize(<a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a>);
<a name="l01365"></a>01365       <span class="keywordflow">for</span> (std::size_t eq=0; eq &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#aff73025620a17789769f06b3a8ac7428" title="Number of equations (and unknowns) per node.">neq</a>; eq++)  <a class="code" href="classAlbany_1_1STKDiscretization.html#ad40d96e53095960c5fa58bfa0dcc6f8e" title="node sets stored as std::map(string ID, int vector of GIDs)">nodeSets</a>[ns-&gt;first][i][eq] = <a class="code" href="classAlbany_1_1STKDiscretization.html#aaee464f8a7390571d4d9b2090d30c588" title="Locate nodal dofs in non-overlapping vectors using local indexing.">getOwnedDOF</a>(node_lid,eq);
<a name="l01366"></a>01366       <a class="code" href="classAlbany_1_1STKDiscretization.html#addc4e2e4c57b2041b84f09a08a46e6cb">nodeSetCoords</a>[ns-&gt;first][i] = stk::mesh::field_data(*coordinates_field, *nodes[i]);
<a name="l01367"></a>01367     }
<a name="l01368"></a>01368     ns++;
<a name="l01369"></a>01369   }
<a name="l01370"></a>01370 }
<a name="l01371"></a>01371 
<a name="l01372"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a5970626a8f7747d0ecf05ed16abfeffd">01372</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a5970626a8f7747d0ecf05ed16abfeffd" title="Call stk_io for creating exodus output file.">Albany::STKDiscretization::setupExodusOutput</a>()
<a name="l01373"></a>01373 {
<a name="l01374"></a>01374 <span class="preprocessor">#ifdef ALBANY_SEACAS</span>
<a name="l01375"></a>01375 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutput) {
<a name="l01376"></a>01376 
<a name="l01377"></a>01377     outputInterval = 0;
<a name="l01378"></a>01378 
<a name="l01379"></a>01379     std::string str = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutFile;
<a name="l01380"></a>01380 
<a name="l01381"></a>01381     Ioss::Init::Initializer io;
<a name="l01382"></a>01382     mesh_data = <span class="keyword">new</span> stk::io::MeshData();
<a name="l01383"></a>01383     stk::io::create_output_mesh(str,
<a name="l01384"></a>01384       <a class="code" href="namespaceAlbany.html#a15bbfa6de65c4c7e0314fb5589e7d041">Albany::getMpiCommFromEpetraComm</a>(*<a class="code" href="classAlbany_1_1STKDiscretization.html#a8f1060bd41ba7b2904cbabb0cac84455" title="Epetra communicator.">comm</a>),
<a name="l01385"></a>01385       <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>, *mesh_data);
<a name="l01386"></a>01386 
<a name="l01387"></a>01387     stk::io::define_output_fields(*mesh_data, <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>);
<a name="l01388"></a>01388 
<a name="l01389"></a>01389   }
<a name="l01390"></a>01390 <span class="preprocessor">#else</span>
<a name="l01391"></a>01391 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutput)
<a name="l01392"></a>01392     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;\nWARNING: exodus output requested but SEACAS not compiled in:&quot;</span>
<a name="l01393"></a>01393          &lt;&lt; <span class="stringliteral">&quot; disabling exodus output \n&quot;</span> &lt;&lt; std::endl;
<a name="l01394"></a>01394 
<a name="l01395"></a>01395 <span class="preprocessor">#endif</span>
<a name="l01396"></a>01396 <span class="preprocessor"></span>}
<a name="l01397"></a>01397 
<a name="l01398"></a>01398 <span class="keyword">namespace </span>{
<a name="l01399"></a>01399   <span class="keyword">const</span> std::vector&lt;double&gt; spherical_to_cart(<span class="keyword">const</span> std::pair&lt;double, double&gt; &amp; sphere){
<a name="l01400"></a>01400     <span class="keyword">const</span> <span class="keywordtype">double</span> radius_of_earth = 1;
<a name="l01401"></a>01401     std::vector&lt;double&gt; cart(3);
<a name="l01402"></a>01402 
<a name="l01403"></a>01403     cart[0] = radius_of_earth*std::cos(sphere.first)*std::cos(sphere.second);
<a name="l01404"></a>01404     cart[1] = radius_of_earth*std::cos(sphere.first)*std::sin(sphere.second);
<a name="l01405"></a>01405     cart[2] = radius_of_earth*std::sin(sphere.first);
<a name="l01406"></a>01406 
<a name="l01407"></a>01407     <span class="keywordflow">return</span> cart;
<a name="l01408"></a>01408   }
<a name="l01409"></a>01409   <span class="keywordtype">double</span> <a class="code" href="AAdapt__STKUnifSizeField_8cpp.html#a97b9b783cb5739b02598f16a8dc0124a">distance</a> (<span class="keyword">const</span> <span class="keywordtype">double</span>* x, <span class="keyword">const</span> <span class="keywordtype">double</span>* y) {
<a name="l01410"></a>01410     <span class="keyword">const</span> <span class="keywordtype">double</span> d = std::sqrt((x[0]-y[0])*(x[0]-y[0]) + 
<a name="l01411"></a>01411                                (x[1]-y[1])*(x[1]-y[1]) + 
<a name="l01412"></a>01412                                (x[2]-y[2])*(x[2]-y[2]));
<a name="l01413"></a>01413     <span class="keywordflow">return</span> d;
<a name="l01414"></a>01414   }
<a name="l01415"></a>01415   <span class="keywordtype">double</span> <a class="code" href="AAdapt__STKUnifSizeField_8cpp.html#a97b9b783cb5739b02598f16a8dc0124a">distance</a> (<span class="keyword">const</span> std::vector&lt;double&gt; &amp;x, <span class="keyword">const</span> std::vector&lt;double&gt; &amp;y) {
<a name="l01416"></a>01416     <span class="keyword">const</span> <span class="keywordtype">double</span> d = std::sqrt((x[0]-y[0])*(x[0]-y[0]) + 
<a name="l01417"></a>01417                                (x[1]-y[1])*(x[1]-y[1]) + 
<a name="l01418"></a>01418                                (x[2]-y[2])*(x[2]-y[2]));
<a name="l01419"></a>01419     <span class="keywordflow">return</span> d;
<a name="l01420"></a>01420   }
<a name="l01421"></a>01421   
<a name="l01422"></a>01422   <span class="keywordtype">bool</span> point_inside(<span class="keyword">const</span> Teuchos::ArrayRCP&lt;double*&gt; &amp;coords, 
<a name="l01423"></a>01423                     <span class="keyword">const</span> std::vector&lt;double&gt;        &amp;sphere_xyz) {
<a name="l01424"></a>01424     <span class="comment">// first check if point is near the element:</span>
<a name="l01425"></a>01425     <span class="keyword">const</span> <span class="keywordtype">double</span>  tol_inside = 1e-12;
<a name="l01426"></a>01426     <span class="keyword">const</span> <span class="keywordtype">double</span> elem_diam = std::max(::<a class="code" href="AAdapt__STKUnifSizeField_8cpp.html#a97b9b783cb5739b02598f16a8dc0124a">distance</a>(coords[0],coords[2]), ::<a class="code" href="AAdapt__STKUnifSizeField_8cpp.html#a97b9b783cb5739b02598f16a8dc0124a">distance</a>(coords[1],coords[3]));
<a name="l01427"></a>01427     std::vector&lt;double&gt; center(3,0);
<a name="l01428"></a>01428     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;4; ++i) 
<a name="l01429"></a>01429       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;3; ++j) center[j] += coords[i][j];
<a name="l01430"></a>01430     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;3; ++j) center[j] /= 4;
<a name="l01431"></a>01431     <span class="keywordtype">bool</span> inside = <span class="keyword">true</span>;
<a name="l01432"></a>01432     
<a name="l01433"></a>01433     <span class="keywordflow">if</span> ( ::<a class="code" href="AAdapt__STKUnifSizeField_8cpp.html#a97b9b783cb5739b02598f16a8dc0124a">distance</a>(&amp;center[0],&amp;sphere_xyz[0]) &gt; 1.0*elem_diam ) inside = <span class="keyword">false</span>;
<a name="l01434"></a>01434 
<a name="l01435"></a>01435     <span class="keywordtype">unsigned</span> j=3;
<a name="l01436"></a>01436     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;4 &amp;&amp; inside; ++i) {
<a name="l01437"></a>01437       std::vector&lt;double&gt; cross(3);
<a name="l01438"></a>01438       <span class="comment">// outward normal to plane containing j-&gt;i edge:  corner(i) x corner(j)</span>
<a name="l01439"></a>01439       <span class="comment">// sphere dot (corner(i) x corner(j) ) = negative if inside</span>
<a name="l01440"></a>01440       cross[0]=  coords[i][1]*coords[j][2] - coords[i][2]*coords[j][1];
<a name="l01441"></a>01441       cross[1]=-(coords[i][0]*coords[j][2] - coords[i][2]*coords[j][0]);
<a name="l01442"></a>01442       cross[2]=  coords[i][0]*coords[j][1] - coords[i][1]*coords[j][0];
<a name="l01443"></a>01443       j = i;
<a name="l01444"></a>01444       <span class="keyword">const</span> <span class="keywordtype">double</span> dotprod = cross[0]*sphere_xyz[0] + 
<a name="l01445"></a>01445                              cross[1]*sphere_xyz[1] + 
<a name="l01446"></a>01446                              cross[2]*sphere_xyz[2];
<a name="l01447"></a>01447       
<a name="l01448"></a>01448       <span class="comment">// dot product is proportional to elem_diam. positive means outside,</span>
<a name="l01449"></a>01449       <span class="comment">// but allow machine precision tolorence: </span>
<a name="l01450"></a>01450       <span class="keywordflow">if</span> (tol_inside*elem_diam &lt; dotprod) inside = <span class="keyword">false</span>;
<a name="l01451"></a>01451     }         
<a name="l01452"></a>01452     <span class="keywordflow">return</span> inside;
<a name="l01453"></a>01453   }
<a name="l01454"></a>01454 
<a name="l01455"></a>01455   std::pair&lt;double, double&gt;  ref2sphere(<span class="keyword">const</span> Teuchos::ArrayRCP&lt;double*&gt; &amp;coords,
<a name="l01456"></a>01456                                          <span class="keyword">const</span> std::pair&lt;double, double&gt; &amp;ref) {
<a name="l01457"></a>01457 
<a name="l01458"></a>01458     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> DIST_THRESHOLD= 1.0e-9;
<a name="l01459"></a>01459     <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="MOR__ExtendedEpetraLapack_8cpp.html#abaab71a1a7c21d8e915288b6945891f6">a</a> = ref.first;
<a name="l01460"></a>01460     <span class="keyword">const</span> <span class="keywordtype">double</span> b = ref.second;
<a name="l01461"></a>01461     <span class="keyword">const</span> <span class="keywordtype">double</span> q[4]={ (1-a)*(1-b)/4, 
<a name="l01462"></a>01462                         (1+a)*(1-b)/4, 
<a name="l01463"></a>01463                         (1+a)*(1+b)/4, 
<a name="l01464"></a>01464                         (1-a)*(1+b)/4} ;
<a name="l01465"></a>01465   
<a name="l01466"></a>01466     <span class="keywordtype">double</span> x[3]={0,0,0};
<a name="l01467"></a>01467     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;3; ++i) 
<a name="l01468"></a>01468       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;4; ++j) 
<a name="l01469"></a>01469         x[i] += coords[j][i] * q[j];
<a name="l01470"></a>01470 
<a name="l01471"></a>01471     <span class="keyword">const</span> <span class="keywordtype">double</span> r = std::sqrt(x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);
<a name="l01472"></a>01472 
<a name="l01473"></a>01473     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;3; ++i) x[i] /= r; 
<a name="l01474"></a>01474 
<a name="l01475"></a>01475     std::pair&lt;double, double&gt; sphere(std::asin(x[2]), std::atan2(x[1],x[0]));
<a name="l01476"></a>01476 
<a name="l01477"></a>01477     <span class="comment">// ==========================================================</span>
<a name="l01478"></a>01478     <span class="comment">// enforce three facts:</span>
<a name="l01479"></a>01479     <span class="comment">//</span>
<a name="l01480"></a>01480     <span class="comment">// 1) lon at poles is defined to be zero</span>
<a name="l01481"></a>01481     <span class="comment">//</span>
<a name="l01482"></a>01482     <span class="comment">// 2) Grid points must be separated by about .01 Meter (on earth)</span>
<a name="l01483"></a>01483     <span class="comment">//   from pole to be considered &quot;not the pole&quot;.</span>
<a name="l01484"></a>01484     <span class="comment">//</span>
<a name="l01485"></a>01485     <span class="comment">// 3) range of lon is { 0&lt;= lon &lt; 2*PI }</span>
<a name="l01486"></a>01486     <span class="comment">//</span>
<a name="l01487"></a>01487     <span class="comment">// ==========================================================</span>
<a name="l01488"></a>01488 
<a name="l01489"></a>01489     <span class="keywordflow">if</span> (std::abs(std::abs(sphere.first)-<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/2) &lt; DIST_THRESHOLD) sphere.second = 0;
<a name="l01490"></a>01490     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sphere.second &lt; 0) sphere.second += 2*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>;
<a name="l01491"></a>01491 
<a name="l01492"></a>01492     <span class="keywordflow">return</span> sphere;
<a name="l01493"></a>01493   }
<a name="l01494"></a>01494 
<a name="l01495"></a>01495   <span class="keywordtype">void</span> Dmap(<span class="keyword">const</span> Teuchos::ArrayRCP&lt;double*&gt; &amp;coords,
<a name="l01496"></a>01496             <span class="keyword">const</span> std::pair&lt;double, double&gt;  &amp;sphere,
<a name="l01497"></a>01497             <span class="keyword">const</span> std::pair&lt;double, double&gt;  &amp;ref,
<a name="l01498"></a>01498             <span class="keywordtype">double</span> D[][2]) {
<a name="l01499"></a>01499 
<a name="l01500"></a>01500     <span class="keyword">const</span> <span class="keywordtype">double</span> th     = sphere.first;
<a name="l01501"></a>01501     <span class="keyword">const</span> <span class="keywordtype">double</span> lam    = sphere.second; 
<a name="l01502"></a>01502     <span class="keyword">const</span> <span class="keywordtype">double</span> sinlam = std::sin(lam); 
<a name="l01503"></a>01503     <span class="keyword">const</span> <span class="keywordtype">double</span> sinth  = std::sin(th);
<a name="l01504"></a>01504     <span class="keyword">const</span> <span class="keywordtype">double</span> coslam = std::cos(lam); 
<a name="l01505"></a>01505     <span class="keyword">const</span> <span class="keywordtype">double</span> costh  = std::cos(th);
<a name="l01506"></a>01506 
<a name="l01507"></a>01507     <span class="keyword">const</span> <span class="keywordtype">double</span> D1[2][3] = {{-sinlam, coslam, 0},
<a name="l01508"></a>01508                              {      0,      0, 1}};
<a name="l01509"></a>01509 
<a name="l01510"></a>01510     <span class="keyword">const</span> <span class="keywordtype">double</span> D2[3][3] = {{ sinlam*sinlam*costh*costh+sinth*sinth, -sinlam*coslam*costh*costh,             -coslam*sinth*costh},
<a name="l01511"></a>01511                              {-sinlam*coslam*costh*costh,              coslam*coslam*costh*costh+sinth*sinth, -sinlam*sinth*costh},
<a name="l01512"></a>01512                              {-coslam*sinth,                          -sinlam*sinth,                                        costh}};
<a name="l01513"></a>01513 
<a name="l01514"></a>01514     <span class="keyword">const</span> <span class="keywordtype">double</span> DD[4][2] = {{ (-1+ref.second)/4, (-1+ref.first)/4 },
<a name="l01515"></a>01515                              { ( 1-ref.second)/4, (-1-ref.first)/4 },
<a name="l01516"></a>01516                              { ( 1+ref.second)/4, ( 1+ref.first)/4 },
<a name="l01517"></a>01517                              { (-1-ref.second)/4, ( 1-ref.first)/4 }};
<a name="l01518"></a>01518 
<a name="l01519"></a>01519     <span class="keywordtype">double</span> D3[3][2] = {0};
<a name="l01520"></a>01520     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;3; ++i) 
<a name="l01521"></a>01521       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;2; ++j) 
<a name="l01522"></a>01522         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;4; ++k) 
<a name="l01523"></a>01523           D3[i][j] += coords[k][i] * DD[k][j];
<a name="l01524"></a>01524 
<a name="l01525"></a>01525     <span class="keywordtype">double</span> D4[3][2] = {0};
<a name="l01526"></a>01526     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;3; ++i) 
<a name="l01527"></a>01527       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;2; ++j) 
<a name="l01528"></a>01528         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;3; ++k) 
<a name="l01529"></a>01529            D4[i][j] += D2[i][k] * D3[k][j];
<a name="l01530"></a>01530 
<a name="l01531"></a>01531     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;2; ++i) 
<a name="l01532"></a>01532       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;2; ++j) D[i][j] = 0;
<a name="l01533"></a>01533 
<a name="l01534"></a>01534     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;2; ++i) 
<a name="l01535"></a>01535       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;2; ++j) 
<a name="l01536"></a>01536         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;3; ++k) 
<a name="l01537"></a>01537           D[i][j] += D1[i][k] * D4[k][j];
<a name="l01538"></a>01538 
<a name="l01539"></a>01539   }
<a name="l01540"></a>01540 
<a name="l01541"></a>01541   std::pair&lt;double, double&gt; parametric_coordinates(<span class="keyword">const</span> Teuchos::ArrayRCP&lt;double*&gt; &amp;coords, 
<a name="l01542"></a>01542                                                    <span class="keyword">const</span> std::pair&lt;double, double&gt;  &amp;sphere) {
<a name="l01543"></a>01543     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> tol_sq = 1e-26;
<a name="l01544"></a>01544     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> MAX_NR_ITER = 10;
<a name="l01545"></a>01545     <span class="keywordtype">double</span> costh = std::cos(sphere.first);
<a name="l01546"></a>01546     <span class="keywordtype">double</span> D[2][2], Dinv[2][2];
<a name="l01547"></a>01547     <span class="keywordtype">double</span> resa = 1;
<a name="l01548"></a>01548     <span class="keywordtype">double</span> resb = 1;
<a name="l01549"></a>01549     std::pair&lt;double, double&gt; ref(0,0); <span class="comment">// initial guess is center of element.</span>
<a name="l01550"></a>01550 
<a name="l01551"></a>01551     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;MAX_NR_ITER &amp;&amp; tol_sq &lt; (costh*resb*resb + resa*resa) ; ++i) {
<a name="l01552"></a>01552       <span class="keyword">const</span> std::pair&lt;double, double&gt; sph = ref2sphere(coords,ref);
<a name="l01553"></a>01553       resa = sph.first  - sphere.first;
<a name="l01554"></a>01554       resb = sph.second - sphere.second;
<a name="l01555"></a>01555 
<a name="l01556"></a>01556       <span class="keywordflow">if</span> (resb &gt;  <a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>) resb -= 2*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>;
<a name="l01557"></a>01557       <span class="keywordflow">if</span> (resb &lt; -<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>) resb += 2*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>;
<a name="l01558"></a>01558  
<a name="l01559"></a>01559       Dmap(coords, sph, ref, D);
<a name="l01560"></a>01560       <span class="keyword">const</span> <span class="keywordtype">double</span> detD = D[0][0]*D[1][1] - D[0][1]*D[1][0];
<a name="l01561"></a>01561       Dinv[0][0] =  D[1][1]/detD;
<a name="l01562"></a>01562       Dinv[0][1] = -D[0][1]/detD;
<a name="l01563"></a>01563       Dinv[1][0] = -D[1][0]/detD;
<a name="l01564"></a>01564       Dinv[1][1] =  D[0][0]/detD;
<a name="l01565"></a>01565  
<a name="l01566"></a>01566       <span class="keyword">const</span> std::pair&lt;double, double&gt; del( Dinv[0][0]*costh*resb + Dinv[0][1]*resa, 
<a name="l01567"></a>01567                                            Dinv[1][0]*costh*resb + Dinv[1][1]*resa);
<a name="l01568"></a>01568       ref.first  -= del.first;
<a name="l01569"></a>01569       ref.second -= del.second;
<a name="l01570"></a>01570     }
<a name="l01571"></a>01571     <span class="keywordflow">return</span> ref;
<a name="l01572"></a>01572   }
<a name="l01573"></a>01573    
<a name="l01574"></a>01574   <span class="keyword">const</span> std::pair&lt;bool,std::pair&lt;unsigned, unsigned&gt; &gt;point_in_element(<span class="keyword">const</span> std::pair&lt;double, double&gt; &amp;sphere, 
<a name="l01575"></a>01575       <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray</a>&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double*&gt; &gt; &gt;::type&amp; coords, 
<a name="l01576"></a>01576       std::pair&lt;double, double&gt; &amp;parametric) {
<a name="l01577"></a>01577     <span class="keyword">const</span> std::vector&lt;double&gt; sphere_xyz = spherical_to_cart(sphere);
<a name="l01578"></a>01578     std::pair&lt;bool,std::pair&lt;unsigned, unsigned&gt; &gt; element(<span class="keyword">false</span>,std::pair&lt;unsigned, unsigned&gt;(0,0));
<a name="l01579"></a>01579     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;coords.size() &amp;&amp; !element.first; ++i) {
<a name="l01580"></a>01580       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;coords[i].size() &amp;&amp; !element.first; ++j) {
<a name="l01581"></a>01581         <span class="keyword">const</span> <span class="keywordtype">bool</span> found =  point_inside(coords[i][j], sphere_xyz);
<a name="l01582"></a>01582         <span class="keywordflow">if</span> (found) {
<a name="l01583"></a>01583           parametric = parametric_coordinates(coords[i][j], sphere);
<a name="l01584"></a>01584           <span class="keywordflow">if</span> (parametric.first  &lt; -1) parametric.first  = -1;
<a name="l01585"></a>01585           <span class="keywordflow">if</span> (parametric.second &lt; -1) parametric.second = -1;
<a name="l01586"></a>01586           <span class="keywordflow">if</span> (1 &lt; parametric.first  ) parametric.first  =  1;
<a name="l01587"></a>01587           <span class="keywordflow">if</span> (1 &lt; parametric.second ) parametric.second =  1;
<a name="l01588"></a>01588           element.first         = <span class="keyword">true</span>;
<a name="l01589"></a>01589           element.second.first  = i;
<a name="l01590"></a>01590           element.second.second = j;
<a name="l01591"></a>01591         }
<a name="l01592"></a>01592       }
<a name="l01593"></a>01593     }
<a name="l01594"></a>01594     <span class="keywordflow">return</span> element;
<a name="l01595"></a>01595   }
<a name="l01596"></a>01596 
<a name="l01597"></a>01597   <span class="keywordtype">void</span> setup_latlon_interp(
<a name="l01598"></a>01598     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nlat, <span class="keyword">const</span> <span class="keywordtype">double</span> nlon,
<a name="l01599"></a>01599     <span class="keyword">const</span> <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray</a>&lt;Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double*&gt; &gt; &gt;::type&amp; coords,
<a name="l01600"></a>01600     <a class="code" href="structAlbany_1_1WorksetArray.html">Albany::WorksetArray</a>&lt;Teuchos::ArrayRCP&lt;std::vector&lt;Albany::STKDiscretization::interp&gt; &gt; &gt;::type&amp; interpdata,
<a name="l01601"></a>01601     <span class="keyword">const</span> Teuchos::RCP&lt;const Epetra_Comm&gt; <a class="code" href="felix__driver_8cpp.html#ab048c6f9fcbcfaa57ce68b00263dbebe">comm</a>) { 
<a name="l01602"></a>01602     
<a name="l01603"></a>01603     <span class="keywordtype">double</span> err;
<a name="l01604"></a>01604     std::vector&lt;double&gt; lat(nlat);
<a name="l01605"></a>01605     std::vector&lt;double&gt; lon(nlon);
<a name="l01606"></a>01606     
<a name="l01607"></a>01607     <span class="keywordtype">unsigned</span> count=0;
<a name="l01608"></a>01608     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;nlat; ++i) lat[i] = -<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/2 + i*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/(nlat-1);
<a name="l01609"></a>01609     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;nlon; ++i) lon[i] =       2*i*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/nlon;
<a name="l01610"></a>01610     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;nlat; ++i) {
<a name="l01611"></a>01611       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;nlon; ++j) {
<a name="l01612"></a>01612         <span class="keyword">const</span> std::pair&lt;double, double&gt; sphere(lat[i],lon[j]);
<a name="l01613"></a>01613         std::pair&lt;double, double&gt; paramtric;
<a name="l01614"></a>01614         <span class="keyword">const</span> std::pair&lt;bool,std::pair&lt;unsigned, unsigned&gt; &gt;element = point_in_element(sphere, coords, paramtric);
<a name="l01615"></a>01615         <span class="keywordflow">if</span> (element.first) {
<a name="l01616"></a>01616           <span class="comment">// compute error: map &#39;cart&#39; back to sphere and compare with original</span>
<a name="l01617"></a>01617           <span class="comment">// interpolation point:</span>
<a name="l01618"></a>01618           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> b = element.second.first ;
<a name="l01619"></a>01619           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> e = element.second.second;
<a name="l01620"></a>01620           <span class="keyword">const</span> std::vector&lt;double&gt; sphere2_xyz = spherical_to_cart(ref2sphere(coords[b][e], paramtric));
<a name="l01621"></a>01621           <span class="keyword">const</span> std::vector&lt;double&gt; sphere_xyz  = spherical_to_cart(sphere);
<a name="l01622"></a>01622           err = std::max(err, ::<a class="code" href="AAdapt__STKUnifSizeField_8cpp.html#a97b9b783cb5739b02598f16a8dc0124a">distance</a>(&amp;sphere2_xyz[0],&amp;sphere_xyz[0]));
<a name="l01623"></a>01623           <a class="code" href="structAlbany_1_1STKDiscretization_1_1interp.html" title="used when NetCDF output on a latitude-longitude grid is requested.">Albany::STKDiscretization::interp</a> interp;
<a name="l01624"></a>01624           interp.<a class="code" href="structAlbany_1_1STKDiscretization_1_1interp.html#a04b5ca2797b421f1f112b6600f8f981d">parametric_coords</a> = paramtric;
<a name="l01625"></a>01625           interp.<a class="code" href="structAlbany_1_1STKDiscretization_1_1interp.html#a87229a2245902ce60422b71265ddaea3">latitude_longitude</a> = std::pair&lt;unsigned,unsigned&gt;(i,j);
<a name="l01626"></a>01626           interpdata[b][e].push_back(interp);
<a name="l01627"></a>01627           ++count;
<a name="l01628"></a>01628         }
<a name="l01629"></a>01629       }
<a name="l01630"></a>01630       <span class="keywordflow">if</span> (!comm-&gt;MyPID() &amp;&amp; (!(i%64) || i==nlat-1)) std::cout&lt;&lt; <span class="stringliteral">&quot;Finished Latitude &quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot; of &quot;</span>&lt;&lt;nlat&lt;&lt;std::endl;
<a name="l01631"></a>01631     }
<a name="l01632"></a>01632     <span class="keywordflow">if</span> (!comm-&gt;MyPID()) std::cout&lt;&lt;<span class="stringliteral">&quot;Max interpolation point search error: &quot;</span>&lt;&lt;err&lt;&lt;std::endl;
<a name="l01633"></a>01633   }
<a name="l01634"></a>01634 
<a name="l01635"></a>01635   <span class="keywordtype">double</span> interpolate_to_point(<span class="keyword">const</span> Teuchos::ArrayRCP&lt;double&gt; height, <span class="keyword">const</span> std::pair&lt;double, double&gt; &amp;parametric) {
<a name="l01636"></a>01636     <span class="keyword">const</span> <span class="keywordtype">double</span> a = parametric.first;
<a name="l01637"></a>01637     <span class="keyword">const</span> <span class="keywordtype">double</span> b = parametric.second;
<a name="l01638"></a>01638     <span class="keyword">const</span> <span class="keywordtype">double</span> q[4]={ (1-a)*(1-b)/4, 
<a name="l01639"></a>01639                         (1+a)*(1-b)/4, 
<a name="l01640"></a>01640                         (1+a)*(1+b)/4, 
<a name="l01641"></a>01641                         (1-a)*(1+b)/4} ;
<a name="l01642"></a>01642     <span class="keywordtype">double</span> y=0;
<a name="l01643"></a>01643     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;4; ++j) y += height[j]*q[j];
<a name="l01644"></a>01644     <span class="keywordflow">return</span> y;
<a name="l01645"></a>01645   }
<a name="l01646"></a>01646 }
<a name="l01647"></a>01647 
<a name="l01648"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a1a37ea93a6d4fad70894143f5b9141be">01648</a> <span class="keywordtype">int</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a1a37ea93a6d4fad70894143f5b9141be">Albany::STKDiscretization::processNetCDFOutputRequest</a>() {
<a name="l01649"></a>01649 <span class="preprocessor">#ifdef ALBANY_SEACAS</span>
<a name="l01650"></a>01650 <span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nlat = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nLat;
<a name="l01651"></a>01651   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nlon = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nLon;
<a name="l01652"></a>01652 
<a name="l01653"></a>01653   std::vector&lt;double&gt; local(nlat*nlon, -std::numeric_limits&lt;double&gt;::max());
<a name="l01654"></a>01654 
<a name="l01655"></a>01655   <span class="keywordtype">unsigned</span> count=0;
<a name="l01656"></a>01656   Teuchos::ArrayRCP&lt;double&gt; height(4);
<a name="l01657"></a>01657   <span class="keyword">const</span> <span class="keywordtype">double</span> theta     = <a class="code" href="classAlbany_1_1STKDiscretization.html#ac89c76b13527046a37aa9e2be393d1ed">netCDFOutputRequest</a>*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/18;
<a name="l01658"></a>01658   <span class="keyword">const</span> <span class="keywordtype">double</span> rot[2][2] = {{ std::sin(theta), std::cos(theta)},
<a name="l01659"></a>01659                             {-std::cos(theta), std::sin(theta)}};
<a name="l01660"></a>01660 
<a name="l01661"></a>01661   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> b=0; b&lt;<a class="code" href="classAlbany_1_1STKDiscretization.html#adef4e8f54be774a317a446302736246e">interpolateData</a>.size(); ++b) {
<a name="l01662"></a>01662     Teuchos::ArrayRCP&lt;std::vector&lt;interp&gt; &gt;        Interpb = <a class="code" href="classAlbany_1_1STKDiscretization.html#adef4e8f54be774a317a446302736246e">interpolateData</a>[b]; 
<a name="l01663"></a>01663     Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double*&gt; &gt; Coordsb = coords[b]; 
<a name="l01664"></a>01664     <span class="comment">//Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;double&gt; &gt;  Heightb = sHeight   [b];</span>
<a name="l01665"></a>01665     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> e=0; e&lt;Interpb.size(); ++e) {
<a name="l01666"></a>01666       <span class="keyword">const</span> std::vector&lt;interp&gt;                    &amp;<a class="code" href="structAlbany_1_1STKDiscretization_1_1interp.html" title="used when NetCDF output on a latitude-longitude grid is requested.">interp</a> = Interpb[e];
<a name="l01667"></a>01667       Teuchos::ArrayRCP&lt;double*&gt;                    coordp = Coordsb[e]; 
<a name="l01668"></a>01668       <span class="comment">//const Teuchos::ArrayRCP&lt;double&gt;               height = Heightb[e]; </span>
<a name="l01669"></a>01669       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;4; ++i) height[i] =  rot[0][0]*coordp[i][0] + rot[0][1]*coordp[i][1];
<a name="l01670"></a>01670       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p=0; p&lt;interp.size(); ++p) {
<a name="l01671"></a>01671         <a class="code" href="structAlbany_1_1STKDiscretization_1_1interp.html" title="used when NetCDF output on a latitude-longitude grid is requested.">Albany::STKDiscretization::interp</a> par    = interp[p]; 
<a name="l01672"></a>01672         <span class="keywordtype">double</span> y = interpolate_to_point(height, par.<a class="code" href="structAlbany_1_1STKDiscretization_1_1interp.html#a04b5ca2797b421f1f112b6600f8f981d">parametric_coords</a>);
<a name="l01673"></a>01673         std::pair&lt;unsigned,unsigned&gt; latlon =   par.<a class="code" href="structAlbany_1_1STKDiscretization_1_1interp.html#a87229a2245902ce60422b71265ddaea3">latitude_longitude</a>;
<a name="l01674"></a>01674         local[latlon.first + nlat*latlon.second] = y;
<a name="l01675"></a>01675         ++count;
<a name="l01676"></a>01676       }
<a name="l01677"></a>01677     }
<a name="l01678"></a>01678   }
<a name="l01679"></a>01679   std::vector&lt;double&gt; global(nlat*nlon);
<a name="l01680"></a>01680   comm-&gt;MaxAll(&amp;local[0], &amp;global[0], nlat*nlon);
<a name="l01681"></a>01681 
<a name="l01682"></a>01682   <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> <a class="code" href="felix__driver_8cpp.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a> = comm-&gt;MyPID();
<a name="l01683"></a>01683 <span class="preprocessor">#ifdef ALBANY_PAR_NETCDF</span>
<a name="l01684"></a>01684 <span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> np   = comm-&gt;NumProc();
<a name="l01685"></a>01685   <span class="keyword">const</span> <span class="keywordtype">size_t</span> start            = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>((rank*nlat)/np);
<a name="l01686"></a>01686   <span class="keyword">const</span> <span class="keywordtype">size_t</span> end              = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(((rank+1)*nlat)/np);
<a name="l01687"></a>01687   <span class="keyword">const</span> <span class="keywordtype">size_t</span> len              = end-start;
<a name="l01688"></a>01688 
<a name="l01689"></a>01689   <span class="keyword">const</span> <span class="keywordtype">size_t</span>  startp[] = {<a class="code" href="classAlbany_1_1STKDiscretization.html#ac89c76b13527046a37aa9e2be393d1ed">netCDFOutputRequest</a>,    0, start, 0};
<a name="l01690"></a>01690   <span class="keyword">const</span> <span class="keywordtype">size_t</span>  countp[] = {1, 1, len, nlon};
<a name="l01691"></a>01691   <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_vara_double (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>, <a class="code" href="classAlbany_1_1STKDiscretization.html#a6f89b5361207cf61110c6b6a68279643">varHeight</a>, startp, countp, &amp;global[0]))
<a name="l01692"></a>01692     TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01693"></a>01693       <span class="stringliteral">&quot;nc_put_vara_double returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01694"></a>01694 <span class="preprocessor">#else</span>
<a name="l01695"></a>01695 <span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span>  startp[] = {<a class="code" href="classAlbany_1_1STKDiscretization.html#ac89c76b13527046a37aa9e2be393d1ed">netCDFOutputRequest</a>,    0, 0, 0};
<a name="l01696"></a>01696   <span class="keyword">const</span> <span class="keywordtype">size_t</span>  countp[] = {1, 1, nlat, nlon};
<a name="l01697"></a>01697   <span class="keywordflow">if</span> (!rank) 
<a name="l01698"></a>01698     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_vara_double (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>, <a class="code" href="classAlbany_1_1STKDiscretization.html#a6f89b5361207cf61110c6b6a68279643">varHeight</a>, startp, countp, &amp;global[0]))
<a name="l01699"></a>01699       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01700"></a>01700         <span class="stringliteral">&quot;nc_put_vara returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01701"></a>01701 <span class="preprocessor">#endif</span>
<a name="l01702"></a>01702 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01703"></a>01703 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#ac89c76b13527046a37aa9e2be393d1ed">netCDFOutputRequest</a>++;
<a name="l01704"></a>01704 }
<a name="l01705"></a>01705 
<a name="l01706"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a24e744acc8207f554efa4bd0df3ee758">01706</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a24e744acc8207f554efa4bd0df3ee758" title="Call stk_io for creating NetCDF output file.">Albany::STKDiscretization::setupNetCDFOutput</a>()
<a name="l01707"></a>01707 {
<a name="l01708"></a>01708 <span class="preprocessor">#ifdef ALBANY_SEACAS</span>
<a name="l01709"></a>01709 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutput) {
<a name="l01710"></a>01710 
<a name="l01711"></a>01711     outputInterval = 0;
<a name="l01712"></a>01712     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nlat = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nLat;
<a name="l01713"></a>01713     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nlon = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;nLon;
<a name="l01714"></a>01714 
<a name="l01715"></a>01715 
<a name="l01716"></a>01716     std::string str = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutFile;
<a name="l01717"></a>01717 
<a name="l01718"></a>01718     <a class="code" href="classAlbany_1_1STKDiscretization.html#adef4e8f54be774a317a446302736246e">interpolateData</a>.resize(coords.size());
<a name="l01719"></a>01719     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b=0; b &lt; coords.size(); b++) <a class="code" href="classAlbany_1_1STKDiscretization.html#adef4e8f54be774a317a446302736246e">interpolateData</a>[b].resize(coords[b].size());
<a name="l01720"></a>01720 
<a name="l01721"></a>01721     setup_latlon_interp(nlat, nlon, coords, <a class="code" href="classAlbany_1_1STKDiscretization.html#adef4e8f54be774a317a446302736246e">interpolateData</a>, comm);
<a name="l01722"></a>01722 
<a name="l01723"></a>01723     <span class="keyword">const</span> std::string name = <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutFile;
<a name="l01724"></a>01724     <a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>=0;
<a name="l01725"></a>01725     <a class="code" href="classAlbany_1_1STKDiscretization.html#ac89c76b13527046a37aa9e2be393d1ed">netCDFOutputRequest</a>=0;
<a name="l01726"></a>01726 
<a name="l01727"></a>01727 
<a name="l01728"></a>01728 <span class="preprocessor">#ifdef ALBANY_PAR_NETCDF</span>
<a name="l01729"></a>01729 <span class="preprocessor"></span>    MPI_Comm theMPIComm = <a class="code" href="namespaceAlbany.html#a15bbfa6de65c4c7e0314fb5589e7d041">Albany::getMpiCommFromEpetraComm</a>(*comm);
<a name="l01730"></a>01730     MPI_Info info;
<a name="l01731"></a>01731     MPI_Info_create(&amp;info);
<a name="l01732"></a>01732     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_create_par (name.c_str(), NC_NETCDF4 | NC_MPIIO | NC_CLOBBER, theMPIComm, info, &amp;<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>))
<a name="l01733"></a>01733       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01734"></a>01734         <span class="stringliteral">&quot;nc_create_par returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01735"></a>01735     MPI_Info_free(&amp;info);
<a name="l01736"></a>01736 <span class="preprocessor">#else</span>
<a name="l01737"></a>01737 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_create (name.c_str(), NC_NETCDF4 | NC_CLOBBER, &amp;<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>))
<a name="l01738"></a>01738       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01739"></a>01739         <span class="stringliteral">&quot;nc_create returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01740"></a>01740 <span class="preprocessor">#endif</span>
<a name="l01741"></a>01741 <span class="preprocessor"></span>   
<a name="l01742"></a>01742     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nlev = 1;
<a name="l01743"></a>01743     <span class="keyword">const</span> <span class="keywordtype">char</span> *dimnames[] = {<span class="stringliteral">&quot;time&quot;</span>,<span class="stringliteral">&quot;lev&quot;</span>,<span class="stringliteral">&quot;lat&quot;</span>,<span class="stringliteral">&quot;lon&quot;</span>};
<a name="l01744"></a>01744     <span class="keyword">const</span> <span class="keywordtype">size_t</span>  dimlen[] = {NC_UNLIMITED, nlev, nlat, nlon};
<a name="l01745"></a>01745     <span class="keywordtype">int</span> dimID[4]={0,0,0,0};
<a name="l01746"></a>01746 
<a name="l01747"></a>01747     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;4; ++i) {
<a name="l01748"></a>01748       <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_def_dim (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  dimnames[i], dimlen[i], &amp;dimID[i]))
<a name="l01749"></a>01749         TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01750"></a>01750           <span class="stringliteral">&quot;nc_def_dim returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01751"></a>01751     }
<a name="l01752"></a>01752     <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name = <span class="stringliteral">&quot;height&quot;</span>;
<a name="l01753"></a>01753     <a class="code" href="classAlbany_1_1STKDiscretization.html#a6f89b5361207cf61110c6b6a68279643">varHeight</a>=0;
<a name="l01754"></a>01754     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_def_var (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  field_name, NC_DOUBLE, 4, dimID, &amp;<a class="code" href="classAlbany_1_1STKDiscretization.html#a6f89b5361207cf61110c6b6a68279643">varHeight</a>))
<a name="l01755"></a>01755       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01756"></a>01756         <span class="stringliteral">&quot;nc_def_var &quot;</span>&lt;&lt;field_name&lt;&lt;<span class="stringliteral">&quot; returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01757"></a>01757     
<a name="l01758"></a>01758     <span class="keyword">const</span> <span class="keywordtype">double</span> fillVal = -9999.0;
<a name="l01759"></a>01759     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_att (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  <a class="code" href="classAlbany_1_1STKDiscretization.html#a6f89b5361207cf61110c6b6a68279643">varHeight</a>, <span class="stringliteral">&quot;FillValue&quot;</span>, NC_DOUBLE, 1, &amp;fillVal))
<a name="l01760"></a>01760       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01761"></a>01761         <span class="stringliteral">&quot;nc_put_att FillValue returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01762"></a>01762 
<a name="l01763"></a>01763     <span class="keyword">const</span> <span class="keywordtype">char</span> lat_name[] = <span class="stringliteral">&quot;latitude&quot;</span>;
<a name="l01764"></a>01764     <span class="keyword">const</span> <span class="keywordtype">char</span> lat_unit[] = <span class="stringliteral">&quot;degrees_north&quot;</span>;
<a name="l01765"></a>01765     <span class="keyword">const</span> <span class="keywordtype">char</span> lon_name[] = <span class="stringliteral">&quot;longitude&quot;</span>;
<a name="l01766"></a>01766     <span class="keyword">const</span> <span class="keywordtype">char</span> lon_unit[] = <span class="stringliteral">&quot;degrees_east&quot;</span>;
<a name="l01767"></a>01767     <span class="keywordtype">int</span> latVarID=0;
<a name="l01768"></a>01768     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_def_var (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  <span class="stringliteral">&quot;lat&quot;</span>, NC_DOUBLE, 1, &amp;dimID[3], &amp;latVarID))
<a name="l01769"></a>01769       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01770"></a>01770         <span class="stringliteral">&quot;nc_def_var lat returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01771"></a>01771     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_att_text (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  latVarID, <span class="stringliteral">&quot;long_name&quot;</span>, <span class="keyword">sizeof</span>(lat_name), lat_name))
<a name="l01772"></a>01772       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01773"></a>01773         <span class="stringliteral">&quot;nc_put_att_text &quot;</span>&lt;&lt;lat_name&lt;&lt;<span class="stringliteral">&quot; returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01774"></a>01774     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_att_text (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  latVarID, <span class="stringliteral">&quot;units&quot;</span>, <span class="keyword">sizeof</span>(lat_unit), lat_unit))
<a name="l01775"></a>01775       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01776"></a>01776         <span class="stringliteral">&quot;nc_put_att_text &quot;</span>&lt;&lt;lat_unit&lt;&lt;<span class="stringliteral">&quot; returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01777"></a>01777 
<a name="l01778"></a>01778     <span class="keywordtype">int</span> lonVarID=0;
<a name="l01779"></a>01779     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_def_var (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  <span class="stringliteral">&quot;lon&quot;</span>, NC_DOUBLE, 1, &amp;dimID[2], &amp;lonVarID))
<a name="l01780"></a>01780       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01781"></a>01781         <span class="stringliteral">&quot;nc_def_var lon returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01782"></a>01782     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_att_text (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  lonVarID, <span class="stringliteral">&quot;long_name&quot;</span>, <span class="keyword">sizeof</span>(lon_name), lon_name))
<a name="l01783"></a>01783       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01784"></a>01784         <span class="stringliteral">&quot;nc_put_att_text &quot;</span>&lt;&lt;lon_name&lt;&lt;<span class="stringliteral">&quot; returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01785"></a>01785     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_att_text (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  lonVarID, <span class="stringliteral">&quot;units&quot;</span>, <span class="keyword">sizeof</span>(lon_unit), lon_unit))
<a name="l01786"></a>01786       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01787"></a>01787         <span class="stringliteral">&quot;nc_put_att_text &quot;</span>&lt;&lt;lon_unit&lt;&lt;<span class="stringliteral">&quot; returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01788"></a>01788     
<a name="l01789"></a>01789     <span class="keyword">const</span> <span class="keywordtype">char</span> history[]=<span class="stringliteral">&quot;Created by Albany&quot;</span>;
<a name="l01790"></a>01790     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_att_text (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>,  NC_GLOBAL, <span class="stringliteral">&quot;history&quot;</span>, <span class="keyword">sizeof</span>(history), history))
<a name="l01791"></a>01791       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01792"></a>01792         <span class="stringliteral">&quot;nc_put_att_text &quot;</span>&lt;&lt;history&lt;&lt;<span class="stringliteral">&quot; returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01793"></a>01793 
<a name="l01794"></a>01794     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_enddef (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>))
<a name="l01795"></a>01795       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01796"></a>01796         <span class="stringliteral">&quot;nc_enddef returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01797"></a>01797 
<a name="l01798"></a>01798     std::vector&lt;double&gt; deglon(nlon);
<a name="l01799"></a>01799     std::vector&lt;double&gt; deglat(nlat);
<a name="l01800"></a>01800     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;nlon; ++i) deglon[i] =((      2*i*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/nlon) *   (180./<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>)) - 180.;
<a name="l01801"></a>01801     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;nlat; ++i) deglat[i] = (-<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/2 + i*<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>/(nlat-1))*(180./<a class="code" href="AAdapt__AnalyticFunction_8cpp.html#a43016d873124d39034edb8cd164794db">pi</a>);
<a name="l01802"></a>01802 
<a name="l01803"></a>01803   
<a name="l01804"></a>01804     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_var (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>, lonVarID, &amp;deglon[0]))
<a name="l01805"></a>01805       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01806"></a>01806         <span class="stringliteral">&quot;nc_put_var lon returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01807"></a>01807     <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> ierr = nc_put_var (<a class="code" href="classAlbany_1_1STKDiscretization.html#a8b0a019c8ee22c66dc52b2ba7817cdf8">netCDFp</a>, latVarID, &amp;deglat[0]))
<a name="l01808"></a>01808       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01809"></a>01809         <span class="stringliteral">&quot;nc_put_var lat returned error code &quot;</span>&lt;&lt;ierr&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt;nc_strerror(ierr)&lt;&lt;std::endl);
<a name="l01810"></a>01810 
<a name="l01811"></a>01811   }
<a name="l01812"></a>01812 <span class="preprocessor">#else</span>
<a name="l01813"></a>01813 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutput)
<a name="l01814"></a>01814     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;\nWARNING: NetCDF output requested but SEACAS not compiled in:&quot;</span>
<a name="l01815"></a>01815          &lt;&lt; <span class="stringliteral">&quot; disabling NetCDF output \n&quot;</span> &lt;&lt; std::endl;
<a name="l01816"></a>01816   <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;cdfOutput = <span class="keyword">false</span>;
<a name="l01817"></a>01817 
<a name="l01818"></a>01818 <span class="preprocessor">#endif</span>
<a name="l01819"></a>01819 <span class="preprocessor"></span>}
<a name="l01820"></a>01820 
<a name="l01821"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a017990564a1c6c22f9b1df3b6dab50d2">01821</a> <span class="keywordtype">void</span> <a class="code" href="classAlbany_1_1STKDiscretization.html#a017990564a1c6c22f9b1df3b6dab50d2" title="Close current exodus file in stk_io and create a new one for an adapted mesh and new results...">Albany::STKDiscretization::reNameExodusOutput</a>(std::string&amp; filename)
<a name="l01822"></a>01822 {
<a name="l01823"></a>01823 <span class="preprocessor">#ifdef ALBANY_SEACAS</span>
<a name="l01824"></a>01824 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutput &amp;&amp; mesh_data != NULL) {
<a name="l01825"></a>01825 
<a name="l01826"></a>01826    <span class="comment">// Delete the mesh data object and recreate it</span>
<a name="l01827"></a>01827    <span class="keyword">delete</span> mesh_data;
<a name="l01828"></a>01828 
<a name="l01829"></a>01829    <a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutFile = filename;
<a name="l01830"></a>01830 
<a name="l01831"></a>01831    <span class="comment">// reset reference value for monotonic time function call as we are writing to a new file</span>
<a name="l01832"></a>01832    <a class="code" href="classAlbany_1_1STKDiscretization.html#a2134cc877988853876df2d5446568d94">previous_time_label</a> = -1.0e32;
<a name="l01833"></a>01833 
<a name="l01834"></a>01834   }
<a name="l01835"></a>01835 <span class="preprocessor">#else</span>
<a name="l01836"></a>01836 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="classAlbany_1_1STKDiscretization.html#a9cec6b54f9d73412a7c5879d0f5335cc">stkMeshStruct</a>-&gt;exoOutput)
<a name="l01837"></a>01837     *<a class="code" href="classAlbany_1_1STKDiscretization.html#ab7190e5b44b7f00bb6ae7a199d217fa7" title="Call stk_io for creating exodus output file.">out</a> &lt;&lt; <span class="stringliteral">&quot;\nWARNING: exodus output requested but SEACAS not compiled in:&quot;</span>
<a name="l01838"></a>01838          &lt;&lt; <span class="stringliteral">&quot; disabling exodus output \n&quot;</span> &lt;&lt; std::endl;
<a name="l01839"></a>01839 
<a name="l01840"></a>01840 <span class="preprocessor">#endif</span>
<a name="l01841"></a>01841 <span class="preprocessor"></span>}
<a name="l01842"></a>01842 
<a name="l01843"></a>01843 <span class="keywordtype">void</span>
<a name="l01844"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#a88004931809859cd2d0eb79f10fa4747">01844</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#a88004931809859cd2d0eb79f10fa4747" title="Convert the stk mesh on this processor to a nodal graph using SEACAS.">Albany::STKDiscretization::meshToGraph</a>()
<a name="l01845"></a>01845 {
<a name="l01846"></a>01846 <span class="comment">/*</span>
<a name="l01847"></a>01847 <span class="comment">  Convert the stk mesh on this processor to a nodal graph</span>
<a name="l01848"></a>01848 <span class="comment">*/</span>
<a name="l01849"></a>01849 
<a name="l01850"></a>01850   <span class="comment">// Elements that surround a given node, in the form of Entity *&#39;s</span>
<a name="l01851"></a>01851   std::vector&lt;std::vector&lt;stk::mesh::Entity *&gt; &gt; sur_elem;
<a name="l01852"></a>01852   <span class="comment">// numOverlapNodes are the total # of nodes seen by this pe</span>
<a name="l01853"></a>01853   <span class="comment">// numOwnedNodes are the total # of nodes owned by this pe</span>
<a name="l01854"></a>01854   sur_elem.resize(<a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>);
<a name="l01855"></a>01855 
<a name="l01856"></a>01856   std::size_t max_nsur = 0;
<a name="l01857"></a>01857 
<a name="l01858"></a>01858   <span class="comment">// Get the elements owned by the current processor</span>
<a name="l01859"></a>01859   stk::mesh::Selector select_owned_in_part =
<a name="l01860"></a>01860     stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.universal_part() ) &amp;
<a name="l01861"></a>01861     stk::mesh::Selector( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.locally_owned_part() );
<a name="l01862"></a>01862 
<a name="l01863"></a>01863   std::vector&lt; stk::mesh::Bucket * &gt; buckets ;
<a name="l01864"></a>01864   stk::mesh::get_buckets( select_owned_in_part ,
<a name="l01865"></a>01865                           <a class="code" href="classAlbany_1_1STKDiscretization.html#a07a1cfe823ad286c47ced333a94c691a">bulkData</a>.buckets( <a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.element_rank() ) ,
<a name="l01866"></a>01866                           buckets);
<a name="l01867"></a>01867 
<a name="l01868"></a>01868   <span class="keywordtype">int</span> numBuckets = buckets.size();
<a name="l01869"></a>01869   std::vector&lt;const std::size_t *&gt; table(numBuckets);
<a name="l01870"></a>01870   std::vector&lt;std::size_t&gt; nconnect(numBuckets);
<a name="l01871"></a>01871 
<a name="l01872"></a>01872 
<a name="l01873"></a>01873   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b=0; b &lt; numBuckets; b++) {
<a name="l01874"></a>01874 
<a name="l01875"></a>01875     stk::mesh::Bucket&amp; <a class="code" href="classAlbany_1_1STKDiscretization.html#ab83300b2ee825168aa58104dbf77baa9">cells</a> = *buckets[b];
<a name="l01876"></a>01876 
<a name="l01877"></a>01877     <span class="keyword">const</span> CellTopologyData * <span class="keyword">const</span> elem_top 
<a name="l01878"></a>01878              = stk::mesh::fem::get_cell_topology( cells[0] ).getCellTopologyData();
<a name="l01879"></a>01879 
<a name="l01880"></a>01880     <span class="keywordflow">if</span>(strncmp(elem_top-&gt;name, <span class="stringliteral">&quot;Hexahedron&quot;</span>, 10) == 0){
<a name="l01881"></a>01881        table[b] = <a class="code" href="namespaceAlbany.html#a9081a284e273223f3101c9da45ab5307" title="Various utilities for the construction of an STK nodal graph.">hex_table</a>;
<a name="l01882"></a>01882        nconnect[b] = <a class="code" href="namespaceAlbany.html#a15065c40187dc0fc7a3f77e8311e4002">hex_nconnect</a>;
<a name="l01883"></a>01883     }
<a name="l01884"></a>01884     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strncmp(elem_top-&gt;name, <span class="stringliteral">&quot;Tetrahedron&quot;</span>, 11) == 0){
<a name="l01885"></a>01885        table[b] = <a class="code" href="namespaceAlbany.html#a4bc19ec23fecab255188ff5c1fc85db6">tet_table</a>;
<a name="l01886"></a>01886        nconnect[b] = <a class="code" href="namespaceAlbany.html#a2ef14c528b910fa89d653737483ba29a">tet_nconnect</a>;
<a name="l01887"></a>01887     }
<a name="l01888"></a>01888     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strncmp(elem_top-&gt;name, <span class="stringliteral">&quot;Triangle&quot;</span>, 8) == 0){
<a name="l01889"></a>01889        table[b] = <a class="code" href="namespaceAlbany.html#a0d8b0642fc62df8813b2dad6ef417f1c">tri_table</a>;
<a name="l01890"></a>01890        nconnect[b] = <a class="code" href="namespaceAlbany.html#ad72fc7fb3f7f6b86cb404c0ce0758594">tri_nconnect</a>;
<a name="l01891"></a>01891     }
<a name="l01892"></a>01892     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strncmp(elem_top-&gt;name, <span class="stringliteral">&quot;Quadrilateral&quot;</span>, 13) == 0){
<a name="l01893"></a>01893        table[b] = <a class="code" href="namespaceAlbany.html#af9f8f9eba2fbdd7ab4152f69ca1d3ea8">quad_table</a>;
<a name="l01894"></a>01894        nconnect[b] = <a class="code" href="namespaceAlbany.html#af588fb9ddd2dfa49eeee159147c84453">quad_nconnect</a>;
<a name="l01895"></a>01895     }
<a name="l01896"></a>01896     <span class="keywordflow">else</span>
<a name="l01897"></a>01897 
<a name="l01898"></a>01898       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01899"></a>01899                            <span class="stringliteral">&quot;Error - unknown element type : &quot;</span> &lt;&lt; elem_top-&gt;name 
<a name="l01900"></a>01900                            &lt;&lt; <span class="stringliteral">&quot; requested in nodal graph algorithm&quot;</span> &lt;&lt; std::endl);
<a name="l01901"></a>01901 
<a name="l01902"></a>01902     <span class="comment">/* Find the surrounding elements for each node owned by this processor */</span>
<a name="l01903"></a>01903     <span class="keywordflow">for</span> (std::size_t ecnt=0; ecnt &lt; cells.size(); ecnt++) {
<a name="l01904"></a>01904       <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>&amp; e = cells[ecnt];
<a name="l01905"></a>01905       stk::mesh::PairIterRelation rel = e.relations(<a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.NODE_RANK);
<a name="l01906"></a>01906 
<a name="l01907"></a>01907       <span class="comment">// loop over nodes within the element</span>
<a name="l01908"></a>01908       <span class="keywordflow">for</span> (std::size_t ncnt=0; ncnt &lt; rel.size(); ncnt++) {
<a name="l01909"></a>01909         <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>&amp; rowNode = * rel[ncnt].entity();
<a name="l01910"></a>01910         <span class="keywordtype">int</span> nodeGID = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(rowNode);
<a name="l01911"></a>01911         <span class="keywordtype">int</span> nodeLID = <a class="code" href="classAlbany_1_1STKDiscretization.html#add1e11b4e7887764bd677538c33a5ec1">overlap_node_map</a>-&gt;LID(nodeGID);
<a name="l01912"></a>01912 
<a name="l01913"></a>01913         <span class="comment">/*</span>
<a name="l01914"></a>01914 <span class="comment">         * in the case of degenerate elements, where a node can be</span>
<a name="l01915"></a>01915 <span class="comment">         * entered into the connect table twice, need to check to</span>
<a name="l01916"></a>01916 <span class="comment">         * make sure that this element is not already listed as</span>
<a name="l01917"></a>01917 <span class="comment">         * surrounding this node</span>
<a name="l01918"></a>01918 <span class="comment">         */</span>
<a name="l01919"></a>01919 
<a name="l01920"></a>01920         <span class="keywordflow">if</span> (sur_elem[nodeLID].empty() || <a class="code" href="classAlbany_1_1STKDiscretization.html#a894f3cbadfd46f63c459076df5d262ac">entity_in_list</a>(&amp;e, sur_elem[nodeLID]) &lt; 0) {
<a name="l01921"></a>01921           <span class="comment">/* Add the element to the list */</span>
<a name="l01922"></a>01922           sur_elem[nodeLID].push_back(&amp;e);
<a name="l01923"></a>01923         }
<a name="l01924"></a>01924       }
<a name="l01925"></a>01925     } <span class="comment">/* End &quot;for(ecnt=0; ecnt &lt; mesh-&gt;num_elems; ecnt++)&quot; */</span>
<a name="l01926"></a>01926   } <span class="comment">// End of loop over buckets</span>
<a name="l01927"></a>01927 
<a name="l01928"></a>01928   <span class="keywordflow">for</span>(std::size_t ncnt=0; ncnt &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; ncnt++) {
<a name="l01929"></a>01929     <span class="keywordflow">if</span>(sur_elem[ncnt].empty()) {
<a name="l01930"></a>01930       TEUCHOS_TEST_FOR_EXCEPTION(<span class="keyword">true</span>, std::logic_error,
<a name="l01931"></a>01931         <span class="stringliteral">&quot;Node = &quot;</span> &lt;&lt; ncnt+1 &lt;&lt; <span class="stringliteral">&quot; has no elements&quot;</span> &lt;&lt; std::endl);
<a name="l01932"></a>01932     }
<a name="l01933"></a>01933     <span class="keywordflow">else</span> {
<a name="l01934"></a>01934       std::size_t nsur = sur_elem[ncnt].size();
<a name="l01935"></a>01935       <span class="keywordflow">if</span> (nsur &gt; max_nsur)
<a name="l01936"></a>01936         max_nsur = nsur;
<a name="l01937"></a>01937     }
<a name="l01938"></a>01938   }
<a name="l01939"></a>01939 
<a name="l01940"></a>01940 <span class="comment">//end find_surrnd_elems</span>
<a name="l01941"></a>01941 
<a name="l01942"></a>01942 <span class="comment">// find_adjacency</span>
<a name="l01943"></a>01943 
<a name="l01944"></a>01944     <span class="comment">// Note that the center node of a subgraph must be owned by this pe, but we want all nodes in the overlap</span>
<a name="l01945"></a>01945     <span class="comment">// graph to be covered in the nodal graph</span>
<a name="l01946"></a>01946 
<a name="l01947"></a>01947     <span class="comment">/* Allocate memory necessary for the adjacency */</span>
<a name="l01948"></a>01948     <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a59f1fe07e2e0e0450920e591300e889a">start</a>.resize(numOverlapNodes + 1);
<a name="l01949"></a>01949     <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a9decf52ab5d408adfdcc7061aeca46fd">adj</a>.clear();
<a name="l01950"></a>01950     std::size_t nadj = 0;
<a name="l01951"></a>01951 
<a name="l01952"></a>01952 
<a name="l01953"></a>01953       <span class="comment">// loop over all the nodes owned by this PE</span>
<a name="l01954"></a>01954       <span class="keywordflow">for</span>(std::size_t ncnt=0; ncnt &lt; numOverlapNodes; ncnt++) {
<a name="l01955"></a>01955 <span class="comment">//std::cout &lt;&lt; &quot;Center node is : &quot; &lt;&lt; ncnt + 1 &lt;&lt; &quot; num elems around it : &quot; &lt;&lt; sur_elem[ncnt].size() &lt;&lt; std::endl;</span>
<a name="l01956"></a>01956         <span class="comment">// save the starting location for the nodes surrounding ncnt</span>
<a name="l01957"></a>01957   <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a59f1fe07e2e0e0450920e591300e889a">start</a>[ncnt] = nadj;
<a name="l01958"></a>01958         <span class="comment">// loop over the elements surrounding node ncnt</span>
<a name="l01959"></a>01959   <span class="keywordflow">for</span>(std::size_t ecnt=0; ecnt &lt; sur_elem[ncnt].size(); ecnt++) {
<a name="l01960"></a>01960     <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>* elem   = sur_elem[ncnt][ecnt];
<a name="l01961"></a>01961 <span class="comment">//std::cout &lt;&lt; &quot;   Element is : &quot; &lt;&lt; elem-&gt;identifier() &lt;&lt; std::endl;</span>
<a name="l01962"></a>01962 
<a name="l01963"></a>01963           stk::mesh::PairIterRelation rel = elem-&gt;relations(<a class="code" href="classAlbany_1_1STKDiscretization.html#aa451e2342da340d564e1923537461f0f" title="Stk Mesh Objects.">metaData</a>.NODE_RANK);
<a name="l01964"></a>01964 
<a name="l01965"></a>01965           std::size_t ws = <a class="code" href="classAlbany_1_1STKDiscretization.html#a5d79536cef04ef59e0ebb80f43c37b85" title="Connectivity map from elementGID to workset and LID in workset.">elemGIDws</a>[<a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(elem)].ws;
<a name="l01966"></a>01966 
<a name="l01967"></a>01967           <span class="comment">// loop over the nodes in the surrounding element elem</span>
<a name="l01968"></a>01968           <span class="keywordflow">for</span> (std::size_t lnode=0; lnode &lt; rel.size(); lnode++) {
<a name="l01969"></a>01969             <a class="code" href="namespaceAAdapt.html#a6e672c66f1cfcf2ba9f8baf4a51e0381">stk::mesh::Entity</a>&amp; node_a = * rel[lnode].entity();
<a name="l01970"></a>01970             <span class="comment">// entry is the GID of each node</span>
<a name="l01971"></a>01971             std::size_t entry = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(node_a);
<a name="l01972"></a>01972 
<a name="l01973"></a>01973             <span class="comment">// if &quot;entry&quot; is not the center node AND &quot;entry&quot; does not appear in the current list of nodes surrounding</span>
<a name="l01974"></a>01974             <span class="comment">// &quot;ncnt&quot;, add &quot;entry&quot; to the adj list</span>
<a name="l01975"></a>01975       <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#add1e11b4e7887764bd677538c33a5ec1">overlap_node_map</a>-&gt;GID(ncnt) == entry){ <span class="comment">// entry - offset lnode - is where we are in the node</span>
<a name="l01976"></a>01976                                                       <span class="comment">// ordering within the element</span>
<a name="l01977"></a>01977 
<a name="l01978"></a>01978                <span class="keywordflow">for</span>(std::size_t k = 0; k &lt; nconnect[ws]; k++){
<a name="l01979"></a>01979 
<a name="l01980"></a>01980                   <span class="keywordtype">int</span> local_node = table[ws][lnode * nconnect[ws] + k]; <span class="comment">// local number of the node connected to the center &quot;entry&quot;</span>
<a name="l01981"></a>01981 
<a name="l01982"></a>01982                   std::size_t global_node_id = <a class="code" href="classAlbany_1_1STKDiscretization.html#a0e30dfebd265ae16423946ccefcf5253">gid</a>(*rel[local_node].entity());
<a name="l01983"></a>01983 <span class="comment">//std::cout &lt;&lt; &quot;      Local test node is : &quot; &lt;&lt; local_node + 1 &lt;&lt; &quot; offset is : &quot; &lt;&lt; k &lt;&lt; &quot; global node is : &quot; &lt;&lt; global_node_id + 1 &lt;&lt;  std::endl;</span>
<a name="l01984"></a>01984 
<a name="l01985"></a>01985                   <span class="keywordflow">if</span>(<a class="code" href="classAlbany_1_1STKDiscretization.html#aaebe3fa0356ff02c086554d649ce9a0c">in_list</a>(global_node_id,
<a name="l01986"></a>01986            <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a9decf52ab5d408adfdcc7061aeca46fd">adj</a>.size()-<a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a59f1fe07e2e0e0450920e591300e889a">start</a>[ncnt],
<a name="l01987"></a>01987            &amp;<a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a9decf52ab5d408adfdcc7061aeca46fd">adj</a>[<a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a59f1fe07e2e0e0450920e591300e889a">start</a>[ncnt]]) &lt; 0) {
<a name="l01988"></a>01988                        <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a9decf52ab5d408adfdcc7061aeca46fd">adj</a>.push_back(global_node_id);
<a name="l01989"></a>01989 <span class="comment">//std::cout &lt;&lt; &quot;            Added edge node : &quot; &lt;&lt; global_node_id + 1 &lt;&lt; std::endl;</span>
<a name="l01990"></a>01990             }
<a name="l01991"></a>01991                }
<a name="l01992"></a>01992                <span class="keywordflow">break</span>;
<a name="l01993"></a>01993             }
<a name="l01994"></a>01994     }
<a name="l01995"></a>01995   } <span class="comment">/* End &quot;for(ecnt=0; ecnt &lt; graph-&gt;nsur_elem[ncnt]; ecnt++)&quot; */</span>
<a name="l01996"></a>01996 
<a name="l01997"></a>01997         nadj = <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a9decf52ab5d408adfdcc7061aeca46fd">adj</a>.size();
<a name="l01998"></a>01998 
<a name="l01999"></a>01999       } <span class="comment">/* End &quot;for(ncnt=0; ncnt &lt; mesh-&gt;num_nodes; ncnt++)&quot; */</span>
<a name="l02000"></a>02000 
<a name="l02001"></a>02001     <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a59f1fe07e2e0e0450920e591300e889a">start</a>[numOverlapNodes] = nadj;
<a name="l02002"></a>02002 
<a name="l02003"></a>02003 <span class="comment">// end find_adjacency</span>
<a name="l02004"></a>02004 
<a name="l02005"></a>02005 }
<a name="l02006"></a>02006 
<a name="l02007"></a>02007 <span class="keywordtype">void</span>
<a name="l02008"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#af4533f839cbfcb2691a54416e3d80be1">02008</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#af4533f839cbfcb2691a54416e3d80be1">Albany::STKDiscretization::printVertexConnectivity</a>(){
<a name="l02009"></a>02009 
<a name="l02010"></a>02010   <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a0a57d9508414e2813565e988597431a7">numOverlapNodes</a>; i++){
<a name="l02011"></a>02011 
<a name="l02012"></a>02012     std::cout &lt;&lt; <span class="stringliteral">&quot;Center vert is : &quot;</span> &lt;&lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#add1e11b4e7887764bd677538c33a5ec1">overlap_node_map</a>-&gt;GID(i) + 1 &lt;&lt; std::endl;
<a name="l02013"></a>02013 
<a name="l02014"></a>02014     <span class="keywordflow">for</span>(std::size_t j = <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a59f1fe07e2e0e0450920e591300e889a">start</a>[i]; j &lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a59f1fe07e2e0e0450920e591300e889a">start</a>[i + 1]; j++)
<a name="l02015"></a>02015 
<a name="l02016"></a>02016       std::cout &lt;&lt; <span class="stringliteral">&quot;                  &quot;</span> &lt;&lt; <a class="code" href="classAlbany_1_1STKDiscretization.html#a57585a2abddb6862635a1893f6baaf13">nodalGraph</a>.<a class="code" href="structAlbany_1_1MeshGraph.html#a9decf52ab5d408adfdcc7061aeca46fd">adj</a>[j] + 1 &lt;&lt; std::endl;
<a name="l02017"></a>02017 
<a name="l02018"></a>02018    }
<a name="l02019"></a>02019 }
<a name="l02020"></a>02020 
<a name="l02021"></a>02021 <span class="keywordtype">void</span>
<a name="l02022"></a><a class="code" href="classAlbany_1_1STKDiscretization.html#ad5dac2bbc4d548d84c1f0db9f7275f78">02022</a> <a class="code" href="classAlbany_1_1STKDiscretization.html#ad5dac2bbc4d548d84c1f0db9f7275f78" title="After mesh modification, need to update the element connectivity and nodal coordinates.">Albany::STKDiscretization::updateMesh</a>()
<a name="l02023"></a>02023 {
<a name="l02024"></a>02024 
<a name="l02025"></a>02025   <a class="code" href="classAlbany_1_1STKDiscretization.html#afbf76c212116f67eaedc9bfb2c3c1464" title="Process STK mesh for Owned nodal quantitites.">computeOwnedNodesAndUnknowns</a>();
<a name="l02026"></a>02026 
<a name="l02027"></a>02027   <a class="code" href="classAlbany_1_1STKDiscretization.html#ad2b5f24655684c1e1efed7e7356b01e9" title="Process coords for ML.">setupMLCoords</a>();
<a name="l02028"></a>02028 
<a name="l02029"></a>02029   <a class="code" href="classAlbany_1_1STKDiscretization.html#a620565509dacf5c28d351172b9c51b8b" title="Process STK mesh for Overlap nodal quantitites.">computeOverlapNodesAndUnknowns</a>();
<a name="l02030"></a>02030 
<a name="l02031"></a>02031   <a class="code" href="classAlbany_1_1STKDiscretization.html#ac14ce93957277e452addc88c1a8d8905" title="Function that transforms an STK mesh of a unit cube (for FELIX problems).">transformMesh</a>();
<a name="l02032"></a>02032 
<a name="l02033"></a>02033   <a class="code" href="classAlbany_1_1STKDiscretization.html#aba4192b9c5b2a7e5ca77e1e7634318b7" title="Process STK mesh for CRS Graphs.">computeGraphs</a>();
<a name="l02034"></a>02034 
<a name="l02035"></a>02035   <a class="code" href="classAlbany_1_1STKDiscretization.html#a8950d2962d151003edadd2658424f931" title="Process STK mesh for Workset/Bucket Info.">computeWorksetInfo</a>();
<a name="l02036"></a>02036 
<a name="l02037"></a>02037   <a class="code" href="classAlbany_1_1STKDiscretization.html#a4cc7530b6ea21955ec42ab464ba58b56" title="Process STK mesh for NodeSets.">computeNodeSets</a>();
<a name="l02038"></a>02038 
<a name="l02039"></a>02039   <a class="code" href="classAlbany_1_1STKDiscretization.html#a0c571fc5f3153f4b0d3fe930d10fe885" title="Process STK mesh for SideSets.">computeSideSets</a>();
<a name="l02040"></a>02040 
<a name="l02041"></a>02041   <a class="code" href="classAlbany_1_1STKDiscretization.html#a5970626a8f7747d0ecf05ed16abfeffd" title="Call stk_io for creating exodus output file.">setupExodusOutput</a>();
<a name="l02042"></a>02042 
<a name="l02043"></a>02043   <a class="code" href="classAlbany_1_1STKDiscretization.html#a24e744acc8207f554efa4bd0df3ee758" title="Call stk_io for creating NetCDF output file.">setupNetCDFOutput</a>();
<a name="l02044"></a>02044 <span class="comment">//meshToGraph();</span>
<a name="l02045"></a>02045 <span class="comment">//printVertexConnectivity();</span>
<a name="l02046"></a>02046 
<a name="l02047"></a>02047 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 26 2014 18:36:36 for Albany: a Trilinos-based PDE code by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
