<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Albany: a Trilinos-based PDE code: LCMPartition.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>LCMPartition.h</h1>  </div>
</div>
<div class="contents">
<a href="LCMPartition_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//*****************************************************************//</span>
<a name="l00002"></a>00002 <span class="comment">//    Albany 2.0:  Copyright 2012 Sandia Corporation               //</span>
<a name="l00003"></a>00003 <span class="comment">//    This Software is released under the BSD license detailed     //</span>
<a name="l00004"></a>00004 <span class="comment">//    in the file &quot;license.txt&quot; in the top-level Albany directory  //</span>
<a name="l00005"></a>00005 <span class="comment">//*****************************************************************//</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">// Define only if Zoltan is enabled</span>
<a name="l00008"></a>00008 <span class="preprocessor">#if defined (ALBANY_LCM) &amp;&amp; defined(ALBANY_ZOLTAN)</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span>
<a name="l00010"></a>00010 <span class="preprocessor">#if !defined(LCM_Partition_h)</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#define LCM_Partition_h</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;boost/shared_ptr.hpp&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;zoltan_cpp.h&gt;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;Teuchos_RCP.hpp&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;Teuchos_ArrayRCP.hpp&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;Teuchos_ParameterList.hpp&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Albany__AbstractDiscretization_8hpp.html">Albany_AbstractDiscretization.hpp</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Albany__DiscretizationFactory_8hpp.html">Albany_DiscretizationFactory.hpp</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Albany__STKDiscretization_8hpp.html">Albany_STKDiscretization.hpp</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Albany__SolverFactory_8hpp.html">Albany_SolverFactory.hpp</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Albany__Utils_8hpp.html">Albany_Utils.hpp</a>&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;Intrepid_MiniTensor_Geometry.h&gt;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">using</span> Intrepid::Index;
<a name="l00036"></a>00036 <span class="keyword">using</span> Intrepid::Vector;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="keyword">namespace </span>LCM {
<a name="l00039"></a>00039 
<a name="l00043"></a>00043   <span class="keyword">typedef</span> std::vector&lt;int&gt;
<a name="l00044"></a>00044   IDList;
<a name="l00045"></a>00045 
<a name="l00050"></a>00050   <span class="keyword">typedef</span> std::map&lt;int, IDList&gt;
<a name="l00051"></a>00051   AdjacencyMap;
<a name="l00052"></a>00052 
<a name="l00056"></a>00056   <span class="keyword">typedef</span> std::map&lt;int, double&gt;
<a name="l00057"></a>00057   ScalarMap;
<a name="l00058"></a>00058 
<a name="l00062"></a>00062   <span class="keyword">typedef</span> std::map&lt;int, Vector&lt;double&gt; &gt;
<a name="l00063"></a>00063   PointMap;
<a name="l00064"></a>00064 
<a name="l00068"></a>00068   <span class="keyword">namespace </span>PARTITION {
<a name="l00069"></a>00069 
<a name="l00070"></a>00070     <span class="keyword">enum</span> Scheme {
<a name="l00071"></a>00071       UNKNOWN,
<a name="l00072"></a>00072       RANDOM,
<a name="l00073"></a>00073       GEOMETRIC,
<a name="l00074"></a>00074       HYPERGRAPH,
<a name="l00075"></a>00075       KMEANS,
<a name="l00076"></a>00076       SEQUENTIAL,
<a name="l00077"></a>00077       KDTREE};
<a name="l00078"></a>00078 
<a name="l00079"></a>00079   }
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   <span class="comment">//</span>
<a name="l00083"></a>00083 <span class="comment"></span>  <span class="comment">//</span>
<a name="l00084"></a>00084   <span class="keyword">class </span>ConnectivityArray;
<a name="l00085"></a>00085   <span class="keyword">class </span>DualGraph;
<a name="l00086"></a>00086   <span class="keyword">class </span>ZoltanHyperGraph;
<a name="l00087"></a>00087   <span class="keyword">struct </span>KDTreeNode;
<a name="l00088"></a>00088 
<a name="l00096"></a>00096   <span class="keyword">struct </span>ClusterCenter {
<a name="l00097"></a>00097 
<a name="l00098"></a>00098     Vector&lt;double&gt;
<a name="l00099"></a>00099     position;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101     Vector&lt;double&gt;
<a name="l00102"></a>00102     weighted_centroid;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104     Index
<a name="l00105"></a>00105     count;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107   };
<a name="l00108"></a>00108 
<a name="l00116"></a>00116   <span class="keyword">struct </span>KDTreeNode {
<a name="l00117"></a>00117     std::string
<a name="l00118"></a>00118     name;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     boost::shared_ptr&lt;KDTreeNode&gt;
<a name="l00121"></a>00121     parent;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="comment">// Children</span>
<a name="l00124"></a>00124     boost::shared_ptr&lt;KDTreeNode&gt;
<a name="l00125"></a>00125     left;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     boost::shared_ptr&lt;KDTreeNode&gt;
<a name="l00128"></a>00128     right;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     <span class="comment">// Bounding box of cell</span>
<a name="l00131"></a>00131     Vector&lt;double&gt;
<a name="l00132"></a>00132     lower_corner;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     Vector&lt;double&gt;
<a name="l00135"></a>00135     upper_corner;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137     <span class="comment">// Weighted centroid and count</span>
<a name="l00138"></a>00138     Vector&lt;double&gt;
<a name="l00139"></a>00139     weighted_centroid;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     Index
<a name="l00142"></a>00142     count;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     std::set&lt;Index&gt;
<a name="l00145"></a>00145     cell_points;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147     std::set&lt;Index&gt;
<a name="l00148"></a>00148     candidate_centers;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     Index
<a name="l00151"></a>00151     closest_center_to_midcell;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153   };
<a name="l00154"></a>00154 
<a name="l00162"></a>00162   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Node&gt;
<a name="l00163"></a>00163   <span class="keyword">class </span>KDTree {
<a name="l00164"></a>00164   <span class="keyword">public</span>:
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     KDTree(std::vector&lt;Vector&lt;double&gt; &gt; <span class="keyword">const</span> &amp; points,
<a name="l00167"></a>00167         Index <span class="keyword">const</span> number_centers);
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     boost::shared_ptr&lt;Node&gt; &amp;
<a name="l00170"></a>00170     get_root() {<span class="keywordflow">return</span> root_;};
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <span class="keyword">private</span>:
<a name="l00173"></a>00173 
<a name="l00174"></a>00174     boost::shared_ptr&lt;Node&gt;
<a name="l00175"></a>00175     root_;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   };
<a name="l00178"></a>00178 
<a name="l00184"></a>00184   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Node&gt;
<a name="l00185"></a>00185   boost::shared_ptr&lt;Node&gt;
<a name="l00186"></a>00186   BuildKDTree(std::vector&lt; Vector&lt;double&gt; &gt; <span class="keyword">const</span> &amp; points);
<a name="l00187"></a>00187 
<a name="l00193"></a>00193   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Node&gt;
<a name="l00194"></a>00194   boost::shared_ptr&lt;Node&gt;
<a name="l00195"></a>00195   CreateKDTreeNode(
<a name="l00196"></a>00196       std::string <span class="keyword">const</span> &amp; name,
<a name="l00197"></a>00197       boost::shared_ptr&lt;Node&gt; parent,
<a name="l00198"></a>00198       std::vector&lt; Vector&lt;double&gt; &gt; <span class="keyword">const</span> &amp; points,
<a name="l00199"></a>00199       std::set&lt;Index&gt; <span class="keyword">const</span> &amp; points_indices);
<a name="l00200"></a>00200 
<a name="l00205"></a>00205   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Node, <span class="keyword">typename</span> Visitor&gt;
<a name="l00206"></a>00206   <span class="keywordtype">void</span>
<a name="l00207"></a>00207   VisitTreeNode(<a class="code" href="structNode.html">Node</a> &amp; node, Visitor <span class="keyword">const</span> &amp; visitor);
<a name="l00208"></a>00208 
<a name="l00212"></a>00212   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tree, <span class="keyword">typename</span> Visitor&gt;
<a name="l00213"></a>00213   <span class="keywordtype">void</span>
<a name="l00214"></a>00214   TraverseTree(Tree &amp; tree, Visitor <span class="keyword">const</span> &amp; visitor);
<a name="l00215"></a>00215 
<a name="l00219"></a>00219   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Node&gt;
<a name="l00220"></a>00220   <span class="keyword">struct </span>OutputVisitor {
<a name="l00221"></a>00221     <span class="keywordtype">void</span>
<a name="l00222"></a>00222     operator()(<a class="code" href="structNode.html">Node</a> <span class="keyword">const</span> &amp; node) <span class="keyword">const</span>;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224     <span class="keywordtype">bool</span>
<a name="l00225"></a>00225     pre_stop(<a class="code" href="structNode.html">Node</a> <span class="keyword">const</span> &amp; node) <span class="keyword">const</span>;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <span class="keywordtype">bool</span>
<a name="l00228"></a>00228     post_stop(<a class="code" href="structNode.html">Node</a> <span class="keyword">const</span> &amp; node) <span class="keyword">const</span>;
<a name="l00229"></a>00229   };
<a name="l00230"></a>00230 
<a name="l00234"></a>00234   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Node, <span class="keyword">typename</span> Center&gt;
<a name="l00235"></a>00235   <span class="keyword">struct </span>FilterVisitor {
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     std::vector&lt;Vector&lt;double&gt; &gt; &amp; points;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     std::vector&lt;Center&gt; &amp; centers;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     FilterVisitor(std::vector&lt;Vector&lt;double&gt; &gt; &amp; p, std::vector&lt;Center&gt; &amp; c);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     <span class="keywordtype">void</span>
<a name="l00244"></a>00244     operator()(<a class="code" href="structNode.html">Node</a> <span class="keyword">const</span> &amp; node) <span class="keyword">const</span>;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <span class="keywordtype">bool</span>
<a name="l00247"></a>00247     pre_stop(<a class="code" href="structNode.html">Node</a> <span class="keyword">const</span> &amp; node) <span class="keyword">const</span>;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     <span class="keywordtype">bool</span>
<a name="l00250"></a>00250     post_stop(<a class="code" href="structNode.html">Node</a> <span class="keyword">const</span> &amp; node) <span class="keyword">const</span>;
<a name="l00251"></a>00251   };
<a name="l00252"></a>00252 
<a name="l00257"></a>00257   <span class="keyword">class </span>ConnectivityArray {
<a name="l00258"></a>00258   <span class="keyword">public</span>:
<a name="l00259"></a>00259 
<a name="l00263"></a>00263     ConnectivityArray();
<a name="l00264"></a>00264 
<a name="l00270"></a>00270     ConnectivityArray(
<a name="l00271"></a>00271         std::string <span class="keyword">const</span> &amp; input_file,
<a name="l00272"></a>00272         std::string <span class="keyword">const</span> &amp; output_file);
<a name="l00273"></a>00273 
<a name="l00277"></a>00277     Index
<a name="l00278"></a>00278     GetNumberNodes() <span class="keyword">const</span>;
<a name="l00279"></a>00279 
<a name="l00283"></a>00283     Index
<a name="l00284"></a>00284     GetNumberElements() <span class="keyword">const</span>;
<a name="l00285"></a>00285 
<a name="l00289"></a>00289     Index
<a name="l00290"></a>00290     GetDimension() <span class="keyword">const</span>;
<a name="l00291"></a>00291 
<a name="l00296"></a>00296     Intrepid::ELEMENT::Type
<a name="l00297"></a>00297     GetType() <span class="keyword">const</span>;
<a name="l00298"></a>00298 
<a name="l00303"></a>00303     Index
<a name="l00304"></a>00304     GetNodesPerElement() <span class="keyword">const</span>;
<a name="l00305"></a>00305 
<a name="l00309"></a>00309     PointMap
<a name="l00310"></a>00310     GetNodeList() <span class="keyword">const</span>;
<a name="l00311"></a>00311 
<a name="l00315"></a>00315     AdjacencyMap
<a name="l00316"></a>00316     GetConnectivity() <span class="keyword">const</span>;
<a name="l00317"></a>00317 
<a name="l00321"></a>00321     ScalarMap
<a name="l00322"></a>00322     GetVolumes() <span class="keyword">const</span>;
<a name="l00323"></a>00323 
<a name="l00327"></a>00327     <span class="keywordtype">double</span>
<a name="l00328"></a>00328     GetVolume() <span class="keyword">const</span>;
<a name="l00329"></a>00329 
<a name="l00333"></a>00333     std::map&lt;int, int&gt;
<a name="l00334"></a>00334     GetPartitions() <span class="keyword">const</span>;
<a name="l00335"></a>00335 
<a name="l00339"></a>00339     ScalarMap
<a name="l00340"></a>00340     GetPartitionVolumes() <span class="keyword">const</span>;
<a name="l00341"></a>00341 
<a name="l00345"></a>00345     std::vector&lt; Vector&lt;double&gt; &gt;
<a name="l00346"></a>00346     GetPartitionCentroids() <span class="keyword">const</span>;
<a name="l00347"></a>00347 
<a name="l00351"></a>00351     PointMap
<a name="l00352"></a>00352     GetCentroids() <span class="keyword">const</span>;
<a name="l00353"></a>00353 
<a name="l00357"></a>00357     std::pair&lt;Vector&lt;double&gt;, Vector&lt;double&gt; &gt;
<a name="l00358"></a>00358     BoundingBox() <span class="keyword">const</span>;
<a name="l00359"></a>00359 
<a name="l00363"></a>00363     <span class="keywordtype">void</span>
<a name="l00364"></a>00364     SetTolerance(<span class="keywordtype">double</span> tolerance);
<a name="l00365"></a>00365 
<a name="l00369"></a>00369     <span class="keywordtype">double</span>
<a name="l00370"></a>00370     GetTolerance() <span class="keyword">const</span>;
<a name="l00371"></a>00371 
<a name="l00375"></a>00375     <span class="keywordtype">void</span>
<a name="l00376"></a>00376     SetCellSize(<span class="keywordtype">double</span> requested_cell_size);
<a name="l00377"></a>00377 
<a name="l00381"></a>00381     <span class="keywordtype">double</span>
<a name="l00382"></a>00382     GetCellSize() <span class="keyword">const</span>;
<a name="l00383"></a>00383 
<a name="l00387"></a>00387     <span class="keywordtype">void</span>
<a name="l00388"></a>00388     SetMaximumIterations(Index maximum_iterations);
<a name="l00389"></a>00389 
<a name="l00393"></a>00393     Index
<a name="l00394"></a>00394     GetMaximumIterations() <span class="keyword">const</span>;
<a name="l00395"></a>00395 
<a name="l00399"></a>00399     <span class="keywordtype">void</span>
<a name="l00400"></a>00400     SetInitializerScheme(PARTITION::Scheme initializer_scheme);
<a name="l00401"></a>00401 
<a name="l00405"></a>00405     PARTITION::Scheme
<a name="l00406"></a>00406     GetInitializerScheme() <span class="keyword">const</span>;
<a name="l00407"></a>00407 
<a name="l00411"></a>00411     <span class="keywordtype">void</span>
<a name="l00412"></a>00412     CheckNullVolume() <span class="keyword">const</span>;
<a name="l00413"></a>00413 
<a name="l00419"></a>00419     std::vector&lt; Vector&lt;double&gt; &gt;
<a name="l00420"></a>00420     CreateGrid();
<a name="l00421"></a>00421 
<a name="l00425"></a>00425     Vector&lt;int&gt;
<a name="l00426"></a>00426     PointToIndex(Vector&lt;double&gt; <span class="keyword">const</span> &amp; point) <span class="keyword">const</span>;
<a name="l00427"></a>00427 
<a name="l00431"></a>00431     <span class="keywordtype">bool</span>
<a name="l00432"></a>00432     IsInsideMesh(Vector&lt;double&gt; <span class="keyword">const</span> &amp; point) <span class="keyword">const</span>;
<a name="l00433"></a>00433 
<a name="l00440"></a>00440     <span class="keywordtype">bool</span>
<a name="l00441"></a>00441     IsInsideMeshByElement(Vector&lt;double&gt; <span class="keyword">const</span> &amp; point) <span class="keyword">const</span>;
<a name="l00442"></a>00442 
<a name="l00449"></a>00449     Index
<a name="l00450"></a>00450     GetNumberPartitions(<span class="keywordtype">double</span> <span class="keyword">const</span> length_scale) <span class="keyword">const</span>;
<a name="l00451"></a>00451 
<a name="l00455"></a>00455     <a class="code" href="classAlbany_1_1AbstractDiscretization.html">Albany::AbstractDiscretization</a> &amp;
<a name="l00456"></a>00456     GetDiscretization();
<a name="l00457"></a>00457 
<a name="l00463"></a>00463     std::map&lt;int, int&gt;
<a name="l00464"></a>00464     PartitionByCenters(std::vector&lt; Vector&lt;double&gt; &gt; <span class="keyword">const</span> &amp; centers);
<a name="l00465"></a>00465 
<a name="l00473"></a>00473     std::map&lt;int, int&gt;
<a name="l00474"></a>00474     Partition(
<a name="l00475"></a>00475         <span class="keyword">const</span> PARTITION::Scheme partition_scheme,
<a name="l00476"></a>00476         <span class="keywordtype">double</span> <span class="keyword">const</span> length_scale);
<a name="l00477"></a>00477 
<a name="l00484"></a>00484     std::map&lt;int, int&gt;
<a name="l00485"></a>00485     PartitionHyperGraph(<span class="keywordtype">double</span> <span class="keyword">const</span> length_scale);
<a name="l00486"></a>00486 
<a name="l00493"></a>00493     std::map&lt;int, int&gt;
<a name="l00494"></a>00494     PartitionGeometric(<span class="keywordtype">double</span> <span class="keyword">const</span> length_scale);
<a name="l00495"></a>00495 
<a name="l00502"></a>00502     std::map&lt;int, int&gt;
<a name="l00503"></a>00503     PartitionKMeans(<span class="keywordtype">double</span> <span class="keyword">const</span> length_scale);
<a name="l00504"></a>00504 
<a name="l00511"></a>00511     std::map&lt;int, int&gt;
<a name="l00512"></a>00512     PartitionKDTree(<span class="keywordtype">double</span> <span class="keyword">const</span> length_scale);
<a name="l00513"></a>00513 
<a name="l00520"></a>00520     std::map&lt;int, int&gt;
<a name="l00521"></a>00521     PartitionSequential(<span class="keywordtype">double</span> <span class="keyword">const</span> length_scale);
<a name="l00522"></a>00522 
<a name="l00530"></a>00530     std::map&lt;int, int&gt;
<a name="l00531"></a>00531     PartitionRandom(<span class="keywordtype">double</span> <span class="keyword">const</span> length_scale);
<a name="l00532"></a>00532 
<a name="l00545"></a>00545     <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00546"></a>00546     GetNumberGeometry(
<a name="l00547"></a>00547         <span class="keywordtype">void</span>* data,
<a name="l00548"></a>00548         <span class="keywordtype">int</span>* ierr);
<a name="l00549"></a>00549 
<a name="l00560"></a>00560     <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00561"></a>00561     GetNumberOfObjects(
<a name="l00562"></a>00562         <span class="keywordtype">void</span>* data,
<a name="l00563"></a>00563         <span class="keywordtype">int</span>* ierr);
<a name="l00564"></a>00564 
<a name="l00602"></a>00602     <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00603"></a>00603     GetObjectList(
<a name="l00604"></a>00604         <span class="keywordtype">void</span>* data,
<a name="l00605"></a>00605         <span class="keywordtype">int</span> sizeGID,
<a name="l00606"></a>00606         <span class="keywordtype">int</span> sizeLID,
<a name="l00607"></a>00607         ZOLTAN_ID_PTR globalID,
<a name="l00608"></a>00608         ZOLTAN_ID_PTR localID,
<a name="l00609"></a>00609         <span class="keywordtype">int</span> wgt_dim,
<a name="l00610"></a>00610         <span class="keywordtype">float</span>* obj_wgts,
<a name="l00611"></a>00611         <span class="keywordtype">int</span>* ierr);
<a name="l00612"></a>00612 
<a name="l00651"></a>00651     <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00652"></a>00652     GetGeometry(
<a name="l00653"></a>00653         <span class="keywordtype">void</span>* data,
<a name="l00654"></a>00654         <span class="keywordtype">int</span> sizeGID,
<a name="l00655"></a>00655         <span class="keywordtype">int</span> sizeLID,
<a name="l00656"></a>00656         <span class="keywordtype">int</span> num_obj,
<a name="l00657"></a>00657         ZOLTAN_ID_PTR globalID,
<a name="l00658"></a>00658         ZOLTAN_ID_PTR localID,
<a name="l00659"></a>00659         <span class="keywordtype">int</span> num_dim,
<a name="l00660"></a>00660         <span class="keywordtype">double</span>* geom_vec,
<a name="l00661"></a>00661         <span class="keywordtype">int</span>* ierr);
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   <span class="keyword">private</span>:
<a name="l00664"></a>00664 
<a name="l00665"></a>00665     <span class="comment">//</span>
<a name="l00666"></a>00666     <span class="comment">// The type of elements in the mesh (assumed that all are of same type)</span>
<a name="l00667"></a>00667     <span class="comment">//</span>
<a name="l00668"></a>00668     Intrepid::ELEMENT::Type
<a name="l00669"></a>00669     type_;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671     <span class="comment">//</span>
<a name="l00672"></a>00672     <span class="comment">// Node list</span>
<a name="l00673"></a>00673     <span class="comment">//</span>
<a name="l00674"></a>00674     PointMap
<a name="l00675"></a>00675     nodes_;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677     <span class="comment">//</span>
<a name="l00678"></a>00678     <span class="comment">// Element - nodes connectivity</span>
<a name="l00679"></a>00679     <span class="comment">//</span>
<a name="l00680"></a>00680     AdjacencyMap
<a name="l00681"></a>00681     connectivity_;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683     <span class="comment">//</span>
<a name="l00684"></a>00684     <span class="comment">// Space dimension</span>
<a name="l00685"></a>00685     <span class="comment">//</span>
<a name="l00686"></a>00686     Index
<a name="l00687"></a>00687     dimension_;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="comment">//</span>
<a name="l00690"></a>00690     <span class="comment">// Teuchos pointer to corresponding discretization</span>
<a name="l00691"></a>00691     <span class="comment">//</span>
<a name="l00692"></a>00692     Teuchos::RCP&lt;Albany::AbstractDiscretization&gt;
<a name="l00693"></a>00693     discretization_ptr_;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     <span class="comment">//</span>
<a name="l00696"></a>00696     <span class="comment">// Partitions if mesh is partitioned; otherwise empty</span>
<a name="l00697"></a>00697     <span class="comment">//</span>
<a name="l00698"></a>00698     std::map&lt;int, int&gt;
<a name="l00699"></a>00699     partitions_;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701     <span class="comment">//</span>
<a name="l00702"></a>00702     <span class="comment">// Background grid of the domain for fast determination</span>
<a name="l00703"></a>00703     <span class="comment">// of whether a point is inside the domain or not.</span>
<a name="l00704"></a>00704     <span class="comment">//</span>
<a name="l00705"></a>00705     std::vector&lt; std::vector&lt; std::vector&lt;bool&gt; &gt; &gt;
<a name="l00706"></a>00706     cells_;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     <span class="comment">//</span>
<a name="l00709"></a>00709     <span class="comment">// Size of background grid cell</span>
<a name="l00710"></a>00710     <span class="comment">//</span>
<a name="l00711"></a>00711     Vector&lt;double&gt;
<a name="l00712"></a>00712     cell_size_;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714     <span class="comment">//</span>
<a name="l00715"></a>00715     <span class="comment">// Parameters for kmeans partitioning</span>
<a name="l00716"></a>00716     <span class="comment">//</span>
<a name="l00717"></a>00717     <span class="keywordtype">double</span>
<a name="l00718"></a>00718     tolerance_;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720     <span class="keywordtype">double</span>
<a name="l00721"></a>00721     requested_cell_size_;
<a name="l00722"></a>00722 
<a name="l00723"></a>00723     Index
<a name="l00724"></a>00724     maximum_iterations_;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     <span class="comment">//</span>
<a name="l00727"></a>00727     <span class="comment">// Limits of the bounding box for coordinate array</span>
<a name="l00728"></a>00728     <span class="comment">//</span>
<a name="l00729"></a>00729     Vector&lt;double&gt;
<a name="l00730"></a>00730     lower_corner_;
<a name="l00731"></a>00731 
<a name="l00732"></a>00732     Vector&lt;double&gt;
<a name="l00733"></a>00733     upper_corner_;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735     <span class="comment">//</span>
<a name="l00736"></a>00736     <span class="comment">// Initializer scheme, if any.</span>
<a name="l00737"></a>00737     <span class="comment">//</span>
<a name="l00738"></a>00738     PARTITION::Scheme
<a name="l00739"></a>00739     initializer_scheme_;
<a name="l00740"></a>00740 
<a name="l00741"></a>00741   };
<a name="l00742"></a>00742 
<a name="l00746"></a>00746   <span class="keyword">class </span>DualGraph {
<a name="l00747"></a>00747 
<a name="l00748"></a>00748   <span class="keyword">public</span>:
<a name="l00749"></a>00749 
<a name="l00753"></a>00753     DualGraph();
<a name="l00754"></a>00754 
<a name="l00758"></a>00758     DualGraph(ConnectivityArray <span class="keyword">const</span> &amp; connectivity_array);
<a name="l00759"></a>00759 
<a name="l00763"></a>00763     <span class="keywordtype">int</span>
<a name="l00764"></a>00764     GetNumberVertices() <span class="keyword">const</span>;
<a name="l00765"></a>00765 
<a name="l00769"></a>00769     <span class="keywordtype">int</span>
<a name="l00770"></a>00770     GetNumberEdges() <span class="keyword">const</span>;
<a name="l00771"></a>00771 
<a name="l00776"></a>00776     <span class="keywordtype">void</span>
<a name="l00777"></a>00777     SetVertexWeights(ScalarMap &amp; vertex_weights);
<a name="l00778"></a>00778 
<a name="l00782"></a>00782     ScalarMap
<a name="l00783"></a>00783     GetVertexWeights() <span class="keyword">const</span>;
<a name="l00784"></a>00784 
<a name="l00789"></a>00789     <span class="keywordtype">void</span>
<a name="l00790"></a>00790     SetGraph(AdjacencyMap &amp; graph);
<a name="l00791"></a>00791 
<a name="l00795"></a>00795     AdjacencyMap
<a name="l00796"></a>00796     GetGraph() <span class="keyword">const</span>;
<a name="l00797"></a>00797 
<a name="l00801"></a>00801     AdjacencyMap
<a name="l00802"></a>00802     GetEdgeList() <span class="keyword">const</span>;
<a name="l00803"></a>00803 
<a name="l00807"></a>00807     <span class="keywordtype">int</span>
<a name="l00808"></a>00808     GetConnectedComponents(std::vector&lt;int&gt; &amp; components) <span class="keyword">const</span>;
<a name="l00809"></a>00809 
<a name="l00813"></a>00813     <span class="keywordtype">void</span>
<a name="l00814"></a>00814     Print() <span class="keyword">const</span>;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="keyword">private</span>:
<a name="l00817"></a>00817 
<a name="l00818"></a>00818     <span class="comment">//</span>
<a name="l00819"></a>00819     <span class="comment">// Given a connectivity array type, return local numbering of</span>
<a name="l00820"></a>00820     <span class="comment">// proper faces</span>
<a name="l00821"></a>00821     <span class="comment">//</span>
<a name="l00822"></a>00822     std::vector&lt; std::vector&lt;int&gt; &gt;
<a name="l00823"></a>00823     GetFaceConnectivity(Intrepid::ELEMENT::Type <span class="keyword">const</span> type) <span class="keyword">const</span>;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825   <span class="keyword">private</span>:
<a name="l00826"></a>00826 
<a name="l00827"></a>00827     <span class="comment">//</span>
<a name="l00828"></a>00828     <span class="comment">// Number of edges in dual graph</span>
<a name="l00829"></a>00829     <span class="comment">//</span>
<a name="l00830"></a>00830     <span class="keywordtype">int</span>
<a name="l00831"></a>00831     number_edges_;
<a name="l00832"></a>00832 
<a name="l00833"></a>00833     <span class="comment">//</span>
<a name="l00834"></a>00834     <span class="comment">// Graph data structure</span>
<a name="l00835"></a>00835     <span class="comment">//</span>
<a name="l00836"></a>00836     AdjacencyMap
<a name="l00837"></a>00837     graph_;
<a name="l00838"></a>00838 
<a name="l00839"></a>00839     <span class="comment">//</span>
<a name="l00840"></a>00840     <span class="comment">// Vertex weights</span>
<a name="l00841"></a>00841     <span class="comment">//</span>
<a name="l00842"></a>00842     ScalarMap
<a name="l00843"></a>00843     vertex_weights_;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845   };
<a name="l00846"></a>00846 
<a name="l00858"></a>00858   <span class="keyword">class </span>ZoltanHyperGraph {
<a name="l00859"></a>00859 
<a name="l00860"></a>00860   <span class="keyword">public</span>:
<a name="l00861"></a>00861 
<a name="l00865"></a>00865     ZoltanHyperGraph();
<a name="l00866"></a>00866 
<a name="l00871"></a>00871     ZoltanHyperGraph(DualGraph <span class="keyword">const</span> &amp; dual_graph);
<a name="l00872"></a>00872 
<a name="l00876"></a>00876     <span class="keywordtype">int</span>
<a name="l00877"></a>00877     GetNumberVertices() <span class="keyword">const</span>;
<a name="l00878"></a>00878 
<a name="l00883"></a>00883     <span class="keywordtype">void</span>
<a name="l00884"></a>00884     SetNumberHyperedges(<span class="keywordtype">int</span> number_hyperedges);
<a name="l00885"></a>00885 
<a name="l00889"></a>00889     <span class="keywordtype">int</span>
<a name="l00890"></a>00890     GetNumberHyperedges() <span class="keyword">const</span>;
<a name="l00891"></a>00891 
<a name="l00896"></a>00896     <span class="keywordtype">void</span>
<a name="l00897"></a>00897     SetGraph(AdjacencyMap &amp; graph);
<a name="l00898"></a>00898 
<a name="l00902"></a>00902     AdjacencyMap
<a name="l00903"></a>00903     GetGraph() <span class="keyword">const</span>;
<a name="l00904"></a>00904 
<a name="l00909"></a>00909     <span class="keywordtype">void</span>
<a name="l00910"></a>00910     SetVertexWeights(ScalarMap &amp; vertex_weights);
<a name="l00911"></a>00911 
<a name="l00915"></a>00915     ScalarMap
<a name="l00916"></a>00916     GetVertexWeights() <span class="keyword">const</span>;
<a name="l00917"></a>00917 
<a name="l00921"></a>00921     std::vector&lt;ZOLTAN_ID_TYPE&gt;
<a name="l00922"></a>00922     GetEdgeIDs() <span class="keyword">const</span>;
<a name="l00923"></a>00923 
<a name="l00928"></a>00928     std::vector&lt;int&gt;
<a name="l00929"></a>00929     GetEdgePointers() <span class="keyword">const</span>;
<a name="l00930"></a>00930 
<a name="l00934"></a>00934     std::vector&lt;ZOLTAN_ID_TYPE&gt;
<a name="l00935"></a>00935     GetVertexIDs() <span class="keyword">const</span>;
<a name="l00936"></a>00936 
<a name="l00947"></a>00947     <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00948"></a>00948     GetNumberOfObjects(
<a name="l00949"></a>00949         <span class="keywordtype">void</span>* data,
<a name="l00950"></a>00950         <span class="keywordtype">int</span>* ierr);
<a name="l00951"></a>00951 
<a name="l00989"></a>00989     <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00990"></a>00990     GetObjectList(
<a name="l00991"></a>00991         <span class="keywordtype">void</span>* data,
<a name="l00992"></a>00992         <span class="keywordtype">int</span> sizeGID,
<a name="l00993"></a>00993         <span class="keywordtype">int</span> sizeLID,
<a name="l00994"></a>00994         ZOLTAN_ID_PTR globalID,
<a name="l00995"></a>00995         ZOLTAN_ID_PTR localID,
<a name="l00996"></a>00996         <span class="keywordtype">int</span> wgt_dim,
<a name="l00997"></a>00997         <span class="keywordtype">float</span>* obj_wgts,
<a name="l00998"></a>00998         <span class="keywordtype">int</span>* ierr);
<a name="l00999"></a>00999 
<a name="l01024"></a>01024     <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01025"></a>01025     GetHyperGraphSize(
<a name="l01026"></a>01026         <span class="keywordtype">void</span>* data,
<a name="l01027"></a>01027         <span class="keywordtype">int</span>* num_lists,
<a name="l01028"></a>01028         <span class="keywordtype">int</span>* num_pins,
<a name="l01029"></a>01029         <span class="keywordtype">int</span>* format,
<a name="l01030"></a>01030         <span class="keywordtype">int</span>* ierr);
<a name="l01031"></a>01031 
<a name="l01078"></a>01078     <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01079"></a>01079     GetHyperGraph(
<a name="l01080"></a>01080         <span class="keywordtype">void</span>* data,
<a name="l01081"></a>01081         <span class="keywordtype">int</span> num_gid_entries,
<a name="l01082"></a>01082         <span class="keywordtype">int</span> num_vtx_edge,
<a name="l01083"></a>01083         <span class="keywordtype">int</span> num_pins,
<a name="l01084"></a>01084         <span class="keywordtype">int</span> format,
<a name="l01085"></a>01085         ZOLTAN_ID_PTR
<a name="l01086"></a>01086         vtxedge_GID,
<a name="l01087"></a>01087         <span class="keywordtype">int</span>* vtxedge_ptr,
<a name="l01088"></a>01088         ZOLTAN_ID_PTR pin_GID,
<a name="l01089"></a>01089         <span class="keywordtype">int</span>* ierr);
<a name="l01090"></a>01090 
<a name="l01091"></a>01091   <span class="keyword">private</span>:
<a name="l01092"></a>01092 
<a name="l01093"></a>01093     <span class="comment">//</span>
<a name="l01094"></a>01094     <span class="comment">// Number of vertices</span>
<a name="l01095"></a>01095     <span class="comment">//</span>
<a name="l01096"></a>01096     <span class="keywordtype">int</span>
<a name="l01097"></a>01097     number_vertices_;
<a name="l01098"></a>01098 
<a name="l01099"></a>01099     <span class="comment">//</span>
<a name="l01100"></a>01100     <span class="comment">// Number of hyperedges</span>
<a name="l01101"></a>01101     <span class="comment">//</span>
<a name="l01102"></a>01102     <span class="keywordtype">int</span>
<a name="l01103"></a>01103     number_hyperedges_;
<a name="l01104"></a>01104 
<a name="l01105"></a>01105     <span class="comment">//</span>
<a name="l01106"></a>01106     <span class="comment">// Graph data structure</span>
<a name="l01107"></a>01107     <span class="comment">//</span>
<a name="l01108"></a>01108     AdjacencyMap
<a name="l01109"></a>01109     graph_;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111     <span class="comment">//</span>
<a name="l01112"></a>01112     <span class="comment">// Vertex weights</span>
<a name="l01113"></a>01113     <span class="comment">//</span>
<a name="l01114"></a>01114     ScalarMap
<a name="l01115"></a>01115     vertex_weights_;
<a name="l01116"></a>01116 
<a name="l01117"></a>01117   };
<a name="l01118"></a>01118 
<a name="l01124"></a>01124   std::istream &amp;
<a name="l01125"></a>01125   operator&gt;&gt;(
<a name="l01126"></a>01126       std::istream &amp; input_stream,
<a name="l01127"></a>01127       ConnectivityArray &amp; connectivity_array);
<a name="l01128"></a>01128 
<a name="l01134"></a>01134   std::ostream &amp;
<a name="l01135"></a>01135   <a class="code" href="namespaceQCAD.html#a9f60f37fd458154ebfec6bd2e47fdf5b">operator&lt;&lt;</a>(
<a name="l01136"></a>01136       std::ostream &amp; output_stream,
<a name="l01137"></a>01137       ConnectivityArray <span class="keyword">const</span> &amp; connectivity_array);
<a name="l01138"></a>01138 
<a name="l01144"></a>01144   std::istream &amp;
<a name="l01145"></a>01145   operator&gt;&gt;(
<a name="l01146"></a>01146       std::istream &amp; input_stream,
<a name="l01147"></a>01147       ZoltanHyperGraph &amp; zoltan_hypergraph);
<a name="l01148"></a>01148 
<a name="l01154"></a>01154   std::ostream &amp;
<a name="l01155"></a>01155   <a class="code" href="namespaceQCAD.html#a9f60f37fd458154ebfec6bd2e47fdf5b">operator&lt;&lt;</a>(
<a name="l01156"></a>01156       std::ostream &amp; output_stream,
<a name="l01157"></a>01157       ZoltanHyperGraph <span class="keyword">const</span> &amp; zoltan_hypergraph);
<a name="l01158"></a>01158 
<a name="l01159"></a>01159 } <span class="comment">// namespace LCM</span>
<a name="l01160"></a>01160 
<a name="l01161"></a>01161 <span class="preprocessor">#endif // #if !defined(LCM_Partition_h)</span>
<a name="l01162"></a>01162 <span class="preprocessor"></span>
<a name="l01163"></a>01163 <span class="preprocessor">#endif // #if defined (ALBANY_LCM) &amp;&amp; defined(ALBANY_ZOLTAN)</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 26 2014 18:36:39 for Albany: a Trilinos-based PDE code by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
